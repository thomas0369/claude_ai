'use client';

/**
 * Block Puzzle Game - Konva.js Implementation
 *
 * Production-ready game component that replaces Phaser.js
 * Features:
 * - Native drag and drop with Konva
 * - Grid-based placement with validation
 * - Line clearing (rows and columns)
 * - Score tracking with combo multiplier
 * - Block respawning
 * - Debug mode with visual feedback
 * - Level configuration support
 */

import { useEffect, useRef, useState, useCallback } from 'react';
import { Stage, Layer, Rect, Group, Text } from 'react-konva';
import Konva from 'konva';
import type { LevelConfig } from '@/lib/game/levels/levelService';

// Game constants
const GRID_SIZE = 8;
const CELL_SIZE = 50;
const GRID_OFFSET_X = 50;
const GRID_OFFSET_Y = 50;
const SPAWN_Y = GRID_OFFSET_Y + GRID_SIZE * CELL_SIZE + 80;
const STAGE_WIDTH = 600;
const STAGE_HEIGHT = 700;

interface BlockData {
  id: string;
  shape: number[][];
  color: string;
  x: number;
  y: number;
  originalX: number;
  originalY: number;
}

export interface KonvaGameProps {
  level: LevelConfig;
  onScoreUpdate?: (score: number) => void;
  onGameOver?: () => void;
  onLevelComplete?: () => void;
}

export function KonvaGame({ level, onScoreUpdate }: KonvaGameProps) {
  // Game state
  const [grid, setGrid] = useState<number[][]>(() =>
    Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0))
  );
  const [blocks, setBlocks] = useState<BlockData[]>([]);
  const [score, setScore] = useState(0);
  const [comboCount, setComboCount] = useState(0);
  const [activeBlocks, setActiveBlocks] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [dragPreview, setDragPreview] = useState<{
    row: number;
    col: number;
    shape: number[][];
    isValid: boolean;
  } | null>(null);

  const stageRef = useRef<Konva.Stage>(null);
  const levelBlocksRef = useRef<typeof level.blocks>([]);
  const initializedRef = useRef(false);
  const onScoreUpdateRef = useRef(onScoreUpdate);

  // Keep score callback ref up to date
  useEffect(() => {
    onScoreUpdateRef.current = onScoreUpdate;
  }, [onScoreUpdate]);

  // Initialize level blocks ONCE
  useEffect(() => {
    if (!initializedRef.current && level.blocks && level.blocks.length > 0) {
      initializedRef.current = true;
      levelBlocksRef.current = level.blocks;
      spawnBlocks();
      setIsLoading(false);
    }
  }, [level.levelNumber]); // Only re-initialize when level number changes

  // Update score callback (using ref to prevent infinite loop)
  useEffect(() => {
    if (onScoreUpdateRef.current) {
      onScoreUpdateRef.current(score);
    }
  }, [score]);

  /**
   * Spawn 3 random blocks from level configuration
   */
  const spawnBlocks = useCallback(() => {
    if (!levelBlocksRef.current || levelBlocksRef.current.length === 0) {
      console.warn('No blocks available to spawn');
      return;
    }

    const newBlocks: BlockData[] = [];
    const availableBlocks = levelBlocksRef.current;

    for (let i = 0; i < 3; i++) {
      // Get random block from level config
      const blockConfig = availableBlocks[Math.floor(Math.random() * availableBlocks.length)];

      const startX = 100 + i * 150;

      newBlocks.push({
        id: `block-${Date.now()}-${i}`,
        shape: blockConfig.shape,
        color: blockConfig.color,
        x: startX,
        y: SPAWN_Y,
        originalX: startX,
        originalY: SPAWN_Y,
      });
    }

    setBlocks(newBlocks);
    setActiveBlocks(3);
    console.log('‚ú® 3 new blocks spawned');
  }, []);

  /**
   * Convert world coordinates to grid position
   * Uses rounding instead of floor for better snap-to-grid behavior
   */
  const worldToGrid = useCallback((worldX: number, worldY: number, useSnapping = true) => {
    const gridX = worldX - GRID_OFFSET_X;
    const gridY = worldY - GRID_OFFSET_Y;

    // Check if position is within grid bounds
    if (gridX < -CELL_SIZE / 2 || gridY < -CELL_SIZE / 2 ||
        gridX > GRID_SIZE * CELL_SIZE + CELL_SIZE / 2 ||
        gridY > GRID_SIZE * CELL_SIZE + CELL_SIZE / 2) {
      return null;
    }

    // Use rounding for snap-to-grid behavior instead of floor
    // This makes the block snap to the nearest cell center
    const col = useSnapping
      ? Math.round(gridX / CELL_SIZE)
      : Math.floor(gridX / CELL_SIZE);
    const row = useSnapping
      ? Math.round(gridY / CELL_SIZE)
      : Math.floor(gridY / CELL_SIZE);

    // Ensure we're still within bounds after rounding
    if (row < 0 || col < 0 || row >= GRID_SIZE || col >= GRID_SIZE) {
      return null;
    }

    return { row, col };
  }, []);

  /**
   * Check if a block can be placed at the given position
   */
  const canPlaceBlock = useCallback((row: number, col: number, shape: number[][]) => {
    if (row < 0 || col < 0) return false;
    if (row + shape.length > GRID_SIZE) return false;
    if (col + shape[0].length > GRID_SIZE) return false;

    for (let r = 0; r < shape.length; r++) {
      for (let c = 0; c < shape[r].length; c++) {
        if (shape[r][c] === 1 && grid[row + r][col + c] !== 0) {
          return false;
        }
      }
    }

    return true;
  }, [grid]);

  /**
   * Check and clear completed lines (rows and columns)
   */
  const checkAndClearLines = useCallback((currentGrid: number[][]) => {
    const newGrid = currentGrid.map(row => [...row]);
    let linesCleared = 0;
    const clearedRows: number[] = [];
    const clearedCols: number[] = [];

    // Check rows
    for (let row = 0; row < GRID_SIZE; row++) {
      if (newGrid[row].every(cell => cell !== 0)) {
        newGrid[row].fill(0);
        linesCleared++;
        clearedRows.push(row);
        console.log(`üéâ Row ${row} cleared!`);
      }
    }

    // Check columns
    for (let col = 0; col < GRID_SIZE; col++) {
      const columnFilled = newGrid.every(row => row[col] !== 0);
      if (columnFilled) {
        for (let row = 0; row < GRID_SIZE; row++) {
          newGrid[row][col] = 0;
        }
        linesCleared++;
        clearedCols.push(col);
        console.log(`üéâ Column ${col} cleared!`);
      }
    }

    return { linesCleared, clearedRows, clearedCols, newGrid };
  }, []);

  /**
   * Place a block on the grid
   */
  const placeBlock = useCallback((blockId: string, row: number, col: number, shape: number[][], color: string) => {
    console.log(`üé® Placing block at [${row}][${col}]`);

    const newGrid = grid.map(row => [...row]);
    const colorValue = parseInt(color.replace('#', ''), 16);
    let cellsPlaced = 0;

    // Place block cells on grid
    for (let r = 0; r < shape.length; r++) {
      for (let c = 0; c < shape[r].length; c++) {
        if (shape[r][c] === 1) {
          newGrid[row + r][col + c] = colorValue;
          cellsPlaced++;
        }
      }
    }

    setGrid(newGrid);

    // Remove the placed block
    setBlocks(prev => prev.filter(b => b.id !== blockId));
    const newActiveCount = activeBlocks - 1;
    setActiveBlocks(newActiveCount);

    // Add score for placed cells
    const cellScore = cellsPlaced * 10;
    setScore(prev => prev + cellScore);

    // Check for completed lines
    setTimeout(() => {
      const { linesCleared, clearedRows, clearedCols, newGrid: clearedGrid } = checkAndClearLines(newGrid);

      if (linesCleared > 0) {
        setGrid(clearedGrid);

        // Update combo and score
        setComboCount(prev => {
          const newCombo = prev + 1;
          const lineScore = linesCleared * 100 * newCombo;
          setScore(prevScore => prevScore + lineScore);

          console.log('üéØ SCORE UPDATE', {
            linesCleared,
            combo: newCombo,
            lineScore,
            clearedRows,
            clearedCols
          });

          return newCombo;
        });
      } else {
        // Reset combo if no lines cleared
        setComboCount(0);
      }

      // Spawn new blocks if all placed
      if (newActiveCount === 0) {
        console.log('üîÑ All blocks placed, spawning new set...');
        setTimeout(spawnBlocks, 500);
      }
    }, 100);
  }, [grid, activeBlocks, spawnBlocks, checkAndClearLines]);

  /**
   * Handle drag move for a block - show preview of placement
   */
  const handleDragMove = useCallback((blockId: string) => (e: Konva.KonvaEventObject<DragEvent>) => {
    const block = blocks.find(b => b.id === blockId);
    if (!block) return;

    const shape = e.target;
    const x = shape.x();
    const y = shape.y();

    // Calculate the top-left corner point of the block for grid alignment
    // Don't use center - use top-left for accurate grid cell detection
    const centerX = x;
    const centerY = y;

    // Get grid position
    const gridPos = worldToGrid(centerX, centerY, true);

    if (gridPos) {
      const { row, col } = gridPos;
      const isValid = canPlaceBlock(row, col, block.shape);
      setDragPreview({ row, col, shape: block.shape, isValid });
    } else {
      setDragPreview(null);
    }
  }, [blocks, worldToGrid, canPlaceBlock]);

  /**
   * Handle drag end for a block
   * Improved with better positioning calculation and visual snapping
   */
  const handleDragEnd = useCallback((blockId: string) => (e: Konva.KonvaEventObject<DragEvent>) => {
    const block = blocks.find(b => b.id === blockId);
    if (!block) return;

    // Clear drag preview
    setDragPreview(null);

    const shape = e.target;
    const x = shape.x();
    const y = shape.y();

    console.log(`üéØ Block dropped at (${Math.round(x)}, ${Math.round(y)})`);

    // Use the top-left corner for grid alignment
    // This ensures accurate placement matching the visual block position
    const gridPos = worldToGrid(x, y, true);

    if (!gridPos) {
      console.log('‚ùå Not on grid, returning to origin');
      // Return to original position with animation
      shape.to({
        x: block.originalX,
        y: block.originalY,
        duration: 0.3,
      });
      return;
    }

    const { row, col } = gridPos;
    console.log(`üé≤ Calculated grid position: [${row}][${col}]`);

    if (canPlaceBlock(row, col, block.shape)) {
      console.log(`‚úÖ Valid placement at [${row}][${col}]`);

      // Snap to grid position visually before placing
      const snapX = GRID_OFFSET_X + col * CELL_SIZE;
      const snapY = GRID_OFFSET_Y + row * CELL_SIZE;

      console.log(`‚ú® Snapping to grid position: (${snapX}, ${snapY})`);

      // Animate to exact grid position
      shape.to({
        x: snapX,
        y: snapY,
        duration: 0.15,
        onFinish: () => {
          placeBlock(blockId, row, col, block.shape, block.color);
        }
      });
    } else {
      console.log(`‚ùå Invalid placement at [${row}][${col}], returning to origin`);
      // Return to original position with animation
      shape.to({
        x: block.originalX,
        y: block.originalY,
        duration: 0.3,
      });
    }
  }, [blocks, worldToGrid, canPlaceBlock, placeBlock]);

  if (isLoading) {
    return (
      <div className="flex items-center justify-center bg-gray-800 rounded-xl shadow-2xl p-4 border border-gray-700" style={{ width: STAGE_WIDTH, height: STAGE_HEIGHT }}>
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-green-500 mx-auto mb-4"></div>
          <p className="text-white text-xl">Loading Konva Game...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="flex flex-col items-center">
      {/* Konva Stage */}
      <div className="bg-gray-800 rounded-xl shadow-2xl p-4 border border-gray-700">
        <Stage
          width={STAGE_WIDTH}
          height={STAGE_HEIGHT}
          ref={stageRef}
        >
          {/* Grid Layer */}
          <Layer>
            {/* Grid background */}
            <Rect
              x={GRID_OFFSET_X}
              y={GRID_OFFSET_Y}
              width={GRID_SIZE * CELL_SIZE}
              height={GRID_SIZE * CELL_SIZE}
              fill="#1a1a2e"
              stroke="#2a2a3e"
              strokeWidth={2}
            />

            {/* Grid cells */}
            {Array.from({ length: GRID_SIZE }).map((_, row) =>
              Array.from({ length: GRID_SIZE }).map((_, col) => {
                const cellValue = grid[row][col];
                const x = GRID_OFFSET_X + col * CELL_SIZE;
                const y = GRID_OFFSET_Y + row * CELL_SIZE;

                return (
                  <Group key={`cell-${row}-${col}`}>
                    {/* Cell border */}
                    <Rect
                      x={x}
                      y={y}
                      width={CELL_SIZE}
                      height={CELL_SIZE}
                      stroke="#2a2a4e"
                      strokeWidth={1}
                    />

                    {/* Filled cell */}
                    {cellValue !== 0 && (
                      <Rect
                        x={x + 2}
                        y={y + 2}
                        width={CELL_SIZE - 4}
                        height={CELL_SIZE - 4}
                        fill={`#${cellValue.toString(16).padStart(6, '0')}`}
                        cornerRadius={4}
                      />
                    )}
                  </Group>
                );
              })
            )}

            {/* Instruction text */}
            <Text
              text="Drag blocks onto the grid"
              x={50}
              y={SPAWN_Y - 40}
              fontSize={16}
              fill="#888"
              width={500}
              align="center"
            />
          </Layer>

          {/* Preview Layer - shows where block will be placed */}
          <Layer>
            {dragPreview && (
              <>
                {dragPreview.shape.map((row, r) =>
                  row.map((cell, c) => {
                    if (cell === 1) {
                      const x = GRID_OFFSET_X + (dragPreview.col + c) * CELL_SIZE;
                      const y = GRID_OFFSET_Y + (dragPreview.row + r) * CELL_SIZE;

                      return (
                        <Rect
                          key={`preview-${r}-${c}`}
                          x={x + 2}
                          y={y + 2}
                          width={CELL_SIZE - 4}
                          height={CELL_SIZE - 4}
                          fill={dragPreview.isValid ? '#22c55e' : '#ef4444'}
                          opacity={0.3}
                          cornerRadius={4}
                          listening={false}
                        />
                      );
                    }
                    return null;
                  })
                )}
              </>
            )}
          </Layer>

          {/* Blocks Layer */}
          <Layer>
            {blocks.map((block) => {
              return (
                <Group
                  key={block.id}
                  x={block.x}
                  y={block.y}
                  draggable
                  onDragMove={handleDragMove(block.id)}
                  onDragEnd={handleDragEnd(block.id)}
                  onDragStart={() => {
                    console.log(`üéØ Drag started: ${block.id}`);
                  }}
                  onMouseEnter={(e) => {
                    const stage = e.target.getStage();
                    if (stage) {
                      stage.container().style.cursor = 'grab';
                    }
                  }}
                  onMouseLeave={(e) => {
                    const stage = e.target.getStage();
                    if (stage) {
                      stage.container().style.cursor = 'default';
                    }
                  }}
                  onMouseDown={(e) => {
                    const stage = e.target.getStage();
                    if (stage) {
                      stage.container().style.cursor = 'grabbing';
                    }
                  }}
                  onMouseUp={(e) => {
                    const stage = e.target.getStage();
                    if (stage) {
                      stage.container().style.cursor = 'grab';
                    }
                  }}
                >
                  {/* Render block shape */}
                  {block.shape.map((row, r) =>
                    row.map((cell, c) => {
                      if (cell === 1) {
                        const x = c * CELL_SIZE;
                        const y = r * CELL_SIZE;

                        return (
                          <Rect
                            key={`${r}-${c}`}
                            x={x}
                            y={y}
                            width={CELL_SIZE - 4}
                            height={CELL_SIZE - 4}
                            fill={block.color}
                            stroke="#ffffff"
                            strokeWidth={2}
                            cornerRadius={6}
                            shadowColor="black"
                            shadowBlur={10}
                            shadowOpacity={0.5}
                          />
                        );
                      }
                      return null;
                    })
                  )}
                </Group>
              );
            })}
          </Layer>
        </Stage>
      </div>

      {/* Info panel - matches demo design */}
      <div className="mt-4 flex gap-4 text-gray-300 text-sm">
        <div className="bg-gray-800/50 px-4 py-2 rounded-lg border border-gray-700">
          <span className="text-gray-400">Active Blocks:</span>{' '}
          <span className="font-bold text-white">{activeBlocks}</span>
        </div>
        {comboCount > 0 && (
          <div className="bg-gray-800/50 px-4 py-2 rounded-lg border border-gray-700">
            <span className="text-gray-400">Combo:</span>{' '}
            <span className="font-bold text-yellow-400">x{comboCount}</span>
          </div>
        )}
        <div className="bg-gray-800/50 px-4 py-2 rounded-lg border border-gray-700">
          <span className="text-gray-400">Engine:</span>{' '}
          <span className="font-bold text-green-400">Konva.js</span>
        </div>
      </div>
    </div>
  );
}
