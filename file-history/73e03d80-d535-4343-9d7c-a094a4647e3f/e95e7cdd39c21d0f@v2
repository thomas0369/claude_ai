/**
 * Edge Browser Laptop Responsive Test
 *
 * Tests the game rendering specifically in Edge browser (Chromium)
 * at typical laptop viewport sizes (100% zoom)
 *
 * This test identifies:
 * - Block positioning and spacing issues
 * - Responsive design problems at laptop sizes
 * - Layout overflow or misalignment
 */

import { test, expect } from '@playwright/test';

// Common laptop viewport sizes
const LAPTOP_VIEWPORTS = [
  { name: '13" Laptop (1366x768)', width: 1366, height: 768 },
  { name: '14" Laptop (1440x900)', width: 1440, height: 900 },
  { name: '15" Laptop (1920x1080)', width: 1920, height: 1080 },
  { name: '15" Laptop (1600x900)', width: 1600, height: 900 },
];

test.describe('Edge Browser Laptop Responsive Design', () => {
  for (const viewport of LAPTOP_VIEWPORTS) {
    test(`Game rendering at ${viewport.name}`, async ({ page }) => {
      // Set viewport to laptop size
      await page.setViewportSize({
        width: viewport.width,
        height: viewport.height
      });

      console.log(`\n=== Testing ${viewport.name} ===`);
      console.log(`Viewport: ${viewport.width}x${viewport.height}`);

      // Navigate to game
      await page.goto('http://localhost:3003/play/1');

      // Wait for game to load
      await page.waitForTimeout(8000);

      // Capture full page screenshot
      const screenshotPath = `edge-laptop-${viewport.width}x${viewport.height}.png`;
      await page.screenshot({
        path: screenshotPath,
        fullPage: true
      });

      console.log(`üì∏ Screenshot saved: ${screenshotPath}`);

      // Analyze Konva stage dimensions
      const stageDimensions = await page.evaluate(() => {
        const canvas = document.querySelector('canvas');
        if (!canvas) return null;

        const canvasRect = canvas.getBoundingClientRect();
        const container = canvas.closest('.bg-white.rounded-xl');
        const containerRect = container?.getBoundingClientRect();

        return {
          canvas: {
            width: canvas.width,
            height: canvas.height,
            displayWidth: canvasRect.width,
            displayHeight: canvasRect.height,
            left: canvasRect.left,
            top: canvasRect.top,
          },
          container: containerRect ? {
            width: containerRect.width,
            height: containerRect.height,
            left: containerRect.left,
            top: containerRect.top,
          } : null,
          viewport: {
            width: window.innerWidth,
            height: window.innerHeight,
          }
        };
      });

      console.log('\nüìä Stage Dimensions:');
      console.log('Canvas:', stageDimensions?.canvas);
      console.log('Container:', stageDimensions?.container);
      console.log('Viewport:', stageDimensions?.viewport);

      // Analyze block positioning
      const blockAnalysis = await page.evaluate(() => {
        const canvas = document.querySelector('canvas');
        if (!canvas) return null;

        const canvasRect = canvas.getBoundingClientRect();
        const container = canvas.closest('.bg-white.rounded-xl');
        const containerRect = container?.getBoundingClientRect();

        // Get info panel (Active Blocks, Engine, etc.)
        const infoPanel = document.querySelector('.mt-6.flex.flex-wrap');
        const infoPanelRect = infoPanel?.getBoundingClientRect();

        return {
          canvasBottom: canvasRect.bottom,
          containerBottom: containerRect?.bottom || 0,
          infoPanelTop: infoPanelRect?.top || 0,
          gapBetweenCanvasAndInfo: infoPanelRect ? (infoPanelRect.top - canvasRect.bottom) : 0,
          canvasOverflow: canvasRect.bottom > (containerRect?.bottom || 0),
          canvasWidth: canvasRect.width,
          containerWidth: containerRect?.width || 0,
          canvasHorizontalOverflow: canvasRect.width > (containerRect?.width || 0),
        };
      });

      console.log('\nüìè Block Positioning Analysis:');
      console.log('Canvas bottom:', blockAnalysis?.canvasBottom);
      console.log('Container bottom:', blockAnalysis?.containerBottom);
      console.log('Info panel top:', blockAnalysis?.infoPanelTop);
      console.log('Gap between canvas and info:', blockAnalysis?.gapBetweenCanvasAndInfo);
      console.log('Canvas overflow:', blockAnalysis?.canvasOverflow);
      console.log('Canvas width:', blockAnalysis?.canvasWidth);
      console.log('Container width:', blockAnalysis?.containerWidth);
      console.log('Horizontal overflow:', blockAnalysis?.canvasHorizontalOverflow);

      // Check for visual issues
      if (blockAnalysis?.canvasOverflow) {
        console.log('‚ö†Ô∏è WARNING: Canvas overflows container vertically!');
      }
      if (blockAnalysis?.canvasHorizontalOverflow) {
        console.log('‚ö†Ô∏è WARNING: Canvas overflows container horizontally!');
      }
      if (blockAnalysis?.gapBetweenCanvasAndInfo && blockAnalysis.gapBetweenCanvasAndInfo < 20) {
        console.log('‚ö†Ô∏è WARNING: Very small gap between canvas and info panel!');
      }

      // Measure responsive behavior
      const responsiveMetrics = await page.evaluate(() => {
        const canvas = document.querySelector('canvas');
        if (!canvas) return null;

        const parentContainer = canvas.closest('.w-full.flex.flex-col.items-center');
        if (!parentContainer) return null;

        return {
          containerWidth: (parentContainer as HTMLElement).offsetWidth,
          canvasWidth: canvas.width,
          cellSizeEstimate: Math.floor(canvas.width / 10), // Rough estimate
        };
      });

      console.log('\nüìê Responsive Metrics:');
      console.log('Parent container width:', responsiveMetrics?.containerWidth);
      console.log('Canvas width:', responsiveMetrics?.canvasWidth);
      console.log('Estimated cell size:', responsiveMetrics?.cellSizeEstimate);

      console.log('\n‚úÖ Test complete for', viewport.name);
      console.log('‚îÄ'.repeat(60));
    });
  }

  test('Analyze block spacing and positioning', async ({ page }) => {
    // Use most common laptop size
    await page.setViewportSize({ width: 1366, height: 768 });

    console.log('\n=== Analyzing Block Spacing ===');

    await page.goto('http://localhost:3003/play/1');
    await page.waitForTimeout(8000);

    // Detailed block analysis
    const blockDetails = await page.evaluate(() => {
      const canvas = document.querySelector('canvas');
      if (!canvas) return null;

      const ctx = (canvas as HTMLCanvasElement).getContext('2d');
      if (!ctx) return null;

      const canvasRect = canvas.getBoundingClientRect();

      // Try to detect block positions by analyzing the canvas
      // (This is a rough heuristic since Konva doesn't expose internals easily)
      return {
        canvasWidth: canvas.width,
        canvasHeight: canvas.height,
        displayWidth: canvasRect.width,
        displayHeight: canvasRect.height,
        aspectRatio: canvas.width / canvas.height,
      };
    });

    console.log('Block Analysis:', blockDetails);

    // Take a detailed screenshot for manual inspection
    await page.screenshot({
      path: 'edge-laptop-block-spacing-analysis.png',
      fullPage: true,
    });

    console.log('üì∏ Detailed screenshot saved: edge-laptop-block-spacing-analysis.png');
  });
});
