/**
 * Demo Block Entity
 *
 * Implements all best practices from research:
 * - Container with explicit hit area
 * - Geometric shapes (Rectangle, not pixel-perfect)
 * - Event listener cleanup
 * - Local coordinate system (0,0 = top-left)
 * - Proper drag event handling
 */

import * as Phaser from 'phaser';
import { CELL_SIZE } from '../config';

export interface BlockData {
  id: string;
  shape: number[][];
  color: string;
}

export class DemoBlock extends Phaser.GameObjects.Container {
  private blockData: BlockData;
  private graphics: Phaser.GameObjects.Graphics;
  private originalX: number = 0;
  private originalY: number = 0;
  private isDragging: boolean = false;

  // Callbacks
  private onPlacedCallback?: (block: DemoBlock, gridX: number, gridY: number) => void;

  constructor(
    scene: Phaser.Scene,
    x: number,
    y: number,
    data: BlockData
  ) {
    super(scene, x, y);

    this.blockData = data;
    this.originalX = x;
    this.originalY = y;

    // Create graphics object for rendering
    this.graphics = scene.add.graphics();
    this.add(this.graphics);

    // Draw the block
    this.drawBlock();

    // Setup interaction (if not empty shape)
    if (this.blockData.shape.length > 0) {
      this.setupInteraction();
    }

    scene.add.existing(this);
  }

  /**
   * Reset block with new data
   * Used by object pool when respawning
   */
  public reset(data: BlockData, x: number, y: number): void {
    this.blockData = data;
    this.originalX = x;
    this.originalY = y;
    this.x = x;
    this.y = y;
    this.setScale(1);
    this.setDepth(0);
    this.isDragging = false;

    // Clear graphics and redraw
    this.graphics.clear();
    this.drawBlock();

    // Setup interaction
    this.setupInteraction();
  }

  /**
   * Setup interaction following best practices:
   * 1. Clear existing event listeners
   * 2. Set Container size
   * 3. Create explicit hit area with geometric shape
   * 4. Attach fresh event listeners
   */
  private setupInteraction(): void {
    // Calculate block dimensions
    const width = this.blockData.shape[0].length * CELL_SIZE;
    const height = this.blockData.shape.length * CELL_SIZE;

    // Clear existing event listeners (prevents duplicates)
    this.off('dragstart');
    this.off('drag');
    this.off('dragend');
    this.off('pointerover');
    this.off('pointerout');

    // Set Container size (required for Containers)
    this.setSize(width, height);

    // Create explicit hit area using geometric shape (Rectangle)
    // IMPORTANT: Use local coordinates (0, 0) = top-left of container
    const hitArea = new Phaser.Geom.Rectangle(0, 0, width, height);

    // Setup interactive with explicit configuration
    this.setInteractive({
      hitArea: hitArea,
      hitAreaCallback: Phaser.Geom.Rectangle.Contains,
      draggable: true,
      useHandCursor: true,
      pixelPerfect: false, // Use geometric shape for performance
    });

    // Attach event listeners
    this.on('dragstart', this.onDragStart, this);
    this.on('drag', this.onDrag, this);
    this.on('dragend', this.onDragEnd, this);
    this.on('pointerover', this.onPointerOver, this);
    this.on('pointerout', this.onPointerOut, this);
  }

  /**
   * Draw the block shape
   */
  private drawBlock(): void {
    this.graphics.clear();

    const shape = this.blockData.shape;
    const color = Phaser.Display.Color.HexStringToColor(this.blockData.color).color;

    for (let row = 0; row < shape.length; row++) {
      for (let col = 0; col < shape[row].length; col++) {
        if (shape[row][col] === 1) {
          const x = col * CELL_SIZE;
          const y = row * CELL_SIZE;

          // Fill
          this.graphics.fillStyle(color, 1);
          this.graphics.fillRect(x, y, CELL_SIZE - 2, CELL_SIZE - 2);

          // Border
          this.graphics.lineStyle(2, 0xffffff, 0.3);
          this.graphics.strokeRect(x, y, CELL_SIZE - 2, CELL_SIZE - 2);
        }
      }
    }
  }

  /**
   * Drag start event handler
   */
  private onDragStart(_pointer: Phaser.Input.Pointer): void {
    this.isDragging = true;
    this.setScale(1.1); // Visual feedback
    this.setDepth(1000); // Bring to front

    console.log(`ðŸŽ¯ Drag started - Block ${this.blockData.id}`);
  }

  /**
   * Drag event handler
   */
  private onDrag(
    _pointer: Phaser.Input.Pointer,
    dragX: number,
    dragY: number
  ): void {
    // Update position
    this.x = dragX;
    this.y = dragY;
  }

  /**
   * Drag end event handler
   */
  private onDragEnd(pointer: Phaser.Input.Pointer): void {
    this.isDragging = false;
    this.setScale(1); // Reset scale
    this.setDepth(0); // Reset depth

    // Check if dropped on valid grid position
    // This would be implemented by the scene
    if (this.onPlacedCallback) {
      // Convert pointer position to grid coordinates
      // For now, just notify the scene
      this.onPlacedCallback(this, pointer.worldX, pointer.worldY);
    }

    console.log(`ðŸ Drag ended - Block ${this.blockData.id}`);
  }

  /**
   * Pointer over event handler
   */
  private onPointerOver(): void {
    if (!this.isDragging) {
      this.setScale(1.05);
    }
  }

  /**
   * Pointer out event handler
   */
  private onPointerOut(): void {
    if (!this.isDragging) {
      this.setScale(1);
    }
  }

  /**
   * Return block to original position
   */
  public returnToOrigin(animate: boolean = true): void {
    if (animate) {
      this.scene.tweens.add({
        targets: this,
        x: this.originalX,
        y: this.originalY,
        duration: 300,
        ease: 'Back.easeOut',
      });
    } else {
      this.x = this.originalX;
      this.y = this.originalY;
    }
  }

  /**
   * Set callback for when block is placed
   */
  public setOnPlacedCallback(
    callback: (block: DemoBlock, x: number, y: number) => void
  ): void {
    this.onPlacedCallback = callback;
  }


  /**
   * Get block data
   */
  public getBlockData(): BlockData {
    return this.blockData;
  }

  /**
   * Cleanup method
   */
  public cleanup(): void {
    // Remove event listeners
    this.off('dragstart');
    this.off('drag');
    this.off('dragend');
    this.off('pointerover');
    this.off('pointerout');
  }

  /**
   * Destroy block
   */
  public destroy(fromScene?: boolean): void {
    this.cleanup();
    super.destroy(fromScene);
  }
}
