'use client';

/**
 * Block Puzzle Game - Konva.js Implementation (Responsive)
 *
 * Production-ready game component with fully responsive design
 * Features:
 * - Native drag and drop with Konva
 * - Grid-based placement with validation
 * - Line clearing (rows and columns)
 * - Score tracking with combo multiplier
 * - Block respawning
 * - Debug mode with visual feedback
 * - Level configuration support
 * - Fully responsive (adapts to any screen size)
 */

import { useEffect, useRef, useState, useCallback } from 'react';
import { Stage, Layer, Rect, Group, Text } from 'react-konva';
import Konva from 'konva';
import type { LevelConfig } from '@/lib/game/levels/levelService';
import { musicManager } from '@/lib/audio/MusicManager';
import { soundEffects } from '@/lib/audio/SoundEffects';
import { haptics } from '@/lib/utils/haptics';
import { ComboFeedback } from './ComboFeedback';
import { Tutorial } from './Tutorial';
import { AudioControls } from './AudioControls';

// Game constants
const GRID_SIZE = 8;

// Responsive sizing constraints
const MIN_CELL_SIZE = 30; // Minimum for mobile
const MAX_CELL_SIZE = 42; // Maximum for large screens (smaller for better fit)
const GRID_OFFSET_RATIO = 0.08; // 8% of stage width/height for offsets
const MIN_STAGE_WIDTH = 320; // Minimum viewport support

interface BlockData {
  id: string;
  shape: number[][];
  color: string;
  x: number;
  y: number;
  originalX: number;
  originalY: number;
}

export interface KonvaGameProps {
  level: LevelConfig;
  onScoreUpdate?: (score: number) => void;
  onGameOver?: () => void;
  onLevelComplete?: () => void;
  onGameplayStart?: () => void;
  immersiveMode?: boolean;
}

/**
 * Calculate responsive dimensions based on container width
 */
function calculateDimensions(containerWidth: number) {
  const safeWidth = Math.max(containerWidth, MIN_STAGE_WIDTH);

  // Calculate cell size based on available width
  // Reserve space for offsets on both sides
  const availableWidth = safeWidth - (safeWidth * GRID_OFFSET_RATIO * 2);
  let cellSize = Math.floor(availableWidth / GRID_SIZE);

  // Clamp cell size to min/max
  cellSize = Math.max(MIN_CELL_SIZE, Math.min(MAX_CELL_SIZE, cellSize));

  // Calculate actual dimensions
  const gridOffsetX = Math.floor(safeWidth * GRID_OFFSET_RATIO);
  const gridOffsetY = gridOffsetX;
  const gridWidth = cellSize * GRID_SIZE;
  const stageWidth = gridWidth + (gridOffsetX * 2);
  const spawnY = gridOffsetY + gridWidth + Math.floor(cellSize * 1.5);
  // Increase space for blocks - assume max 3x3 block size + comfortable spacing
  const maxBlockHeight = cellSize * 3; // Max block is 3 cells tall
  const stageHeight = spawnY + maxBlockHeight + (cellSize * 1.5); // Extra space for comfortable touch

  return {
    cellSize,
    gridOffsetX,
    gridOffsetY,
    stageWidth,
    stageHeight,
    spawnY,
  };
}

export function KonvaGame({ level, onScoreUpdate, onGameOver, onLevelComplete, onGameplayStart, immersiveMode = false }: KonvaGameProps) {
  // Responsive dimensions state
  const [dimensions, setDimensions] = useState(() => calculateDimensions(800)); // Default for SSR

  // Game state
  const [grid, setGrid] = useState<number[][]>(() =>
    Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0))
  );
  const [blocks, setBlocks] = useState<BlockData[]>([]);
  const [score, setScore] = useState(0);
  const [comboCount, setComboCount] = useState(0);
  const [activeBlocks, setActiveBlocks] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [isGameOver, setIsGameOver] = useState(false);
  const [isLevelWon, setIsLevelWon] = useState(false);
  const [dragPreview, setDragPreview] = useState<{
    row: number;
    col: number;
    shape: number[][];
    isValid: boolean;
  } | null>(null);

  // New engagement features state
  const [showTutorial, setShowTutorial] = useState(!immersiveMode);
  const [showComboFeedback, setShowComboFeedback] = useState(false);
  const [lastClearedLines, setLastClearedLines] = useState(0);
  const [audioInitialized, setAudioInitialized] = useState(false);
  const [showInstructions, setShowInstructions] = useState(!immersiveMode);
  const [hasInteracted, setHasInteracted] = useState(false);

  const stageRef = useRef<Konva.Stage>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const levelBlocksRef = useRef<typeof level.blocks>([]);
  const initializedRef = useRef(false);
  const onScoreUpdateRef = useRef(onScoreUpdate);

  // Keep score callback ref up to date
  useEffect(() => {
    onScoreUpdateRef.current = onScoreUpdate;
  }, [onScoreUpdate]);

  // Initialize audio systems on first user interaction
  useEffect(() => {
    if (!audioInitialized) {
      const initAudio = () => {
        musicManager.initialize();
        soundEffects.initialize();
        setAudioInitialized(true);

        // Start music (user can mute via controls)
        musicManager.play();
      };

      // CRITICAL FIX: Use { once: true } to auto-remove listeners after first trigger
      // This prevents memory leaks and ensures cleanup even if component unmounts
      document.addEventListener('click', initAudio, { once: true });
      document.addEventListener('touchstart', initAudio, { once: true });

      return () => {
        // Cleanup in case component unmounts before user interaction
        document.removeEventListener('click', initAudio);
        document.removeEventListener('touchstart', initAudio);
      };
    }
    return undefined;
  }, [audioInitialized]);

  // Handle responsive resize
  useEffect(() => {
    const updateDimensions = () => {
      // Detect mobile/tablet vs desktop
      const isMobile = window.innerWidth < 768; // Tailwind's 'md' breakpoint
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      // In immersive mode, maximize grid to fit viewport
      // Desktop: use container width, capped at 600px
      let maxGameWidth: number;

      if (immersiveMode && isMobile) {
        // Immersive mode: use full viewport, optimized for vertical space
        const maxWidthFromHeight = Math.floor(viewportHeight * 0.85); // Leave space for blocks
        maxGameWidth = Math.min(viewportWidth * 0.95, maxWidthFromHeight, 600);
      } else if (isMobile) {
        // Normal mobile: 98% width
        maxGameWidth = Math.min(viewportWidth * 0.98, 600);
      } else {
        // Desktop: 70% width
        maxGameWidth = Math.min(viewportWidth * 0.7, 600);
      }

      const availableWidth = containerRef.current?.offsetWidth || maxGameWidth;
      const calculatedWidth = Math.min(availableWidth, maxGameWidth);

      setDimensions(calculateDimensions(calculatedWidth));
    };

    // Set initial dimensions after a short delay to ensure DOM is ready
    setTimeout(updateDimensions, 100);

    // Add resize listener with debounce
    let resizeTimer: NodeJS.Timeout;
    const debouncedResize = () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(updateDimensions, 150);
    };

    window.addEventListener('resize', debouncedResize);
    return () => {
      window.removeEventListener('resize', debouncedResize);
      clearTimeout(resizeTimer);
    };
  }, [immersiveMode]);

  // Initialize level blocks ONCE
  useEffect(() => {
    if (!initializedRef.current && level.blocks && level.blocks.length > 0) {
      initializedRef.current = true;
      levelBlocksRef.current = level.blocks;
      spawnBlocks();
      setIsLoading(false);
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [level.levelNumber]); // Only re-initialize when level number changes

  // Update score callback (using ref to prevent infinite loop)
  useEffect(() => {
    if (onScoreUpdateRef.current) {
      onScoreUpdateRef.current(score);
    }
  }, [score]);

  // Check for level completion when score changes
  useEffect(() => {
    if (score >= level.targetScore && !isLevelWon && !isGameOver) {
      setIsLevelWon(true);

      // Play victory feedback
      soundEffects.play('levelWin');
      haptics.levelComplete();

      if (onLevelComplete) {
        onLevelComplete();
      }
    }
  }, [score, level.targetScore, isLevelWon, isGameOver, onLevelComplete]);

  /**
   * Spawn 3 random blocks from level configuration
   * Improved positioning to prevent overlap
   */
  const spawnBlocks = useCallback(() => {
    if (!levelBlocksRef.current || levelBlocksRef.current.length === 0) {
      return;
    }

    const newBlocks: BlockData[] = [];
    const availableBlocks = levelBlocksRef.current;

    // First, select the blocks and calculate their actual widths
    const selectedBlocks = [];
    for (let i = 0; i < 3; i++) {
      const blockConfig = availableBlocks[Math.floor(Math.random() * availableBlocks.length)];
      const blockWidth = blockConfig.shape[0].length * dimensions.cellSize;
      selectedBlocks.push({
        config: blockConfig,
        width: blockWidth,
      });
    }

    // Calculate total width needed
    const totalBlocksWidth = selectedBlocks.reduce((sum, block) => sum + block.width, 0);
    const gap = dimensions.cellSize * 0.5; // Half cell gap between blocks
    const totalGapsWidth = gap * 4; // gaps: [start] block [gap] block [gap] block [end]
    const totalNeededWidth = totalBlocksWidth + totalGapsWidth;
    const availableWidth = dimensions.stageWidth - (dimensions.gridOffsetX * 2);

    // Calculate starting X position to center all blocks together
    let currentX = dimensions.gridOffsetX + (availableWidth - totalNeededWidth) / 2 + gap;

    // Position blocks side by side with proper spacing
    for (let i = 0; i < selectedBlocks.length; i++) {
      const { config, width } = selectedBlocks[i];

      newBlocks.push({
        id: `block-${Date.now()}-${i}`,
        shape: config.shape,
        color: config.color,
        x: currentX,
        y: dimensions.spawnY,
        originalX: currentX,
        originalY: dimensions.spawnY,
      });

      // Move to next position (current block width + gap)
      currentX += width + gap;
    }

    // Set blocks with staggered animation
    setBlocks([]);
    newBlocks.forEach((block, index) => {
      setTimeout(() => {
        setBlocks(prev => [...prev, block]);
        if (index === newBlocks.length - 1) {
          setActiveBlocks(3);
        }
      }, index * 150); // 150ms delay between each block
    });
  }, [dimensions]);


  /**
   * Convert world coordinates to grid position
   * Uses floor for accurate top-left corner alignment
   */
  const worldToGrid = useCallback((worldX: number, worldY: number) => {
    const gridX = worldX - dimensions.gridOffsetX;
    const gridY = worldY - dimensions.gridOffsetY;

    // Check if position is within grid bounds (with small tolerance)
    if (gridX < 0 || gridY < 0 ||
        gridX >= GRID_SIZE * dimensions.cellSize ||
        gridY >= GRID_SIZE * dimensions.cellSize) {
      return null;
    }

    // Use floor to detect which cell the top-left corner is in
    // This gives accurate placement matching the visual position
    const col = Math.floor(gridX / dimensions.cellSize);
    const row = Math.floor(gridY / dimensions.cellSize);

    // Ensure we're within bounds
    if (row < 0 || col < 0 || row >= GRID_SIZE || col >= GRID_SIZE) {
      return null;
    }

    return { row, col };
  }, [dimensions]);

  /**
   * Check if a block can be placed at the given position
   */
  const canPlaceBlock = useCallback((row: number, col: number, shape: number[][]) => {
    if (row < 0 || col < 0) return false;
    if (row + shape.length > GRID_SIZE) return false;
    if (col + shape[0].length > GRID_SIZE) return false;

    for (let r = 0; r < shape.length; r++) {
      for (let c = 0; c < shape[r].length; c++) {
        if (shape[r][c] === 1 && grid[row + r][col + c] !== 0) {
          return false;
        }
      }
    }

    return true;
  }, [grid]);

  /**
   * Check if any of the current blocks can be placed anywhere on the grid
   * Returns true if at least one move is possible, false if game over
   */
  const checkMovesAvailable = useCallback((currentBlocks: BlockData[]) => {
    // Try each block
    for (const block of currentBlocks) {
      // Try each position on the grid
      for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = 0; col < GRID_SIZE; col++) {
          if (canPlaceBlock(row, col, block.shape)) {
            // Found at least one valid move
            return true;
          }
        }
      }
    }
    // No valid moves found - game over
    return false;
  }, [canPlaceBlock]);

  // Check for game over after blocks change
  useEffect(() => {
    if (blocks.length > 0 && !isLoading && !isGameOver) {
      // Small delay to ensure grid state is updated
      const timer = setTimeout(() => {
        const movesAvailable = checkMovesAvailable(blocks);
        if (!movesAvailable) {
          setIsGameOver(true);

          // Play game over feedback
          soundEffects.play('gameOver');
          haptics.gameOver();

          if (onGameOver) {
            onGameOver();
          }
        }
      }, 100);
      return () => clearTimeout(timer);
    }
    return undefined;
  }, [blocks, isLoading, isGameOver, checkMovesAvailable, onGameOver]);

  /**
   * Check and clear completed lines (rows and columns)
   */
  const checkAndClearLines = useCallback((currentGrid: number[][]) => {
    const newGrid = currentGrid.map(row => [...row]);
    let linesCleared = 0;
    const clearedRows: number[] = [];
    const clearedCols: number[] = [];

    // Check rows
    for (let row = 0; row < GRID_SIZE; row++) {
      if (newGrid[row].every(cell => cell !== 0)) {
        newGrid[row].fill(0);
        linesCleared++;
        clearedRows.push(row);
      }
    }

    // Check columns
    for (let col = 0; col < GRID_SIZE; col++) {
      const columnFilled = newGrid.every(row => row[col] !== 0);
      if (columnFilled) {
        for (let row = 0; row < GRID_SIZE; row++) {
          newGrid[row][col] = 0;
        }
        linesCleared++;
        clearedCols.push(col);
      }
    }

    return { linesCleared, clearedRows, clearedCols, newGrid };
  }, []);

  /**
   * Place a block on the grid
   */
  const placeBlock = useCallback((blockId: string, row: number, col: number, shape: number[][], color: string) => {
    const newGrid = grid.map(row => [...row]);
    const colorValue = parseInt(color.replace('#', ''), 16);
    let cellsPlaced = 0;

    // Place block cells on grid
    for (let r = 0; r < shape.length; r++) {
      for (let c = 0; c < shape[r].length; c++) {
        if (shape[r][c] === 1) {
          newGrid[row + r][col + c] = colorValue;
          cellsPlaced++;
        }
      }
    }

    setGrid(newGrid);

    // Play block placement feedback
    soundEffects.play('blockPlace');
    haptics.blockPlace();

    // Remove the placed block
    setBlocks(prev => prev.filter(b => b.id !== blockId));
    const newActiveCount = activeBlocks - 1;
    setActiveBlocks(newActiveCount);

    // Add score for placed cells
    const cellScore = cellsPlaced * 10;
    setScore(prev => prev + cellScore);

    // Check for completed lines
    setTimeout(() => {
      const { linesCleared, newGrid: clearedGrid } = checkAndClearLines(newGrid);

      if (linesCleared > 0) {
        setGrid(clearedGrid);

        // Play clear feedback
        if (linesCleared === 1) {
          soundEffects.play('lineClear');
        } else {
          soundEffects.playMultiClear(linesCleared);
        }
        haptics.lineClear(linesCleared);

        // Update combo and score
        setComboCount(prev => {
          const newCombo = prev + 1;
          const lineScore = linesCleared * 100 * newCombo;
          setScore(prevScore => prevScore + lineScore);

          // Play combo feedback
          if (newCombo > 1) {
            soundEffects.playCombo(newCombo);
            haptics.comboAchieved(newCombo);
          }

          // Show visual feedback
          setLastClearedLines(linesCleared);
          setShowComboFeedback(true);

          return newCombo;
        });
      } else {
        // Reset combo if no lines cleared
        setComboCount(0);
      }

      // Spawn new blocks if all placed
      if (newActiveCount === 0) {
        setTimeout(spawnBlocks, 500);
      }
    }, 100);
  }, [grid, activeBlocks, spawnBlocks, checkAndClearLines]);

  /**
   * Find the nearest valid position for a block near the grid
   * Returns null if no valid position within snap radius
   */
  const findNearestValidPosition = useCallback((x: number, y: number, shape: number[][]) => {
    // Define snap radius (1.5 cells)
    const snapRadius = dimensions.cellSize * 1.5;

    // Try positions in a spiral pattern around the drop point
    const centerRow = Math.round((y - dimensions.gridOffsetY) / dimensions.cellSize);
    const centerCol = Math.round((x - dimensions.gridOffsetX) / dimensions.cellSize);

    let bestPosition: { row: number; col: number; distance: number } | null = null;

    // Search in expanding radius
    for (let radius = 0; radius <= 2; radius++) {
      for (let row = centerRow - radius; row <= centerRow + radius; row++) {
        for (let col = centerCol - radius; col <= centerCol + radius; col++) {
          // Check bounds
          if (row < 0 || col < 0 || row >= GRID_SIZE || col >= GRID_SIZE) continue;

          // Check if this position is valid
          if (canPlaceBlock(row, col, shape)) {
            // Calculate actual pixel position
            const posX = dimensions.gridOffsetX + col * dimensions.cellSize;
            const posY = dimensions.gridOffsetY + row * dimensions.cellSize;

            // Calculate distance from drop point
            const distance = Math.sqrt(Math.pow(x - posX, 2) + Math.pow(y - posY, 2));

            // Only consider if within snap radius
            if (distance <= snapRadius) {
              if (!bestPosition || distance < bestPosition.distance) {
                bestPosition = { row, col, distance };
              }
            }
          }
        }
      }
    }

    return bestPosition ? { row: bestPosition.row, col: bestPosition.col } : null;
  }, [dimensions, canPlaceBlock]);

  /**
   * Handle drag move for a block - show preview of placement
   */
  const handleDragMove = useCallback((blockId: string) => (e: Konva.KonvaEventObject<DragEvent>) => {
    const block = blocks.find(b => b.id === blockId);
    if (!block) return;

    // Trigger gameplay start on first interaction
    if (!hasInteracted) {
      setHasInteracted(true);
      setShowInstructions(false);
      if (onGameplayStart) {
        onGameplayStart();
      }
    }

    const shape = e.target;
    const x = shape.x();
    const y = shape.y();

    // Get grid position
    const gridPos = worldToGrid(x, y);

    if (gridPos) {
      const { row, col } = gridPos;
      const isValid = canPlaceBlock(row, col, block.shape);
      setDragPreview({ row, col, shape: block.shape, isValid });
    } else {
      setDragPreview(null);
    }
  }, [blocks, worldToGrid, canPlaceBlock, hasInteracted, onGameplayStart]);

  /**
   * Handle drag end for a block
   * Improved with magnetic snapping to nearest valid position
   */
  const handleDragEnd = useCallback((blockId: string) => (e: Konva.KonvaEventObject<DragEvent>) => {
    const block = blocks.find(b => b.id === blockId);
    if (!block) return;

    // Clear drag preview
    setDragPreview(null);

    const shape = e.target;
    const x = shape.x();
    const y = shape.y();

    // First, try exact grid position
    const gridPos = worldToGrid(x, y);
    let targetRow: number;
    let targetCol: number;

    if (gridPos && canPlaceBlock(gridPos.row, gridPos.col, block.shape)) {
      // Exact position is valid
      targetRow = gridPos.row;
      targetCol = gridPos.col;
    } else {
      // Try to find nearest valid position (magnetic snap)
      const nearestPos = findNearestValidPosition(x, y, block.shape);

      if (nearestPos) {
        targetRow = nearestPos.row;
        targetCol = nearestPos.col;
      } else {
        // Return to original position with animation
        shape.to({
          x: block.originalX,
          y: block.originalY,
          duration: 0.3,
        });
        return;
      }
    }

    // Snap to target grid position visually before placing
    const snapX = dimensions.gridOffsetX + targetCol * dimensions.cellSize;
    const snapY = dimensions.gridOffsetY + targetRow * dimensions.cellSize;

    // Animate to exact grid position
    shape.to({
      x: snapX,
      y: snapY,
      duration: 0.15,
      onFinish: () => {
        placeBlock(blockId, targetRow, targetCol, block.shape, block.color);
      }
    });
  }, [blocks, worldToGrid, canPlaceBlock, findNearestValidPosition, placeBlock, dimensions]);

  if (isLoading) {
    return (
      <div className="w-full flex flex-col items-center" ref={containerRef}>
        <div className="flex items-center justify-center bg-white rounded-xl shadow-lg p-6 border border-gray-200" style={{ width: dimensions.stageWidth, height: dimensions.stageHeight }}>
          <div className="text-center">
            <div className="animate-spin rounded-full h-16 w-16 border-b-4 border-blue-500 mx-auto mb-4"></div>
            <p className="text-gray-700 text-xl font-medium">Loading Game...</p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full flex flex-col items-center" ref={containerRef}>
      {/* Konva Stage - Minimal padding on mobile for max space */}
      <div className="bg-white rounded-xl shadow-lg p-2 md:p-6 border border-gray-200" style={{ touchAction: 'none', userSelect: 'none', WebkitUserSelect: 'none' }}>
        <Stage
          width={dimensions.stageWidth}
          height={dimensions.stageHeight}
          ref={stageRef}
          listening={true}
        >
          {/* Grid Layer */}
          <Layer>
            {/* Grid background */}
            <Rect
              x={dimensions.gridOffsetX}
              y={dimensions.gridOffsetY}
              width={GRID_SIZE * dimensions.cellSize}
              height={GRID_SIZE * dimensions.cellSize}
              fill="#f8fafc"
              stroke="#cbd5e1"
              strokeWidth={3}
              cornerRadius={8}
            />

            {/* Grid cells */}
            {Array.from({ length: GRID_SIZE }).map((_, row) =>
              Array.from({ length: GRID_SIZE }).map((_, col) => {
                const cellValue = grid[row][col];
                const x = dimensions.gridOffsetX + col * dimensions.cellSize;
                const y = dimensions.gridOffsetY + row * dimensions.cellSize;

                return (
                  <Group key={`cell-${row}-${col}`}>
                    {/* Cell border */}
                    <Rect
                      x={x}
                      y={y}
                      width={dimensions.cellSize}
                      height={dimensions.cellSize}
                      stroke="#e2e8f0"
                      strokeWidth={1.5}
                    />

                    {/* Filled cell */}
                    {cellValue !== 0 && (
                      <Rect
                        x={x + 3}
                        y={y + 3}
                        width={dimensions.cellSize - 6}
                        height={dimensions.cellSize - 6}
                        fill={`#${cellValue.toString(16).padStart(6, '0')}`}
                        cornerRadius={6}
                        shadowColor="rgba(0,0,0,0.15)"
                        shadowBlur={4}
                        shadowOffset={{x: 0, y: 2}}
                        shadowOpacity={0.3}
                      />
                    )}
                  </Group>
                );
              })
            )}

            {/* Instruction text - Hide after first interaction */}
            {showInstructions && (
              <Text
                text="Drag blocks onto the grid"
                x={dimensions.gridOffsetX}
                y={dimensions.spawnY - dimensions.cellSize}
                fontSize={Math.max(14, Math.min(18, dimensions.cellSize * 0.3))}
                fill="#64748b"
                fontStyle="500"
                width={dimensions.stageWidth - (dimensions.gridOffsetX * 2)}
                align="center"
              />
            )}
          </Layer>

          {/* Preview Layer - shows where block will be placed */}
          <Layer>
            {dragPreview && (
              <>
                {dragPreview.shape.map((row, r) =>
                  row.map((cell, c) => {
                    if (cell === 1) {
                      const x = dimensions.gridOffsetX + (dragPreview.col + c) * dimensions.cellSize;
                      const y = dimensions.gridOffsetY + (dragPreview.row + r) * dimensions.cellSize;

                      return (
                        <Rect
                          key={`preview-${r}-${c}`}
                          x={x + 3}
                          y={y + 3}
                          width={dimensions.cellSize - 6}
                          height={dimensions.cellSize - 6}
                          fill={dragPreview.isValid ? '#22c55e' : '#ef4444'}
                          opacity={0.4}
                          cornerRadius={6}
                          listening={false}
                          stroke={dragPreview.isValid ? '#16a34a' : '#dc2626'}
                          strokeWidth={2}
                        />
                      );
                    }
                    return null;
                  })
                )}
              </>
            )}
          </Layer>

          {/* Blocks Layer */}
          <Layer>
            {blocks.map((block) => {
              return (
                <Group
                  key={block.id}
                  x={block.x}
                  y={block.y}
                  draggable={!isGameOver && !isLevelWon}
                  onDragMove={handleDragMove(block.id)}
                  onDragEnd={handleDragEnd(block.id)}
                  onDragStart={(e) => {
                    // Bring the dragged block to the front
                    e.target.moveToTop();
                    // Light haptic feedback on pickup
                    haptics.blockPickup();
                  }}
                  onMouseEnter={(e) => {
                    const stage = e.target.getStage();
                    if (stage && !isGameOver && !isLevelWon) {
                      stage.container().style.cursor = 'grab';
                    }
                  }}
                  onTouchStart={(e) => {
                    // Improve touch responsiveness
                    e.target.moveToTop();
                    // Light haptic feedback on touch
                    haptics.blockPickup();
                  }}
                  onMouseLeave={(e) => {
                    const stage = e.target.getStage();
                    if (stage) {
                      stage.container().style.cursor = 'default';
                    }
                  }}
                  onMouseDown={(e) => {
                    const stage = e.target.getStage();
                    if (stage) {
                      stage.container().style.cursor = 'grabbing';
                    }
                  }}
                  onMouseUp={(e) => {
                    const stage = e.target.getStage();
                    if (stage) {
                      stage.container().style.cursor = 'grab';
                    }
                  }}
                >
                  {/* Render block shape */}
                  {block.shape.map((row, r) =>
                    row.map((cell, c) => {
                      if (cell === 1) {
                        const x = c * dimensions.cellSize;
                        const y = r * dimensions.cellSize;

                        return (
                          <Rect
                            key={`${r}-${c}`}
                            x={x}
                            y={y}
                            width={dimensions.cellSize - 6}
                            height={dimensions.cellSize - 6}
                            fill={block.color}
                            stroke="#ffffff"
                            strokeWidth={3}
                            cornerRadius={8}
                            shadowColor="rgba(0,0,0,0.2)"
                            shadowBlur={12}
                            shadowOffset={{x: 0, y: 4}}
                            shadowOpacity={0.4}
                          />
                        );
                      }
                      return null;
                    })
                  )}
                </Group>
              );
            })}
          </Layer>
        </Stage>
      </div>

      {/* Info panel - Only show combo if active */}
      {comboCount > 0 && (
        <div className="mt-6 flex justify-center">
          <div className="bg-gradient-to-r from-yellow-50 to-orange-50 px-5 py-3 rounded-lg border border-orange-200 shadow-sm animate-pulse">
            <span className="text-gray-600 font-medium">Combo:</span>{' '}
            <span className="font-bold text-orange-600">x{comboCount}</span>
          </div>
        </div>
      )}

      {/* Game Over Overlay */}
      {isGameOver && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-2xl shadow-2xl p-8 max-w-md mx-4 text-center">
            <div className="text-6xl mb-4">ðŸŽ®</div>
            <h2 className="text-3xl font-bold text-gray-900 mb-2">Game Over!</h2>
            <p className="text-gray-600 mb-4">Keine weiteren ZÃ¼ge mÃ¶glich</p>
            <div className="bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg p-6 mb-6">
              <div className="text-sm text-gray-600 mb-1">Final Score</div>
              <div className="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-purple-600">
                {score}
              </div>
            </div>
            <button
              onClick={() => window.location.reload()}
              className="w-full bg-gradient-to-r from-blue-500 to-purple-500 text-white font-bold py-3 px-6 rounded-lg hover:from-blue-600 hover:to-purple-600 transition-all shadow-lg"
            >
              Neues Spiel
            </button>
          </div>
        </div>
      )}

      {/* Level Won Overlay */}
      {isLevelWon && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white rounded-2xl shadow-2xl p-8 max-w-md mx-4 text-center">
            <div className="text-6xl mb-4">ðŸŽ‰</div>
            <h2 className="text-3xl font-bold text-gray-900 mb-2">Level Complete!</h2>
            <p className="text-gray-600 mb-4">Du hast das Ziel erreicht!</p>
            <div className="bg-gradient-to-r from-green-50 to-emerald-50 rounded-lg p-6 mb-6">
              <div className="text-sm text-gray-600 mb-1">Final Score</div>
              <div className="text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-green-600 to-emerald-600">
                {score}
              </div>
              <div className="text-sm text-gray-500 mt-2">
                Target: {level.targetScore}
              </div>
            </div>
            <button
              onClick={() => window.location.reload()}
              className="w-full bg-gradient-to-r from-green-500 to-emerald-500 text-white font-bold py-3 px-6 rounded-lg hover:from-green-600 hover:to-emerald-600 transition-all shadow-lg"
            >
              NÃ¤chstes Level
            </button>
          </div>
        </div>
      )}

      {/* Tutorial Overlay */}
      {showTutorial && (
        <Tutorial onComplete={() => setShowTutorial(false)} />
      )}

      {/* Combo Feedback */}
      <ComboFeedback
        combo={comboCount}
        linesCleared={lastClearedLines}
        visible={showComboFeedback}
        onAnimationComplete={() => setShowComboFeedback(false)}
      />

      {/* Audio Controls */}
      <div className="absolute top-4 right-4 z-40">
        <AudioControls />
      </div>
    </div>
  );
}
