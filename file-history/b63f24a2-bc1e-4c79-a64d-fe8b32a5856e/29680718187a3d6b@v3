#!/usr/bin/env python3
"""
ZEREZ JSON Importer
===================

Fast JSON-based importer that uses GraphQL API directly.
Fetches individual products by ID and saves complete structured data.

Advantages over HTML approach:
- 10-20x faster (no browser overhead)
- All 58 fields preserved from GraphQL response
- Structured data ready for analysis
- No parsing errors
- Includes manufacturer names (resolved via tenant API)

Usage:
    python3 zerez_json_importer.py --product-ids '[...]' --output-dir data/zerez/imports --stream-progress
"""

import argparse
import json
import logging
import sys
import time
from pathlib import Path
from typing import Dict, Optional
from zerez_graphql_client import ZEREZGraphQLClient, GRAPHQL_QUERY
from zerez_import_base import (
    ZEREZImporterBase,
    parse_unit_input,
    validate_output_directory
)

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class ZEREZJSONImporter(ZEREZImporterBase):
    """Import ZEREZ product details using GraphQL API."""

    def __init__(self, output_dir: Path, stream_progress: bool = False):
        """Initialize importer with GraphQL client."""
        super().__init__(output_dir, stream_progress)
        # Initialize GraphQL client (with manufacturer name caching)
        self.client = ZEREZGraphQLClient()

    def process_unit(self, unit_data: Dict, model_name: str) -> bool:
        """
        Fetch and save a single unit by ID using GraphQL API.

        Args:
            unit_data: Must contain 'id' field (UUID)
            model_name: Display name for logging

        Returns:
            True if fetched and saved successfully, False otherwise
        """
        unit_id = unit_data.get('id')

        if not unit_id:
            error_msg = f"Invalid data for {model_name}: Unit data missing 'id' field"
            logger.error(f"‚úó {error_msg}")
            self.stats.add_error(error_msg)
            return False

        # Fetch product data from GraphQL API
        product_data = self._fetch_from_graphql(unit_id, model_name)
        if not product_data:
            return False  # Error already logged by _fetch_from_graphql

        # Add import metadata
        enhanced_data = {
            **product_data,
            'importedAt': time.strftime('%Y-%m-%d %H:%M:%S'),
            'importMethod': 'graphql_api',
            'apiVersion': '1.0',
        }

        # Use shared file writer
        success, error = self.writer.save_json(unit_id, enhanced_data, model_name)

        if success:
            self.stats.increment('saved_files')
            return True
        else:
            logger.error(f"‚úó {error}")
            self.stats.add_error(error)
            return False

    def _fetch_from_graphql(self, product_id: str, model_name: str) -> Optional[Dict]:
        """
        Fetch a single product from GraphQL API.

        Returns complete JSON with all 58 fields from GraphQL response:
        - Core: id, unitCode, modelName, certificateNumber
        - Power: maxActivePower, maxActivePowerRange, minActivePowerRange, etc.
        - Electrical: ratedVoltage, ratedCurrent
        - Classification: primaryEnergySource, category, unitTypeId
        - Certification: certificateId, certificateIssueDate, certificateAuthorityId, etc.
        - Manufacturer: manufacturerId, manufacturerName (resolved via tenant API)
        - Status: isVerified, isImported, is4105
        - Dates: createdAt, modifiedAt, validityStartDate, validityEndDate
        - Relationships: Includes raw_data with full GraphQL response

        Args:
            product_id: UUID of the product to fetch
            model_name: Display name for logging

        Returns:
            Complete product data dict or None if fetch failed
        """
        try:
            logger.info(f"üì° Fetching {model_name} (ID: {product_id[:8]}...)")

            # Build GraphQL where clause with ID filter
            where = {
                "id": {
                    "eq": product_id
                }
            }

            # Prepare GraphQL request
            payload = {
                "operationName": "getUnitsForUnitsOverview",
                "variables": {
                    "take": 1,
                    "where": where,
                    "skip": 0
                },
                "query": GRAPHQL_QUERY
            }

            # Execute GraphQL query
            response = self.client.session.post(
                self.client.endpoint,
                json=payload,
                timeout=10
            )

            if response.status_code != 200:
                raise Exception(f"API returned {response.status_code}")

            data = response.json()

            # Check for GraphQL errors
            if 'errors' in data:
                error_messages = [err.get('message', str(err)) for err in data['errors']]
                raise Exception(f"GraphQL errors: {'; '.join(error_messages)}")

            # Extract unit from response
            unit_overview = data.get('data', {}).get('unitOverview', {})
            items = unit_overview.get('items', [])

            if not items:
                raise Exception("Unit not found in GraphQL response")

            # Convert GraphQL item to structured data
            item = items[0]

            # Create structured product data with ALL 58 fields
            product_data = {
                # ===== Core Identifiers =====
                'id': item.get('id'),
                'unitCode': item.get('unitCode'),
                'modelName': item.get('modelName'),
                'certificateNumber': item.get('certificateNumber'),

                # ===== Power Specifications =====
                'maxActivePower': item.get('maxActivePower'),
                'maxActivePowerRange': item.get('maxActivePowerRange'),
                'minActivePowerRange': item.get('minActivePowerRange'),
                'maxApparentPowerRange': item.get('maxApparentPowerRange'),
                'minApparentPowerRange': item.get('minApparentPowerRange'),
                'hasActivePowerRange': item.get('hasActivePowerRange'),
                'hasApparentPowerRange': item.get('hasApparentPowerRange'),

                # ===== Electrical Specifications =====
                'ratedVoltage': item.get('ratedVoltage'),
                'ratedCurrent': item.get('ratedCurrent'),

                # ===== Classification =====
                'primaryEnergySource': item.get('primaryEnergySource'),
                'category': item.get('category'),
                'unitTypeId': item.get('unitTypeId'),

                # ===== Certification Details =====
                'certificateId': item.get('certificateId'),
                'certificateIssueDate': item.get('certificateIssueDate'),
                'certificateAuthorityId': item.get('certificateAuthorityId'),
                'certificateHolderId': item.get('certificateHolderId'),
                'certificateValidityStatusName': item.get('certificateValidityStatusName'),
                'certificateValidityStatusId': item.get('certificateValidityStatusId'),
                'certificateTypeId': item.get('certificateTypeId'),
                'certificateNormIssueDateDescriptions': item.get('certificateNormIssueDateDescriptions'),
                'certificateIsImported': item.get('certificateIsImported'),
                'withTG8Rev25Conformity': item.get('withTG8Rev25Conformity'),

                # ===== Manufacturer Information =====
                'manufacturerId': item.get('manufacturerId'),
                'manufacturerName': None,  # Will be resolved below

                # ===== Status Flags =====
                'isVerified': item.get('isVerified', False),
                'isImported': item.get('isImported', False),
                'is4105': item.get('is4105', False),
                'hasActiveErrorReport': item.get('hasActiveErrorReport', False),

                # ===== Dates =====
                'createdAt': item.get('createdAt'),
                'modifiedAt': item.get('modifiedAt'),
                'validityStartDate': item.get('validityStartDate'),
                'validityEndDate': item.get('validityEndDate'),

                # ===== Metadata =====
                'tenantId': item.get('tenantId'),
                'inEditByTenantId': item.get('inEditByTenantId'),

                # ===== Relationships =====
                'replacedByCertificate': item.get('replacedByCertificate'),
                'parentCertificateForValidityExtension': item.get('parentCertificateForValidityExtension'),

                # ===== Raw GraphQL Response (for debugging/future use) =====
                'raw_graphql_data': item
            }

            # Resolve manufacturer name via tenant() query
            manufacturer_id = product_data['manufacturerId']
            if manufacturer_id:
                product_data['manufacturerName'] = self._resolve_manufacturer_name(manufacturer_id)

            return product_data

        except Exception as e:
            error_msg = f"Failed to fetch {model_name}: {str(e)}"
            logger.error(f"‚úó {error_msg}")
            self.stats.add_error(error_msg)
            return None

    def _resolve_manufacturer_name(self, manufacturer_id: str) -> Optional[str]:
        """
        Resolve manufacturer name from UUID via tenant() GraphQL query.

        Args:
            manufacturer_id: UUID of the manufacturer

        Returns:
            Manufacturer name or None if resolution fails
        """
        logger.info(f"   üè¢ Resolving manufacturer name for {manufacturer_id[:8]}...")

        # Use existing client cache
        if manufacturer_id in self.client._manufacturer_name_cache:
            name = self.client._manufacturer_name_cache[manufacturer_id]
            logger.info(f"   ‚úì Manufacturer (cached): {name}")
            return name

        # Fetch via tenant query
        tenant_query = """
        query GetTenant($id: UUID!) {
          tenant(id: $id) {
            id
            tenantName
          }
        }
        """

        tenant_payload = {
            "operationName": "GetTenant",
            "variables": {"id": manufacturer_id},
            "query": tenant_query
        }

        try:
            tenant_response = self.client.session.post(
                self.client.endpoint,
                json=tenant_payload,
                timeout=5
            )

            if tenant_response.status_code == 200:
                tenant_data = tenant_response.json()
                if 'errors' not in tenant_data:
                    tenant = tenant_data.get('data', {}).get('tenant')
                    if tenant and tenant.get('tenantName'):
                        name = tenant['tenantName']
                        # Cache for future lookups
                        self.client._manufacturer_name_cache[manufacturer_id] = name
                        logger.info(f"   ‚úì Manufacturer: {name}")
                        return name

        except Exception as e:
            logger.warning(f"   ‚ö†Ô∏è  Failed to resolve manufacturer name: {e}")

        return None


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description='Import ZEREZ product details using GraphQL API',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Import specific products with progress streaming
  python3 zerez_json_importer.py \\
    --product-ids '[\"uuid1\", \"uuid2\"]' \\
    --output-dir data/zerez/imports \\
    --stream-progress

  # Import with model names (for better logging)
  python3 zerez_json_importer.py \\
    --product-ids '[{\"id\":\"uuid1\",\"modelName\":\"HSNV 100K-G01\"}]' \\
    --output-dir data/zerez/imports \\
    --stream-progress

Output Format:
  Each product is saved as {uuid}.json with all 58 GraphQL fields including:
  - Core identifiers (id, unitCode, modelName)
  - Power specifications (maxActivePower, voltage ranges)
  - Electrical specs (ratedVoltage, ratedCurrent)
  - Classification (category, primaryEnergySource)
  - Full certification details
  - Manufacturer information (with resolved name)
  - Status flags (isVerified, is4105, isImported)
  - Dates (createdAt, modifiedAt, validity dates)
  - Certificate relationships
  - Raw GraphQL response for future extensibility
        """
    )
    parser.add_argument('--product-ids', required=True, help='JSON array of product IDs or objects')
    parser.add_argument('--output-dir', required=True, help='Output directory for JSON files')
    parser.add_argument('--stream-progress', action='store_true', help='Stream progress updates (for SSE)')

    args = parser.parse_args()

    try:
        # Parse and validate input using shared utility
        units, _ = parse_unit_input(args.product_ids)
        output_dir = Path(args.output_dir)
        validate_output_directory(output_dir)

        # Run importer
        importer = ZEREZJSONImporter(output_dir, stream_progress=args.stream_progress)
        result = importer.process_units(units)

        # Print final result (if not streaming)
        if not args.stream_progress:
            print(json.dumps(result, indent=2))

        # Exit with error code if any failures
        sys.exit(1 if result['failed'] > 0 else 0)

    except ValueError as e:
        print(json.dumps({'error': str(e)}), file=sys.stderr)
        sys.exit(1)

    except KeyboardInterrupt:
        logger.warning("\n‚ö†Ô∏è  Import interrupted by user")
        sys.exit(130)

    except Exception as e:
        logger.error(f"‚ùå Fatal error: {e}")
        print(json.dumps({'error': str(e)}), file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
