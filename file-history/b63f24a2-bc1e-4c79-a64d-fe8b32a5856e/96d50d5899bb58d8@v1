import { spawn, ChildProcess } from 'child_process';
import path from 'path';
import fs from 'fs';

export interface PythonExecutorOptions {
  scriptName: string;
  args?: string[];
  stdin?: string; // JSON string to pass via stdin
  timeout?: number;
  onStdout?: (data: string) => void;
  onStderr?: (data: string) => void;
}

export interface PythonExecutionResult {
  stdout: string;
  stderr: string;
  exitCode: number;
}

/**
 * Utility class for executing Python scripts with consistent error handling,
 * path resolution, and timeout management.
 */
export class PythonExecutor {
  private static readonly DEFAULT_TIMEOUT = 120000; // 2 minutes
  private static _cachedPythonPath: string | null = null;

  /**
   * Get the repository root path from environment or default
   */
  private static getRepoRoot(): string {
    return process.env.REPO_ROOT || path.join(process.cwd(), '..');
  }

  /**
   * Get the Python interpreter path (prioritizes venv, falls back to system)
   *
   * Priority order:
   * 1. PYTHON_EXECUTABLE env var (explicit override)
   * 2. venv/bin/python3 or venv/Scripts/python.exe (if exists)
   * 3. System python3 or python (fallback)
   *
   * Path is cached after first lookup for performance.
   *
   * @returns Absolute path to Python interpreter
   */
  private static getPythonPath(): string {
    // Return cached path if already resolved
    if (this._cachedPythonPath !== null) {
      return this._cachedPythonPath;
    }

    // Allow explicit override via environment variable
    if (process.env.PYTHON_EXECUTABLE) {
      this._cachedPythonPath = process.env.PYTHON_EXECUTABLE;
      return this._cachedPythonPath;
    }

    const repoRoot = this.getRepoRoot();
    const isWindows = process.platform === 'win32';

    // Check platform-specific venv paths
    const venvPython = isWindows
      ? path.join(repoRoot, 'venv', 'Scripts', 'python.exe')
      : path.join(repoRoot, 'venv', 'bin', 'python3');

    // Prefer venv Python if it exists (ensures correct dependency isolation)
    if (fs.existsSync(venvPython)) {
      this._cachedPythonPath = venvPython;
      return venvPython;
    }

    // Fall back to system Python (warn in development mode)
    if (process.env.NODE_ENV === 'development') {
      console.warn(
        `[PythonExecutor] venv not found at ${venvPython}, using system python. ` +
        `This may cause dependency issues. Run: python3 -m venv venv && source venv/bin/activate && pip install -r scripts/requirements.txt`
      );
    }

    this._cachedPythonPath = isWindows ? 'python' : 'python3';
    return this._cachedPythonPath;
  }

  /**
   * Clear cached Python path (useful for testing)
   * @internal
   */
  static _clearCache(): void {
    this._cachedPythonPath = null;
  }

  /**
   * Execute a Python script and return the result
   *
   * @param options - Execution options
   * @returns Promise resolving to stdout content
   * @throws Error if script fails or times out
   */
  static async execute(options: PythonExecutorOptions): Promise<string> {
    const timeout = options.timeout || this.DEFAULT_TIMEOUT;

    return Promise.race([
      this._executeProcess(options),
      this._createTimeoutPromise(timeout, options.scriptName)
    ]);
  }

  /**
   * Create a ReadableStream for Server-Sent Events from Python script output
   *
   * @param options - Execution options
   * @returns ReadableStream for SSE responses
   */
  static createStreamingResponse(options: PythonExecutorOptions): ReadableStream {
    const scriptPath = path.join(this.getRepoRoot(), 'scripts', options.scriptName);
    const encoder = new TextEncoder();

    return new ReadableStream({
      start(controller) {
        const pythonProcess = spawn(PythonExecutor.getPythonPath(), [scriptPath, ...(options.args || [])], {
          env: { ...process.env, PYTHONUNBUFFERED: '1' } // Disable Python output buffering
        });

        pythonProcess.stdout.on('data', (data) => {
          const chunk = data.toString();

          // Send to custom handler if provided
          options.onStdout?.(chunk);

          // Parse and send SSE events
          const lines = chunk.split('\n');
          for (const line of lines) {
            if (line.trim().startsWith('{')) {
              try {
                // Validate it's parseable JSON
                JSON.parse(line);
                controller.enqueue(encoder.encode(`data: ${line}\n\n`));
              } catch (e) {
                // Skip invalid JSON lines
                console.warn(`[Python ${options.scriptName}] Invalid JSON:`, line.slice(0, 100));
              }
            }
          }
        });

        pythonProcess.stderr.on('data', (data) => {
          const chunk = data.toString();
          console.error(`[Python ${options.scriptName}] stderr:`, chunk.slice(0, 200));
          options.onStderr?.(chunk);
        });

        pythonProcess.on('close', (code) => {
          if (code !== 0) {
            controller.enqueue(
              encoder.encode(`data: ${JSON.stringify({
                error: true,
                message: `Python process failed with exit code ${code}`,
                code
              })}\n\n`)
            );
          }
          controller.close();
        });

        pythonProcess.on('error', (error: NodeJS.ErrnoException) => {
          console.error(`[Python ${options.scriptName}] Spawn failed:`, error.message);

          let errorMessage = `Failed to start Python process: ${error.message}`;

          if (error.code === 'ENOENT') {
            const pythonPath = PythonExecutor.getPythonPath();
            errorMessage =
              `Python interpreter not found at: ${pythonPath}\n\n` +
              `Troubleshooting:\n` +
              `1. Verify Python is installed: python3 --version\n` +
              `2. Set up virtual environment: python3 -m venv venv\n` +
              `3. Activate venv: source venv/bin/activate\n` +
              `4. Install dependencies: pip install playwright beautifulsoup4 requests\n` +
              `5. Set PYTHON_EXECUTABLE env var to override Python path\n\n` +
              `Current REPO_ROOT: ${PythonExecutor.getRepoRoot()}`;
          }

          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify({
              error: true,
              message: errorMessage
            })}\n\n`)
          );
          controller.close();
        });
      }
    });
  }

  /**
   * Internal method to execute the Python process
   */
  private static _executeProcess(options: PythonExecutorOptions): Promise<string> {
    const scriptPath = path.join(this.getRepoRoot(), 'scripts', options.scriptName);
    const args = options.args || [];

    return new Promise((resolve, reject) => {
      const pythonProcess = spawn(this.getPythonPath(), [scriptPath, ...args]);

      let stdout = '';
      let stderr = '';

      // If stdin data is provided, write it to the process
      if (options.stdin) {
        pythonProcess.stdin.write(options.stdin);
        pythonProcess.stdin.end();
      }

      pythonProcess.stdout.on('data', (data) => {
        const chunk = data.toString();
        stdout += chunk;
        options.onStdout?.(chunk);
      });

      pythonProcess.stderr.on('data', (data) => {
        const chunk = data.toString();
        stderr += chunk;
        options.onStderr?.(chunk);
      });

      pythonProcess.on('close', (code) => {
        if (code !== 0) {
          // Log full error server-side
          console.error(`[Python ${options.scriptName}] Process failed:`, {
            code,
            stderr: stderr.slice(0, 500)
          });

          reject(new Error(
            `Python script failed with code ${code}: ${this._sanitizeError(stderr)}`
          ));
        } else {
          resolve(stdout);
        }
      });

      pythonProcess.on('error', (error: NodeJS.ErrnoException) => {
        console.error(`[Python ${options.scriptName}] Spawn failed:`, error);

        let errorMessage = `Failed to start Python process: ${error.message}`;

        if (error.code === 'ENOENT') {
          const pythonPath = this.getPythonPath();
          errorMessage =
            `Python interpreter not found at: ${pythonPath}\n\n` +
            `Troubleshooting:\n` +
            `1. Verify Python is installed: python3 --version\n` +
            `2. Set up virtual environment: python3 -m venv venv\n` +
            `3. Activate venv: source venv/bin/activate\n` +
            `4. Install dependencies: pip install playwright beautifulsoup4 requests\n` +
            `5. Set PYTHON_EXECUTABLE env var to override Python path\n\n` +
            `Current REPO_ROOT: ${this.getRepoRoot()}`;
        }

        reject(new Error(errorMessage));
      });
    });
  }

  /**
   * Create a timeout promise that rejects after the specified duration
   */
  private static _createTimeoutPromise(timeout: number, scriptName: string): Promise<never> {
    return new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Python script '${scriptName}' timed out after ${timeout}ms`));
      }, timeout);
    });
  }

  /**
   * Sanitize error messages to avoid exposing sensitive information
   * Only shows detailed errors in development mode
   */
  private static _sanitizeError(stderr: string): string {
    if (process.env.NODE_ENV === 'development') {
      return stderr.slice(0, 500); // Limit length even in dev
    }

    // In production, only return generic error
    return 'Script execution failed. Check server logs for details.';
  }

  /**
   * Validate that required Python dependencies are installed
   *
   * @param dependencies - List of Python package names to check
   * @returns Promise<string[]> - List of missing packages
   */
  static async validateDependencies(dependencies: string[]): Promise<string[]> {
    const missing: string[] = [];

    for (const dep of dependencies) {
      try {
        await this.execute({
          scriptName: '../node_modules/.bin/python3', // Use absolute python3
          args: ['-c', `import ${dep}`],
          timeout: 5000
        });
      } catch (error) {
        missing.push(dep);
      }
    }

    return missing;
  }
}
