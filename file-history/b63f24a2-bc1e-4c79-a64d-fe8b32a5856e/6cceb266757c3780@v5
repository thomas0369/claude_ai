#!/usr/bin/env python3
"""
ZEREZ GraphQL Client
====================

Direct GraphQL API client for ZEREZ database.
Discovered through network traffic analysis - ZEREZ uses Azure-hosted GraphQL API.

This is MUCH faster and more reliable than HTML scraping because:
1. No browser automation needed
2. Direct data access (no DOM parsing)
3. Proper pagination support
4. Native filtering via GraphQL where clauses
5. ~100x faster than Playwright approach

API Endpoint: https://app-zerez-weeu-gatewaysvc-prod-01.azurewebsites.net/graphql/

Usage:
    from zerez_graphql_client import ZEREZGraphQLClient

    client = ZEREZGraphQLClient()
    units = client.search_units(
        power_min_kw=50,
        power_max_kw=200,
        primary_energy_source='Speicher',
        take=1000
    )
"""

import json
import logging
import requests
import uuid as uuid_lib
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, asdict, field
from concurrent.futures import ThreadPoolExecutor

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


# GraphQL introspection query to discover enum types
INTROSPECTION_QUERY = """
query IntrospectSchema {
  __schema {
    types {
      name
      kind
      enumValues {
        name
        description
      }
    }
  }
}
"""

# GraphQL query (captured from ZEREZ network traffic, simplified for public access)
GRAPHQL_QUERY = """
query getUnitsForUnitsOverview($skip: Int, $take: Int, $where: UnitOverviewFilterInput, $order: [UnitOverviewSortInput!]) {
  unitOverview(skip: $skip, take: $take, where: $where, order: $order) {
    totalCount
    items {
      id
      isImported
      tenantId
      certificateAuthorityId
      modelName
      manufacturerId
      ratedCurrent
      unitCode
      maxActivePower
      hasActivePowerRange
      hasApparentPowerRange
      certificateId
      maxActivePower
      maxActivePowerRange
      maxApparentPowerRange
      minActivePowerRange
      minApparentPowerRange
      ratedVoltage
      unitTypeId
      createdAt
      modifiedAt
      certificateNormIssueDateDescriptions
      is4105
      unitTypeId
      category
      certificateIsImported
      isVerified
      certificateIssueDate
      certificateHolderId
      primaryEnergySource
      certificateNumber
      validityStartDate
      validityEndDate
      inEditByTenantId
      withTG8Rev25Conformity
      certificateValidityStatusName
      certificateValidityStatusId
      certificateTypeId
      hasActiveErrorReport
      replacedByCertificate {
        id
        certificateNumber
        revision
        __typename
      }
      parentCertificateForValidityExtension {
        id
        certificateNumber
        revision
        __typename
      }
      __typename
    }
    __typename
  }
}
"""


@dataclass
class ZEREZUnit:
    """Represents a ZEREZ unit from GraphQL API."""

    # Core identifiers
    id: str
    unitCode: Optional[str] = None
    modelName: Optional[str] = None
    certificateNumber: Optional[str] = None

    # Power ratings
    maxActivePower: Optional[float] = None
    maxActivePowerRange: Optional[float] = None
    minActivePowerRange: Optional[float] = None
    maxApparentPowerRange: Optional[float] = None
    minApparentPowerRange: Optional[float] = None

    # Electrical
    ratedVoltage: Optional[float] = None
    ratedCurrent: Optional[float] = None

    # Classification
    primaryEnergySource: Optional[str] = None
    category: Optional[str] = None
    unitTypeId: Optional[str] = None

    # Certification
    certificateId: Optional[str] = None
    certificateIssueDate: Optional[str] = None
    certificateAuthorityId: Optional[str] = None
    certificateHolderId: Optional[str] = None
    manufacturerId: Optional[str] = None
    manufacturerName: Optional[str] = None  # Resolved via tenant() query
    certificateAuthorityName: Optional[str] = None  # Resolved via tenant() query
    certificateValidityStatusName: Optional[str] = None
    certificateNormIssueDateDescriptions: Optional[str] = None

    # Status
    isVerified: bool = False
    isImported: bool = False
    is4105: bool = False

    # Dates
    createdAt: Optional[str] = None
    modifiedAt: Optional[str] = None
    validityStartDate: Optional[str] = None
    validityEndDate: Optional[str] = None

    # Additional fields
    raw_data: Optional[Dict] = field(default=None, repr=False)


class ZEREZGraphQLClient:
    """Client for ZEREZ GraphQL API."""

    def __init__(self):
        """Initialize GraphQL client."""
        self.endpoint = "https://app-zerez-weeu-gatewaysvc-prod-01.azurewebsites.net/graphql/"
        self.session = requests.Session()
        self.session.headers.update({
            'Content-Type': 'application/json',
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })

        # Cache for enum values discovered via introspection
        self._enum_cache: Dict[str, List[str]] = {}

        # Session-level cache for manufacturer names (shared across multiple searches)
        self._manufacturer_name_cache: Dict[str, Optional[str]] = {}

        # Session-level cache for certificate authority names
        self._authority_name_cache: Dict[str, Optional[str]] = {}

        self._cache_stats = {
            'hits': 0,
            'misses': 0,
            'api_calls': 0
        }

        # Load enum values on initialization
        self._load_enum_values()

    @staticmethod
    def _is_valid_uuid(uuid_string: str) -> bool:
        """
        Validate that a string is a valid UUID format.

        Args:
            uuid_string: String to validate

        Returns:
            True if valid UUID, False otherwise

        Examples:
            >>> _is_valid_uuid("123e4567-e89b-12d3-a456-426614174000")
            True
            >>> _is_valid_uuid("not-a-uuid")
            False
            >>> _is_valid_uuid(None)
            False
        """
        if not uuid_string:
            return False

        try:
            uuid_lib.UUID(uuid_string)
            return True
        except (ValueError, AttributeError, TypeError):
            return False

    def _load_enum_values(self):
        """Load enum values via GraphQL introspection."""
        try:
            logger.info("üîç Discovering enum values via GraphQL introspection...")

            payload = {
                "operationName": "IntrospectSchema",
                "query": INTROSPECTION_QUERY
            }

            response = self.session.post(
                self.endpoint,
                json=payload,
                timeout=10
            )

            if response.status_code != 200:
                logger.warning(f"   ‚ö†Ô∏è  Introspection failed ({response.status_code}), enum filters will be disabled")
                return

            data = response.json()

            if 'errors' in data:
                logger.warning(f"   ‚ö†Ô∏è  Introspection query errors, enum filters will be disabled")
                return

            # Extract enum types
            schema = data.get('data', {}).get('__schema', {})
            types = schema.get('types', [])

            for type_def in types:
                if type_def.get('kind') == 'ENUM' and type_def.get('enumValues'):
                    enum_name = type_def['name']
                    enum_values = [ev['name'] for ev in type_def['enumValues']]
                    self._enum_cache[enum_name] = enum_values

            logger.info(f"   ‚úì Discovered {len(self._enum_cache)} enum types")

            # Log key enum types for debugging
            key_enums = ['PrimaryEnergySource', 'Category', 'NetFeedIn']
            for enum_name in key_enums:
                if enum_name in self._enum_cache:
                    values = self._enum_cache[enum_name]
                    logger.info(f"   ‚Ä¢ {enum_name}: {len(values)} values ({', '.join(values[:3])}...)")

        except Exception as e:
            logger.warning(f"   ‚ö†Ô∏è  Failed to load enum values: {e}")
            logger.warning(f"   Enum filters will be disabled")

    def _validate_enum_value(self, enum_type: str, value: str) -> bool:
        """Validate that a value is valid for a given enum type."""
        if enum_type not in self._enum_cache:
            logger.warning(f"   ‚ö†Ô∏è  Unknown enum type '{enum_type}', cannot validate")
            return False

        valid_values = self._enum_cache[enum_type]
        if value not in valid_values:
            logger.warning(f"   ‚ö†Ô∏è  Invalid value '{value}' for enum '{enum_type}'")
            logger.warning(f"      Valid values: {', '.join(valid_values)}")
            return False

        return True

    def _resolve_tenant_names(
        self,
        units: List[ZEREZUnit],
        id_field: str,
        name_field: str,
        cache: Dict[str, Optional[str]],
        entity_type: str,
        entity_icon: str
    ) -> Dict[str, int]:
        """
        Generic method to batch-resolve tenant UUIDs to names via tenant() GraphQL query.
        Updates units in-place with resolved names.
        Uses session-level cache to avoid redundant API calls.

        This is the DRY implementation used by both manufacturer and authority resolution.

        Args:
            units: List of ZEREZUnit objects to resolve names for
            id_field: Field name containing the UUID (e.g., 'manufacturerId', 'certificateAuthorityId')
            name_field: Field name to set with resolved name (e.g., 'manufacturerName', 'certificateAuthorityName')
            cache: Cache dictionary to use for this entity type
            entity_type: Human-readable entity type for logging (e.g., 'manufacturer', 'certificate authority')
            entity_icon: Icon emoji for logging (e.g., 'üè¢', 'üèõÔ∏è')

        Returns:
            Dict with resolution statistics: {
                'total': int,           # Total unique IDs
                'cached': int,          # Resolved from session cache
                'success': int,         # Successfully resolved via API
                'not_found': int,       # Valid response but tenant not found
                'network_errors': int,  # Network/timeout failures
                'api_calls': int        # Actual API calls made
            }

        Examples:
            >>> stats = client._resolve_tenant_names(
            ...     units=units,
            ...     id_field='manufacturerId',
            ...     name_field='manufacturerName',
            ...     cache=self._manufacturer_name_cache,
            ...     entity_type='manufacturer',
            ...     entity_icon='üè¢'
            ... )
        """
        if not units:
            return {'total': 0, 'cached': 0, 'success': 0, 'not_found': 0, 'network_errors': 0, 'api_calls': 0}

        # Collect unique IDs and check cache
        all_ids = set()
        uncached_ids = set()
        invalid_uuid_count = 0

        for unit in units:
            entity_id = getattr(unit, id_field, None)
            if entity_id:
                # Validate UUID format before processing
                if not self._is_valid_uuid(entity_id):
                    logger.warning(f"   ‚ö†Ô∏è  Invalid UUID format for {entity_type} ID: {entity_id}")
                    invalid_uuid_count += 1
                    continue

                all_ids.add(entity_id)

                if entity_id in cache:
                    # Use cached value immediately
                    setattr(unit, name_field, cache[entity_id])
                    self._cache_stats['hits'] += 1
                else:
                    uncached_ids.add(entity_id)
                    self._cache_stats['misses'] += 1

        if invalid_uuid_count > 0:
            logger.warning(f"   ‚ö†Ô∏è  Skipped {invalid_uuid_count} {entity_type} IDs with invalid UUID format")

        if not all_ids:
            logger.info(f"   ‚ÑπÔ∏è  No {entity_type} IDs to resolve")
            return {'total': 0, 'cached': 0, 'success': 0, 'not_found': 0, 'network_errors': 0, 'api_calls': 0}

        # Log cache efficiency
        cached_count = len(all_ids) - len(uncached_ids)
        if uncached_ids:
            logger.info(f"{entity_icon} Resolving {len(uncached_ids)} {entity_type} names ({cached_count} from cache)...")
        else:
            logger.info(f"   ‚úì All {cached_count} {entity_type} names served from session cache")
            return {'total': len(all_ids), 'cached': cached_count, 'success': 0, 'not_found': 0, 'network_errors': 0, 'api_calls': 0}

        # GraphQL query to get tenant name
        query = """
        query GetTenant($id: UUID!) {
          tenant(id: $id) {
            id
            tenantName
          }
        }
        """

        # Resolution statistics
        success_count = 0
        not_found_count = 0
        network_error_count = 0

        for entity_id in uncached_ids:
            payload = {
                "operationName": "GetTenant",
                "variables": {"id": entity_id},
                "query": query
            }

            try:
                response = self.session.post(
                    self.endpoint,
                    json=payload,
                    timeout=10
                )

                self._cache_stats['api_calls'] += 1

                if response.status_code == 200:
                    data = response.json()

                    if 'errors' not in data:
                        tenant = data.get('data', {}).get('tenant')
                        if tenant and tenant.get('tenantName'):
                            # Success - cache and apply
                            tenant_name = tenant['tenantName']
                            cache[entity_id] = tenant_name
                            success_count += 1
                        else:
                            # Valid response but tenant not found
                            cache[entity_id] = None
                            not_found_count += 1
                    else:
                        # GraphQL error (likely invalid UUID or permission denied)
                        logger.debug(f"   GraphQL error for {entity_id}: {data['errors']}")
                        cache[entity_id] = None
                        not_found_count += 1
                else:
                    # HTTP error - likely infrastructure issue
                    logger.warning(f"   HTTP {response.status_code} for {entity_type} {entity_id}")
                    cache[entity_id] = None
                    network_error_count += 1

            except requests.exceptions.Timeout:
                logger.warning(f"   ‚è±Ô∏è  Timeout resolving {entity_type} {entity_id}")
                cache[entity_id] = None
                network_error_count += 1

            except requests.exceptions.RequestException as e:
                logger.warning(f"   ‚ö†Ô∏è  Network error resolving {entity_id}: {e}")
                cache[entity_id] = None
                network_error_count += 1

            except Exception as e:
                logger.error(f"   ‚ùå Unexpected error resolving {entity_id}: {e}")
                cache[entity_id] = None
                not_found_count += 1

        # Update all units with resolved names (including cached ones)
        for unit in units:
            entity_id = getattr(unit, id_field, None)
            if entity_id and entity_id in cache:
                setattr(unit, name_field, cache[entity_id])

        # Calculate network failure rate
        total_requests = len(uncached_ids)
        network_failure_rate = network_error_count / total_requests if total_requests > 0 else 0

        # Log summary
        logger.info(
            f"   ‚úì Resolved {success_count + cached_count}/{len(all_ids)} {entity_type} names "
            f"({cached_count} cached, {success_count} new, {not_found_count} not found, {network_error_count} network errors)"
        )

        # Warn if high network failure rate
        if network_failure_rate > 0.3:
            logger.warning(
                f"   ‚ö†Ô∏è  High network failure rate: {network_error_count}/{total_requests} "
                f"({network_failure_rate:.1%}) - check network connectivity"
            )

        return {
            'total': len(all_ids),
            'cached': cached_count,
            'success': success_count,
            'not_found': not_found_count,
            'network_errors': network_error_count,
            'api_calls': len(uncached_ids)
        }

    def _resolve_manufacturer_names(self, units: List[ZEREZUnit]) -> Dict[str, int]:
        """
        Batch-resolve manufacturer UUIDs to names via tenant() GraphQL query.
        Updates units in-place with manufacturerName field.
        Uses session-level cache to avoid redundant API calls.

        This is a thin wrapper around _resolve_tenant_names() for manufacturer resolution.

        Args:
            units: List of ZEREZUnit objects to resolve manufacturer names for

        Returns:
            Dict with resolution statistics: {
                'total': int,           # Total unique manufacturer IDs
                'cached': int,          # Resolved from session cache
                'success': int,         # Successfully resolved via API
                'not_found': int,       # Valid response but tenant not found
                'network_errors': int,  # Network/timeout failures
                'api_calls': int        # Actual API calls made
            }
        """
        return self._resolve_tenant_names(
            units=units,
            id_field='manufacturerId',
            name_field='manufacturerName',
            cache=self._manufacturer_name_cache,
            entity_type='manufacturer',
            entity_icon='üè¢'
        )

    def _resolve_certificate_authority_names(self, units: List[ZEREZUnit]) -> Dict[str, int]:
        """
        Batch-resolve certificate authority UUIDs to names via tenant() GraphQL query.
        Updates units in-place with certificateAuthorityName field.
        Uses session-level cache to avoid redundant API calls.

        This is a thin wrapper around _resolve_tenant_names() for certificate authority resolution.

        Args:
            units: List of ZEREZUnit objects to resolve authority names for

        Returns:
            Dict with resolution statistics: {
                'total': int,           # Total unique authority IDs
                'cached': int,          # Resolved from session cache
                'success': int,         # Successfully resolved via API
                'not_found': int,       # Valid response but tenant not found
                'network_errors': int,  # Network/timeout failures
                'api_calls': int        # Actual API calls made
            }
        """
        return self._resolve_tenant_names(
            units=units,
            id_field='certificateAuthorityId',
            name_field='certificateAuthorityName',
            cache=self._authority_name_cache,
            entity_type='certificate authority',
            entity_icon='üèõÔ∏è'
        )

    def _build_where_clause(
        self,
        power_min_kw: Optional[float] = None,
        power_max_kw: Optional[float] = None,
        primary_energy_source: Optional[str] = None,
        category: Optional[str] = None,
        is_verified: Optional[bool] = None,
        is_4105: Optional[bool] = None,
        voltage_min: Optional[float] = None,
        voltage_max: Optional[float] = None,
        certificate_norms: Optional[List[str]] = None,
        manufacturer_id: Optional[str] = None,
        authority_id: Optional[str] = None,
        created_after: Optional[str] = None,
        created_before: Optional[str] = None,
        modified_after: Optional[str] = None,
        modified_before: Optional[str] = None
    ) -> Dict:
        """Build GraphQL where clause from filters."""

        # Start with base filter (match ZEREZ's default structure)
        base_filter = {
            "or": [
                {
                    "ratedVoltage": {
                        "gte": 0
                    }
                },
                {
                    "ratedVoltage": {
                        "eq": None
                    }
                }
            ],
            "replacedByUnitId": {
                "eq": None
            }
        }

        where = {
            "and": [base_filter]
        }

        # Power range filter
        if power_min_kw is not None or power_max_kw is not None:
            power_filter = {}
            if power_min_kw is not None:
                power_filter["gte"] = power_min_kw
            if power_max_kw is not None:
                power_filter["lte"] = power_max_kw

            where["and"].append({
                "maxActivePower": power_filter
            })

        # Primary energy source filter (enum type)
        if primary_energy_source:
            if self._validate_enum_value('PrimaryEnergySource', primary_energy_source):
                where["and"].append({
                    "primaryEnergySource": {
                        "eq": primary_energy_source
                    }
                })
            else:
                logger.warning(f"   ‚ö†Ô∏è  Skipping invalid primary_energy_source: '{primary_energy_source}'")

        # Category filter (enum type)
        if category:
            if self._validate_enum_value('Category', category):
                where["and"].append({
                    "category": {
                        "eq": category
                    }
                })
            else:
                logger.warning(f"   ‚ö†Ô∏è  Skipping invalid category: '{category}'")

        # Verification status
        if is_verified is not None:
            where["and"].append({
                "isVerified": {
                    "eq": is_verified
                }
            })

        # 4105 status
        if is_4105 is not None:
            where["and"].append({
                "is4105": {
                    "eq": is_4105
                }
            })

        # Voltage range filter
        if voltage_min is not None or voltage_max is not None:
            voltage_filter = {}
            if voltage_min is not None:
                voltage_filter["gte"] = voltage_min
            if voltage_max is not None:
                voltage_filter["lte"] = voltage_max

            where["and"].append({
                "ratedVoltage": voltage_filter
            })

        # Certificate norms filter (multi-select with contains)
        if certificate_norms and len(certificate_norms) > 0:
            # Use OR logic for multi-select: match any of the selected norms
            norms_or_clause = []
            for norm in certificate_norms:
                norms_or_clause.append({
                    "certificateNormIssueDateDescriptions": {
                        "contains": norm
                    }
                })
            where["and"].append({"or": norms_or_clause})

        # Manufacturer filter
        if manufacturer_id:
            where["and"].append({
                "manufacturerId": {
                    "eq": manufacturer_id
                }
            })

        # Authority filter
        if authority_id:
            where["and"].append({
                "certificateAuthorityId": {
                    "eq": authority_id
                }
            })

        # Date filters - Created date range
        if created_after is not None or created_before is not None:
            created_filter = {}
            if created_after is not None:
                created_filter["gte"] = created_after
            if created_before is not None:
                created_filter["lte"] = created_before

            where["and"].append({
                "createdAt": created_filter
            })

        # Date filters - Modified date range
        if modified_after is not None or modified_before is not None:
            modified_filter = {}
            if modified_after is not None:
                modified_filter["gte"] = modified_after
            if modified_before is not None:
                modified_filter["lte"] = modified_before

            where["and"].append({
                "modifiedAt": modified_filter
            })

        return where

    def search_units(
        self,
        power_min_kw: Optional[float] = None,
        power_max_kw: Optional[float] = None,
        primary_energy_source: Optional[str] = None,
        category: Optional[str] = None,
        is_verified: Optional[bool] = None,
        is_4105: Optional[bool] = None,
        voltage_min: Optional[float] = None,
        voltage_max: Optional[float] = None,
        certificate_norms: Optional[List[str]] = None,
        manufacturer_id: Optional[str] = None,
        authority_id: Optional[str] = None,
        created_after: Optional[str] = None,
        created_before: Optional[str] = None,
        modified_after: Optional[str] = None,
        modified_before: Optional[str] = None,
        take: int = 100,
        max_results: Optional[int] = None
    ) -> tuple[List[ZEREZUnit], int]:
        """
        Search ZEREZ units using GraphQL API.

        Args:
            power_min_kw: Minimum power in kW
            power_max_kw: Maximum power in kW
            primary_energy_source: e.g., "STORAGE", "PV", "WIND"
            category: e.g., "STORAGE_INVERTER", "INVERTER"
            is_verified: Filter for verified units
            is_4105: Filter for 4105 compliant units
            voltage_min: Minimum rated voltage
            voltage_max: Maximum rated voltage
            certificate_norms: List of certificate norms (e.g., ["VDE-AR-N 4105:2018-11"])
            manufacturer_id: Manufacturer UUID
            authority_id: Certificate authority UUID
            created_after: ISO 8601 date string (e.g., "2024-01-01T00:00:00.000Z")
            created_before: ISO 8601 date string
            modified_after: ISO 8601 date string
            modified_before: ISO 8601 date string
            take: Number of results per page (recommended: 100, max: ~1000)
            max_results: Maximum total results to return

        Returns:
            Tuple of (list of ZEREZ units, total count from GraphQL)
            - units: List of matching units (may be limited by max_results)
            - totalCount: Total available matches in ZEREZ database (not limited)
        """

        logger.info("üîç Searching ZEREZ units via GraphQL API...")
        logger.info(f"   Filters: power={power_min_kw}-{power_max_kw}kW, source={primary_energy_source}, category={category}")

        # Build GraphQL where clause
        where = self._build_where_clause(
            power_min_kw=power_min_kw,
            power_max_kw=power_max_kw,
            primary_energy_source=primary_energy_source,
            category=category,
            is_verified=is_verified,
            is_4105=is_4105,
            voltage_min=voltage_min,
            voltage_max=voltage_max,
            certificate_norms=certificate_norms,
            manufacturer_id=manufacturer_id,
            authority_id=authority_id,
            created_after=created_after,
            created_before=created_before,
            modified_after=modified_after,
            modified_before=modified_before
        )

        all_units = []
        graphql_total_count = 0  # Track totalCount from GraphQL (captured on first page)
        skip = 0
        page = 1

        while True:
            # Prepare GraphQL request
            payload = {
                "operationName": "getUnitsForUnitsOverview",
                "variables": {
                    "take": take,
                    "where": where,
                    "skip": skip,
                    "order": {}
                },
                "query": GRAPHQL_QUERY
            }

            logger.info(f"üì° Fetching page {page} (skip={skip}, take={take})...")

            try:
                response = self.session.post(
                    self.endpoint,
                    json=payload,
                    timeout=30
                )

                if response.status_code != 200:
                    logger.error(f"   ‚úó API returned {response.status_code}: {response.text[:500]}")
                    response.raise_for_status()

                data = response.json()

                # Check for GraphQL errors (even with 200 status)
                if 'errors' in data:
                    error_messages = [err.get('message', str(err)) for err in data['errors']]
                    logger.error(f"   ‚úó GraphQL errors: {'; '.join(error_messages)}")

                    # Check if it's a known enum filter issue
                    if any('cannot parse' in msg.lower() or 'enum' in msg.lower()
                           for msg in error_messages):
                        logger.error("   üí° Hint: This looks like an enum filter issue")
                        logger.error("      Try removing 'primary_energy_source' and 'category' filters")

                    raise ValueError(f"GraphQL query failed: {'; '.join(error_messages)}")

                # Validate response structure
                if 'data' not in data or data.get('data') is None:
                    logger.error(f"   ‚úó Invalid response structure: missing 'data' field")
                    raise ValueError("Response missing 'data' field")

                # Extract units from response
                unit_overview = data.get('data', {}).get('unitOverview', {})
                items = unit_overview.get('items', [])
                total_count = unit_overview.get('totalCount', 0)

                # Capture totalCount from first page (this is the REAL total from GraphQL)
                if page == 1:
                    graphql_total_count = total_count

                logger.info(f"   ‚úì Received {len(items)} units (total available: {total_count})")

                if not items:
                    break

                # Convert to ZEREZUnit objects
                for item in items:
                    unit = ZEREZUnit(
                        id=item.get('id'),
                        unitCode=item.get('unitCode'),
                        modelName=item.get('modelName'),
                        certificateNumber=item.get('certificateNumber'),
                        maxActivePower=item.get('maxActivePower'),
                        maxActivePowerRange=item.get('maxActivePowerRange'),
                        minActivePowerRange=item.get('minActivePowerRange'),
                        maxApparentPowerRange=item.get('maxApparentPowerRange'),
                        minApparentPowerRange=item.get('minApparentPowerRange'),
                        ratedVoltage=item.get('ratedVoltage'),
                        ratedCurrent=item.get('ratedCurrent'),
                        primaryEnergySource=item.get('primaryEnergySource'),
                        category=item.get('category'),
                        unitTypeId=item.get('unitTypeId'),
                        certificateId=item.get('certificateId'),
                        certificateIssueDate=item.get('certificateIssueDate'),
                        certificateAuthorityId=item.get('certificateAuthorityId'),
                        certificateHolderId=item.get('certificateHolderId'),
                        manufacturerId=item.get('manufacturerId'),
                        certificateValidityStatusName=item.get('certificateValidityStatusName'),
                        certificateNormIssueDateDescriptions=item.get('certificateNormIssueDateDescriptions'),
                        isVerified=item.get('isVerified', False),
                        isImported=item.get('isImported', False),
                        is4105=item.get('is4105', False),
                        createdAt=item.get('createdAt'),
                        modifiedAt=item.get('modifiedAt'),
                        validityStartDate=item.get('validityStartDate'),
                        validityEndDate=item.get('validityEndDate'),
                        raw_data=item
                    )
                    all_units.append(unit)

                # Check if we've reached max_results
                if max_results and len(all_units) >= max_results:
                    all_units = all_units[:max_results]
                    logger.info(f"   ‚ÑπÔ∏è  Reached max_results limit ({max_results})")
                    break

                # Check if we've retrieved all available results
                if skip + len(items) >= total_count:
                    logger.info(f"   ‚úÖ Retrieved all {total_count} available units")
                    break

                # Prepare for next page
                skip += len(items)
                page += 1

            except requests.exceptions.RequestException as e:
                logger.error(f"   ‚úó API request failed: {e}")
                break
            except (KeyError, ValueError) as e:
                logger.error(f"   ‚úó Failed to parse response: {e}")
                break

        # Resolve manufacturer and authority names in parallel via tenant() GraphQL query
        manufacturer_stats = None
        authority_stats = None
        if all_units:
            # Run both resolution methods concurrently for better performance
            with ThreadPoolExecutor(max_workers=2) as executor:
                manufacturer_future = executor.submit(self._resolve_manufacturer_names, all_units)
                authority_future = executor.submit(self._resolve_certificate_authority_names, all_units)

                # Wait for both to complete
                manufacturer_stats = manufacturer_future.result()
                authority_stats = authority_future.result()

        # Calculate data quality metrics
        units_with_manufacturer_names = sum(1 for u in all_units if u.manufacturerName)
        units_with_manufacturer_ids = sum(1 for u in all_units if u.manufacturerId)
        units_with_authority_names = sum(1 for u in all_units if u.certificateAuthorityName)
        units_with_authority_ids = sum(1 for u in all_units if u.certificateAuthorityId)

        # Log comprehensive summary
        logger.info(
            f"‚úÖ Search complete: found {len(all_units)} units "
            f"({units_with_manufacturer_names}/{units_with_manufacturer_ids} with manufacturer names, "
            f"{units_with_authority_names}/{units_with_authority_ids} with authority names)"
        )

        # Warn if significant data incompleteness due to network issues
        if manufacturer_stats and manufacturer_stats['network_errors'] > 0:
            missing_due_to_network = manufacturer_stats['network_errors']
            logger.warning(
                f"   ‚ö†Ô∏è  {missing_due_to_network} manufacturer names unavailable due to network issues"
            )

        if authority_stats and authority_stats['network_errors'] > 0:
            missing_due_to_network = authority_stats['network_errors']
            logger.warning(
                f"   ‚ö†Ô∏è  {missing_due_to_network} certificate authority names unavailable due to network issues"
            )

        return all_units, graphql_total_count

    def get_all_units(self, take: int = 100) -> tuple[List[ZEREZUnit], int]:
        """
        Get ALL units from ZEREZ (no filters).

        Args:
            take: Number of results per page (recommended: 100)

        Returns:
            Tuple of (list of all ZEREZ units, total count from GraphQL)
        """
        return self.search_units(take=take)

    def get_enum_values(self, enum_name: str) -> List[str]:
        """
        Get available values for an enum type.

        Args:
            enum_name: Name of enum (e.g., 'PrimaryEnergySource', 'Category')

        Returns:
            List of valid enum values
        """
        return self._enum_cache.get(enum_name, [])

    def get_all_enum_types(self) -> Dict[str, List[str]]:
        """
        Get all available enum types and their values.

        Returns:
            Dictionary mapping enum names to their values
        """
        return self._enum_cache.copy()

    def export_to_json(self, units: List[ZEREZUnit], output_path: str):
        """Export units to JSON file."""
        data = [asdict(unit) for unit in units]

        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)

        logger.info(f"üíæ Exported {len(units)} units to {output_path}")


def main():
    """CLI entry point."""
    import argparse
    import sys

    parser = argparse.ArgumentParser(
        description='Search ZEREZ units via GraphQL API',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Search for 50-200kW verified units
  python3 zerez_graphql_client.py --power-min 50 --power-max 200 --verified true

  # Get all units in JSON format
  python3 zerez_graphql_client.py --format json

  # Search with 4105 compliance
  python3 zerez_graphql_client.py --power-min 100 --4105 true --format json
        """
    )

    parser.add_argument('--power-min', type=float, help='Minimum power in kW')
    parser.add_argument('--power-max', type=float, help='Maximum power in kW')
    parser.add_argument('--verified', type=str, choices=['true', 'false'], help='Filter for verified units only')
    parser.add_argument('--4105', dest='is_4105', type=str, choices=['true', 'false'], help='Filter for 4105 compliant units')
    parser.add_argument('--format', default='table', choices=['json', 'table'], help='Output format (default: table)')
    parser.add_argument('--max-results', type=int, help='Maximum number of results to return')
    parser.add_argument('--output', type=str, help='Output file path (for JSON format)')

    args = parser.parse_args()

    # Convert string booleans to actual booleans
    is_verified = None
    if args.verified:
        is_verified = args.verified == 'true'

    is_4105 = None
    if args.is_4105:
        is_4105 = args.is_4105 == 'true'

    # Create client and search
    try:
        client = ZEREZGraphQLClient()
        units, total_count = client.search_units(
            power_min_kw=args.power_min,
            power_max_kw=args.power_max,
            is_verified=is_verified,
            is_4105=is_4105,
            max_results=args.max_results
        )

        # Output results
        if args.format == 'json':
            # Convert to JSON (for Node.js API integration)
            results = [asdict(unit) for unit in units]

            if args.output:
                # Save to file
                with open(args.output, 'w', encoding='utf-8') as f:
                    json.dump(results, f, indent=2, ensure_ascii=False)
                logger.info(f"üíæ Saved to {args.output}")
            else:
                # Print to stdout (for Node.js to capture)
                print(json.dumps(results))

        else:
            # Table format (for human viewing)
            print(f"\nüìä Found {len(units)} units:")
            print(f"{'Model':<40} {'Power (kW)':>12} {'Verified':>10} {'4105':>6} {'Certificate':<20}")
            print("-" * 100)

            for unit in units[:20]:  # Limit to first 20 for readability
                verified = "‚úì" if unit.isVerified else "‚úó"
                is_4105_str = "‚úì" if unit.is4105 else "‚úó"
                power = f"{unit.maxActivePower:.1f}" if unit.maxActivePower else "N/A"
                cert = unit.certificateNumber[:18] if unit.certificateNumber else "N/A"

                print(f"{unit.modelName:<40} {power:>12} {verified:>10} {is_4105_str:>6} {cert:<20}")

            if len(units) > 20:
                print(f"\n... and {len(units) - 20} more units")

    except Exception as e:
        logger.error(f"‚ùå Error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    main()
