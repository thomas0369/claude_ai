import { NextRequest, NextResponse } from 'next/server';
import { PythonExecutor } from '@/lib/python-executor';
import { isValidUUID } from '@/lib/api-validation-utils';
import { getZEREZPath } from '@/lib/zerez-constants';

// Disable response caching for SSE
export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { units } = body;

    // Validate: units must exist and be non-empty array
    if (!units || !Array.isArray(units) || units.length === 0) {
      return NextResponse.json(
        { error: 'No units provided', message: 'units must be a non-empty array' },
        { status: 400 }
      );
    }

    // Validate: array length limit (max 100 units per import)
    if (units.length > 100) {
      return NextResponse.json(
        {
          error: 'Too many units',
          message: `Maximum 100 units allowed per import, received ${units.length}`
        },
        { status: 400 }
      );
    }

    // Validate: each unit must be an object with id field
    const invalidUnits: number[] = [];
    for (let i = 0; i < units.length; i++) {
      const unit = units[i];
      if (!unit || typeof unit !== 'object' || !unit.id) {
        invalidUnits.push(i);
      } else if (!isValidUUID(unit.id)) {
        invalidUnits.push(i);
      }
    }

    if (invalidUnits.length > 0) {
      return NextResponse.json(
        {
          error: 'Invalid units',
          message: `${invalidUnits.length} invalid unit(s) found`,
          invalidIndexes: invalidUnits.slice(0, 5) // Show first 5 invalid indexes
        },
        { status: 400 }
      );
    }

    // Validate: check for duplicate IDs
    const unitIds = units.map(u => u.id);
    const uniqueIds = new Set(unitIds);
    if (uniqueIds.size !== unitIds.length) {
      return NextResponse.json(
        {
          error: 'Duplicate unit IDs',
          message: `Found ${unitIds.length - uniqueIds.size} duplicate ID(s)`
        },
        { status: 400 }
      );
    }

    // Calculate dynamic timeout based on batch size
    // JSON saver is fast (~0.1s per unit), but add buffer for safety
    const SECONDS_PER_UNIT = 0.5; // Conservative estimate (actual: ~0.02s)
    const BASE_TIMEOUT_MS = 30000; // 30s startup buffer
    const TIMEOUT_PER_UNIT_MS = SECONDS_PER_UNIT * 1000;
    const MAX_TIMEOUT_MS = 600000; // 10 minute hard limit

    const calculatedTimeout = BASE_TIMEOUT_MS + (units.length * TIMEOUT_PER_UNIT_MS);
    const timeout = Math.min(calculatedTimeout, MAX_TIMEOUT_MS);

    // Create SSE stream using Python Executor with new JSON saver
    const stream = PythonExecutor.createStreamingResponse({
      scriptName: 'zerez_json_saver.py',
      args: [
        '--units', JSON.stringify(units),
        '--output-dir', getZEREZPath('IMPORTS'),
        '--stream-progress'
      ],
      timeout
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache, no-transform',
        'Connection': 'keep-alive',
        'X-Accel-Buffering': 'no', // Disable Nginx buffering
      },
    });
  } catch (error) {
    return NextResponse.json(
      {
        error: 'Internal server error',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
