#!/usr/bin/env node
/**
 * ZEREZ Import API Test Script
 *
 * Tests the complete ZEREZ import flow:
 * 1. Search for products
 * 2. Import selected products
 * 3. Verify saved files
 *
 * Usage:
 *   node test-zerez-import.js
 */

const fs = require('fs');
const path = require('path');

const API_BASE = 'http://localhost:3000';
const OUTPUT_DIR = path.join(__dirname, 'data', 'zerez', 'imports');

// ANSI colors for terminal output
const colors = {
  reset: '\x1b[0m',
  green: '\x1b[32m',
  red: '\x1b[31m',
  yellow: '\x1b[33m',
  blue: '\x1b[34m',
  cyan: '\x1b[36m',
};

function log(msg, color = 'reset') {
  console.log(`${colors[color]}${msg}${colors.reset}`);
}

async function searchProducts() {
  log('\nüì° Step 1: Searching for ZEREZ products...', 'cyan');

  const response = await fetch(`${API_BASE}/api/zerez/search`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      powerMin: 50,
      powerMax: 200,
      isVerified: true,
      is4105: false,
      maxResults: 3  // Small batch for testing
    })
  });

  if (!response.ok) {
    throw new Error(`Search failed: ${response.status} ${response.statusText}`);
  }

  const data = await response.json();
  log(`‚úì Found ${data.units.length} products (total: ${data.totalCount})`, 'green');

  return data.units;
}

async function importProducts(units) {
  log('\nüíæ Step 2: Importing products via API...', 'cyan');
  log(`   Importing ${units.length} products...`);

  const startTime = Date.now();

  const response = await fetch(`${API_BASE}/api/zerez/import-details`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ units })
  });

  if (!response.ok) {
    const error = await response.json().catch(() => ({ error: 'Unknown error' }));
    throw new Error(`Import failed: ${response.status} - ${error.error || error.message}`);
  }

  // Read SSE stream
  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let lastProgress = null;

  while (true) {
    const { done, value } = await reader.read();
    if (done) break;

    const chunk = decoder.decode(value);
    const lines = chunk.split('\n');

    for (const line of lines) {
      if (line.startsWith('data: ')) {
        try {
          const data = JSON.parse(line.slice(6));
          if (data.error) {
            throw new Error(`Import error: ${data.message}`);
          }
          lastProgress = data;

          // Show progress
          if (data.current && data.current !== 'Complete') {
            process.stdout.write(`\r   Processing: ${data.current} (${data.downloaded || data.saved}/${data.total})`);
          }
        } catch (e) {
          if (!e.message.includes('Import error')) {
            // Skip invalid JSON (likely incomplete chunks)
          }
        }
      }
    }
  }

  const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);

  console.log(''); // New line after progress
  log(`‚úì Import completed in ${elapsed}s`, 'green');
  log(`   Total: ${lastProgress?.total || 0}`, 'green');
  log(`   Saved: ${lastProgress?.saved || lastProgress?.saved_files || lastProgress?.downloaded || 0}`, 'green');
  log(`   Failed: ${lastProgress?.failed || 0}`, lastProgress?.failed > 0 ? 'red' : 'green');

  if (lastProgress?.errors && lastProgress.errors.length > 0) {
    log(`   Errors: ${lastProgress.errors.slice(0, 3).join(', ')}`, 'red');
  }

  return {
    stats: lastProgress,
    elapsed: parseFloat(elapsed),
    perProduct: (parseFloat(elapsed) / units.length).toFixed(2)
  };
}

function verifyFiles(units) {
  log('\nüîç Step 3: Verifying saved files...', 'cyan');

  let verified = 0;
  let missing = 0;
  let invalid = 0;
  const errors = [];

  // Define comprehensive field validation
  const REQUIRED_FIELDS = ['id', 'modelName', 'importedAt', 'importMethod', 'apiVersion'];
  const CRITICAL_DATA_FIELDS = ['maxActivePower', 'ratedVoltage', 'certificateNumber', 'manufacturerId'];
  const EXPECTED_MIN_FIELDS = 30; // Should have ~33+ fields from GraphQL

  for (const unit of units) {
    const filePath = path.join(OUTPUT_DIR, `${unit.id}.json`);

    try {
      // Check file exists
      if (!fs.existsSync(filePath)) {
        log(`   ‚úó Missing: ${unit.modelName} (${unit.id})`, 'red');
        missing++;
        errors.push(`File not created for ${unit.id}`);
        continue;
      }

      // Read and parse
      const content = fs.readFileSync(filePath, 'utf-8');
      const data = JSON.parse(content);

      // Verify structure - required fields
      const missingRequired = REQUIRED_FIELDS.filter(field => data[field] === undefined);
      if (missingRequired.length > 0) {
        log(`   ‚úó Missing required fields for ${unit.modelName}: ${missingRequired.join(', ')}`, 'red');
        invalid++;
        errors.push(`${unit.id}: missing ${missingRequired.join(', ')}`);
        continue;
      }

      // Verify data completeness - critical fields (warn, don't fail)
      const missingCritical = CRITICAL_DATA_FIELDS.filter(field => data[field] === undefined && data[field] !== null);
      if (missingCritical.length > 0) {
        log(`   ‚ö† Missing some critical data for ${unit.modelName}: ${missingCritical.join(', ')}`, 'yellow');
      }

      // Verify field count (should have ~33+ fields from GraphQL)
      const fieldCount = Object.keys(data).length;
      if (fieldCount < EXPECTED_MIN_FIELDS) {
        log(`   ‚ö† Incomplete data for ${unit.modelName}: ${fieldCount}/${EXPECTED_MIN_FIELDS} fields`, 'yellow');
      }

      // Verify data integrity - ID matches
      if (data.id !== unit.id) {
        log(`   ‚úó ID mismatch for ${unit.modelName}: expected ${unit.id}, got ${data.id}`, 'red');
        invalid++;
        errors.push(`${unit.id}: ID mismatch`);
        continue;
      }

      // Verify import metadata
      if (data.importMethod !== 'graphql_api_search') {
        log(`   ‚ö† Unexpected import method: ${data.importMethod}`, 'yellow');
      }

      const sizeKB = (fs.statSync(filePath).size / 1024).toFixed(1);
      log(`   ‚úì ${unit.modelName} (${sizeKB} KB, ${fieldCount} fields)`, 'green');
      verified++;

    } catch (error) {
      log(`   ‚úó Error reading ${unit.modelName}: ${error.message}`, 'red');
      invalid++;
      errors.push(`${unit.id}: ${error.message}`);
    }
  }

  return { verified, missing, invalid, errors };
}

function displaySummary(importResult, verifyResult) {
  log('\n' + '='.repeat(60), 'blue');
  log('üìä TEST SUMMARY', 'blue');
  log('='.repeat(60), 'blue');

  log('\nImport Performance:', 'cyan');
  log(`  Total time: ${importResult.elapsed}s`);
  log(`  Per product: ${importResult.perProduct}s`);
  log(`  Speed: ${importResult.perProduct < 0.1 ? '‚ö° Excellent (<0.1s)' : importResult.perProduct < 1 ? '‚úì Good (<1s)' : '‚ö† Slow (>1s)'}`);

  log('\nFile Verification:', 'cyan');
  log(`  Verified: ${verifyResult.verified}`, 'green');
  log(`  Missing: ${verifyResult.missing}`, verifyResult.missing > 0 ? 'red' : 'green');
  log(`  Invalid: ${verifyResult.invalid}`, verifyResult.invalid > 0 ? 'red' : 'green');

  const allPassed = verifyResult.verified === importResult.stats.total
                 && verifyResult.missing === 0
                 && verifyResult.invalid === 0;

  if (allPassed) {
    log('\n‚úÖ ALL TESTS PASSED!', 'green');
  } else {
    log('\n‚ö†Ô∏è  SOME TESTS FAILED', 'yellow');
  }

  log('='.repeat(60) + '\n', 'blue');
}

async function main() {
  try {
    log('üß™ ZEREZ Import API Test', 'blue');
    log('Testing: Enhanced JSON import (no HTML download)\n', 'blue');

    // Step 1: Search for products
    const units = await searchProducts();

    if (units.length === 0) {
      log('‚ö†Ô∏è  No products found. Adjust search criteria.', 'yellow');
      return;
    }

    // Step 2: Import products
    const importResult = await importProducts(units);

    // Step 3: Verify saved files
    const verifyResult = verifyFiles(units);

    // Display summary
    displaySummary(importResult, verifyResult);

  } catch (error) {
    log(`\n‚ùå Test failed: ${error.message}`, 'red');
    if (error.stack) {
      log(error.stack, 'red');
    }
    process.exit(1);
  }
}

main();
