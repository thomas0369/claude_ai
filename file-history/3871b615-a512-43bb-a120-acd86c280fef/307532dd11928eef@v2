/**
 * Progress Storage System
 *
 * Manages game progress persistence using localStorage.
 * Tracks level completion, scores, stars, unlocks, and statistics.
 */

export interface LevelProgress {
  levelId: string;
  mode: 'campaign' | 'time-attack' | 'puzzle' | 'zen' | 'daily';
  completed: boolean;
  highScore: number;
  stars: number; // 0-3
  moves?: number; // For puzzle mode
  time?: number; // For time attack mode
  lastPlayed: string; // ISO date
  attempts: number;
}

export interface GameProgress {
  // Campaign progress
  campaignProgress: {
    currentLevel: number;
    unlockedLevels: number[];
    completedLevels: number[];
    totalStars: number;
  };

  // Mode unlocks (based on tier)
  unlockedModes: string[];

  // Daily challenge tracking
  dailyChallenge: {
    lastCompleted: string | null; // ISO date
    streak: number;
    bestStreak: number;
  };

  // Statistics
  stats: {
    totalGamesPlayed: number;
    totalScore: number;
    totalLines: number;
    totalCombos: number;
    bestCombo: number;
    totalPlayTime: number; // in seconds
  };

  // Trial plays tracking (1 free play per day for trial users)
  trialPlays: {
    [modeKey: string]: {
      lastPlayed: string | null;
      playsToday: number;
    };
  };

  // Achievements (future expansion)
  achievements: string[];
}

const STORAGE_KEY = 'block-puzzle-progress';
const LEVEL_PROGRESS_KEY = 'block-puzzle-levels';

/**
 * Get the full game progress object
 */
export function getGameProgress(): GameProgress {
  try {
    const stored = localStorage.getItem(STORAGE_KEY);
    if (stored) {
      return JSON.parse(stored);
    }
  } catch (error) {
    console.error('Failed to load game progress:', error);
  }

  // Return default progress
  return getDefaultProgress();
}

/**
 * Save the full game progress object
 */
export function saveGameProgress(progress: GameProgress): void {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(progress));
  } catch (error) {
    console.error('Failed to save game progress:', error);
  }
}

/**
 * Get progress for a specific level
 */
export function getLevelProgress(levelId: string, mode: string): LevelProgress | null {
  try {
    const stored = localStorage.getItem(LEVEL_PROGRESS_KEY);
    if (stored) {
      const allProgress: { [key: string]: LevelProgress } = JSON.parse(stored);
      const key = `${mode}-${levelId}`;
      return allProgress[key] || null;
    }
  } catch (error) {
    console.error('Failed to load level progress:', error);
  }
  return null;
}

/**
 * Save progress for a specific level
 */
export function saveLevelProgress(progress: LevelProgress): void {
  try {
    const stored = localStorage.getItem(LEVEL_PROGRESS_KEY);
    const allProgress: { [key: string]: LevelProgress } = stored ? JSON.parse(stored) : {};

    const key = `${progress.mode}-${progress.levelId}`;
    const existing = allProgress[key];

    // Merge with existing, keeping best scores
    allProgress[key] = {
      ...progress,
      highScore: Math.max(progress.highScore, existing?.highScore || 0),
      stars: Math.max(progress.stars, existing?.stars || 0),
      attempts: (existing?.attempts || 0) + 1,
    };

    localStorage.setItem(LEVEL_PROGRESS_KEY, JSON.stringify(allProgress));
  } catch (error) {
    console.error('Failed to save level progress:', error);
  }
}

/**
 * Complete a campaign level and unlock the next one
 */
export function completeCampaignLevel(level: number, score: number, stars: number): void {
  const progress = getGameProgress();

  // Add to completed levels
  if (!progress.campaignProgress.completedLevels.includes(level)) {
    progress.campaignProgress.completedLevels.push(level);
  }

  // Unlock next level
  const nextLevel = level + 1;
  if (!progress.campaignProgress.unlockedLevels.includes(nextLevel) && nextLevel <= 50) {
    progress.campaignProgress.unlockedLevels.push(nextLevel);
  }

  // Update current level
  progress.campaignProgress.currentLevel = Math.max(
    progress.campaignProgress.currentLevel,
    nextLevel
  );

  // Update total stars
  const existingProgress = getLevelProgress(level.toString(), 'campaign');
  const previousStars = existingProgress?.stars || 0;
  if (stars > previousStars) {
    progress.campaignProgress.totalStars += (stars - previousStars);
  }

  saveGameProgress(progress);

  // Save level-specific progress
  saveLevelProgress({
    levelId: level.toString(),
    mode: 'campaign',
    completed: true,
    highScore: score,
    stars,
    lastPlayed: new Date().toISOString(),
    attempts: 0, // Will be incremented by saveLevelProgress
  });
}

/**
 * Check if a level is unlocked
 */
export function isLevelUnlocked(level: number): boolean {
  const progress = getGameProgress();
  return progress.campaignProgress.unlockedLevels.includes(level);
}

/**
 * Check if a mode is unlocked
 */
export function isModeUnlocked(mode: string): boolean {
  const progress = getGameProgress();
  return progress.unlockedModes.includes(mode);
}

/**
 * Unlock a game mode
 */
export function unlockMode(mode: string): void {
  const progress = getGameProgress();
  if (!progress.unlockedModes.includes(mode)) {
    progress.unlockedModes.push(mode);
    saveGameProgress(progress);
  }
}

/**
 * Check if trial play is available for a mode today
 */
export function isTrialPlayAvailable(mode: string): boolean {
  const progress = getGameProgress();
  const trialPlay = progress.trialPlays[mode];

  if (!trialPlay) {
    return true; // First play
  }

  const today = new Date().toDateString();
  const lastPlayed = trialPlay.lastPlayed ? new Date(trialPlay.lastPlayed).toDateString() : null;

  if (lastPlayed !== today) {
    return true; // New day, reset available
  }

  return trialPlay.playsToday < 1; // 1 free play per day
}

/**
 * Use a trial play for a mode
 */
export function useTrialPlay(mode: string): void {
  const progress = getGameProgress();
  const today = new Date().toDateString();
  const lastPlayed = progress.trialPlays[mode]?.lastPlayed
    ? new Date(progress.trialPlays[mode].lastPlayed).toDateString()
    : null;

  // Reset if new day
  if (lastPlayed !== today) {
    progress.trialPlays[mode] = {
      lastPlayed: new Date().toISOString(),
      playsToday: 1,
    };
  } else {
    // Increment plays today
    progress.trialPlays[mode].playsToday += 1;
    progress.trialPlays[mode].lastPlayed = new Date().toISOString();
  }

  saveGameProgress(progress);
}

/**
 * Update daily challenge progress
 */
export function completeDailyChallenge(score: number): void {
  const progress = getGameProgress();
  const today = new Date().toDateString();
  const lastCompleted = progress.dailyChallenge.lastCompleted
    ? new Date(progress.dailyChallenge.lastCompleted).toDateString()
    : null;

  // Check if already completed today
  if (lastCompleted === today) {
    return; // Already completed today
  }

  // Check if streak continues
  const yesterday = new Date();
  yesterday.setDate(yesterday.getDate() - 1);
  const yesterdayStr = yesterday.toDateString();

  if (lastCompleted === yesterdayStr) {
    // Streak continues
    progress.dailyChallenge.streak += 1;
  } else {
    // Streak broken, start new
    progress.dailyChallenge.streak = 1;
  }

  // Update best streak
  progress.dailyChallenge.bestStreak = Math.max(
    progress.dailyChallenge.streak,
    progress.dailyChallenge.bestStreak
  );

  progress.dailyChallenge.lastCompleted = new Date().toISOString();

  saveGameProgress(progress);

  // Save as level progress too
  const dateKey = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
  saveLevelProgress({
    levelId: dateKey,
    mode: 'daily',
    completed: true,
    highScore: score,
    stars: 0,
    lastPlayed: new Date().toISOString(),
    attempts: 0,
  });
}

/**
 * Update game statistics
 */
export function updateStats(stats: Partial<GameProgress['stats']>): void {
  const progress = getGameProgress();

  progress.stats = {
    totalGamesPlayed: progress.stats.totalGamesPlayed + (stats.totalGamesPlayed || 0),
    totalScore: progress.stats.totalScore + (stats.totalScore || 0),
    totalLines: progress.stats.totalLines + (stats.totalLines || 0),
    totalCombos: progress.stats.totalCombos + (stats.totalCombos || 0),
    bestCombo: Math.max(progress.stats.bestCombo, stats.bestCombo || 0),
    totalPlayTime: progress.stats.totalPlayTime + (stats.totalPlayTime || 0),
  };

  saveGameProgress(progress);
}

/**
 * Reset all progress (for debugging/testing)
 */
export function resetAllProgress(): void {
  localStorage.removeItem(STORAGE_KEY);
  localStorage.removeItem(LEVEL_PROGRESS_KEY);
}

/**
 * Export progress as JSON (for backup/transfer)
 */
export function exportProgress(): string {
  const progress = getGameProgress();
  const levels = localStorage.getItem(LEVEL_PROGRESS_KEY);

  return JSON.stringify({
    progress,
    levels: levels ? JSON.parse(levels) : {},
    exportedAt: new Date().toISOString(),
  }, null, 2);
}

/**
 * Import progress from JSON (for backup/transfer)
 */
export function importProgress(jsonData: string): boolean {
  try {
    const data = JSON.parse(jsonData);

    if (data.progress) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data.progress));
    }

    if (data.levels) {
      localStorage.setItem(LEVEL_PROGRESS_KEY, JSON.stringify(data.levels));
    }

    return true;
  } catch (error) {
    console.error('Failed to import progress:', error);
    return false;
  }
}

/**
 * Get default progress object
 */
function getDefaultProgress(): GameProgress {
  return {
    campaignProgress: {
      currentLevel: 1,
      unlockedLevels: [1, 2, 3], // First 3 levels are free
      completedLevels: [],
      totalStars: 0,
    },
    unlockedModes: ['campaign'], // Campaign always unlocked
    dailyChallenge: {
      lastCompleted: null,
      streak: 0,
      bestStreak: 0,
    },
    stats: {
      totalGamesPlayed: 0,
      totalScore: 0,
      totalLines: 0,
      totalCombos: 0,
      bestCombo: 0,
      totalPlayTime: 0,
    },
    trialPlays: {},
    achievements: [],
  };
}
