'use client';

/**
 * Zen Mode Game Client
 *
 * Endless, relaxing gameplay with no time pressure or move limits.
 * Features:
 * - Endless gameplay until grid is full
 * - Calming visual aesthetic (muted colors, slower animations)
 * - Session tracking (time, score, lines cleared)
 * - Auto-save every 30 seconds
 * - Continue session on return
 * - Gentle haptic feedback
 * - Optional ambient music
 */

import { useEffect, useRef, useState, useCallback } from 'react';
import { Stage, Layer, Rect, Group, Text } from 'react-konva';
import Konva from 'konva';
import { musicManager } from '@/lib/audio/MusicManager';
import { soundEffects } from '@/lib/audio/SoundEffects';
import { haptics } from '@/lib/utils/haptics';
import { AudioControls } from '@/components/game/AudioControls';
import { saveLevelProgress, getLevelProgress } from '@/lib/storage/progressStorage';

// Zen mode uses a larger 10x10 grid for more relaxed gameplay
const GRID_SIZE = 10;

// Responsive sizing (same as KonvaGame)
const MIN_CELL_SIZE = 30;
const MAX_CELL_SIZE = 38; // Slightly smaller for 10x10 grid
const GRID_OFFSET_RATIO = 0.08;
const MIN_STAGE_WIDTH = 320;

// Zen-specific timing (slower, more relaxed)
const ZEN_ANIMATION_DURATION = 0.4; // Slower than normal (0.15)
const ZEN_BLOCK_SPAWN_DELAY = 200; // Slower spawn
const ZEN_AUTO_SAVE_INTERVAL = 30000; // 30 seconds

// Muted, calming color palette for Zen mode
const ZEN_COLORS = {
  background: '#f0f4f8', // Soft blue-gray
  gridBorder: '#b8c6d4',
  cellBorder: '#d4dee8',
  gridFill: '#fafbfc',
  text: '#5a6c7d',
  textSecondary: '#8a9fb0',
  validPreview: '#7ec4b5', // Soft teal
  invalidPreview: '#e89c9c', // Soft coral
};

interface BlockData {
  id: string;
  shape: number[][];
  color: string;
  x: number;
  y: number;
  originalX: number;
  originalY: number;
}

interface BlockConfig {
  id: string;
  shape: number[][];
  color: string;
  frequency: number;
}

interface ZenModeConfig {
  name: string;
  description: string;
  tier: string;
  gridConfig: {
    rows: number;
    cols: number;
  };
  scoreMultiplier: number;
  comboBonus: number;
  blocks: BlockConfig[];
}

interface SessionData {
  sessionId: string;
  startTime: number;
  currentTime: number;
  score: number;
  linesCleared: number;
  combos: number;
  grid: number[][];
  blocks: Array<{
    shape: number[][];
    color: string;
  }>;
}

/**
 * Calculate responsive dimensions
 */
function calculateDimensions(containerWidth: number) {
  const safeWidth = Math.max(containerWidth, MIN_STAGE_WIDTH);
  const availableWidth = safeWidth - (safeWidth * GRID_OFFSET_RATIO * 2);
  let cellSize = Math.floor(availableWidth / GRID_SIZE);
  cellSize = Math.max(MIN_CELL_SIZE, Math.min(MAX_CELL_SIZE, cellSize));

  const gridOffsetX = Math.floor(safeWidth * GRID_OFFSET_RATIO);
  const gridOffsetY = gridOffsetX;
  const gridWidth = cellSize * GRID_SIZE;
  const stageWidth = gridWidth + (gridOffsetX * 2);
  const spawnY = gridOffsetY + gridWidth + Math.floor(cellSize * 1.5);
  const maxBlockHeight = cellSize * 3;
  const stageHeight = spawnY + maxBlockHeight + (cellSize * 1.5);

  return {
    cellSize,
    gridOffsetX,
    gridOffsetY,
    stageWidth,
    stageHeight,
    spawnY,
  };
}

export function ZenGameClient() {
  // Responsive dimensions
  const [dimensions, setDimensions] = useState(() => calculateDimensions(800));

  // Game state
  const [grid, setGrid] = useState<number[][]>(() =>
    Array(GRID_SIZE).fill(0).map(() => Array(GRID_SIZE).fill(0))
  );
  const [blocks, setBlocks] = useState<BlockData[]>([]);
  const [score, setScore] = useState(0);
  const [linesCleared, setLinesCleared] = useState(0);
  const [combos, setCombos] = useState(0);
  const [comboCount, setComboCount] = useState(0);
  const [sessionTime, setSessionTime] = useState(0);
  const [isLoading, setIsLoading] = useState(true);
  const [isGameOver, setIsGameOver] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [showQuitConfirm, setShowQuitConfirm] = useState(false);
  const [dragPreview, setDragPreview] = useState<{
    row: number;
    col: number;
    shape: number[][];
    isValid: boolean;
  } | null>(null);

  // Session management
  const [sessionId, setSessionId] = useState<string>('');
  const [hasContinuedSession, setHasContinuedSession] = useState(false);

  // Refs
  const stageRef = useRef<Konva.Stage>(null);
  const containerRef = useRef<HTMLDivElement>(null);
  const configRef = useRef<ZenModeConfig | null>(null);
  const sessionTimerRef = useRef<NodeJS.Timeout | null>(null);
  const autoSaveTimerRef = useRef<NodeJS.Timeout | null>(null);
  const audioInitializedRef = useRef(false);

  /**
   * Load Zen mode configuration
   */
  useEffect(() => {
    async function loadConfig() {
      try {
        const basePath = process.env.NODE_ENV === 'production' ? '/block-puzzle-hero' : '';
        const response = await fetch(`${basePath}/modes/zen/config.json`);

        if (!response.ok) {
          throw new Error('Failed to load Zen mode config');
        }

        const config = await response.json() as ZenModeConfig;
        configRef.current = config;

        // Check for saved session
        await tryRestoreSession();
      } catch (error) {
        console.error('Failed to load Zen mode:', error);
      } finally {
        setIsLoading(false);
      }
    }

    loadConfig();
  }, []);

  /**
   * Try to restore a saved session
   */
  const tryRestoreSession = async () => {
    try {
      const savedSession = localStorage.getItem('zen-mode-session');
      if (savedSession) {
        const session: SessionData = JSON.parse(savedSession);

        // Only restore if session is less than 24 hours old
        const sessionAge = Date.now() - session.currentTime;
        if (sessionAge < 24 * 60 * 60 * 1000) {
          // Ask user if they want to continue
          const shouldContinue = window.confirm(
            'You have a saved Zen session. Would you like to continue where you left off?'
          );

          if (shouldContinue) {
            setSessionId(session.sessionId);
            setScore(session.score);
            setLinesCleared(session.linesCleared);
            setCombos(session.combos);
            setGrid(session.grid);
            setSessionTime(Math.floor((Date.now() - session.startTime) / 1000));
            setHasContinuedSession(true);

            // Restore blocks
            const restoredBlocks: BlockData[] = session.blocks.map((b, i) => ({
              id: `block-${Date.now()}-${i}`,
              shape: b.shape,
              color: b.color,
              x: dimensions.gridOffsetX + (i * (dimensions.cellSize * 3)),
              y: dimensions.spawnY,
              originalX: dimensions.gridOffsetX + (i * (dimensions.cellSize * 3)),
              originalY: dimensions.spawnY,
            }));
            setBlocks(restoredBlocks);
            return;
          }
        }

        // Clear old session
        localStorage.removeItem('zen-mode-session');
      }
    } catch (error) {
      console.error('Failed to restore session:', error);
    }

    // Start new session
    startNewSession();
  };

  /**
   * Start a new session
   */
  const startNewSession = useCallback(() => {
    const newSessionId = `zen-${Date.now()}`;
    setSessionId(newSessionId);
    setScore(0);
    setLinesCleared(0);
    setCombos(0);
    setSessionTime(0);
    setHasContinuedSession(false);

    // Initialize with fresh grid and blocks
    spawnBlocks();
  }, []);

  /**
   * Initialize audio on first user interaction
   */
  useEffect(() => {
    if (!audioInitializedRef.current) {
      const initAudio = () => {
        musicManager.initialize();
        soundEffects.initialize();
        audioInitializedRef.current = true;

        // Play calm ambient music for Zen mode
        // Set to lower volume for relaxation
        musicManager.setVolume(0.2);
        musicManager.play();
      };

      document.addEventListener('click', initAudio, { once: true });
      document.addEventListener('touchstart', initAudio, { once: true });

      return () => {
        document.removeEventListener('click', initAudio);
        document.removeEventListener('touchstart', initAudio);
      };
    }
    return undefined;
  }, []);

  /**
   * Handle responsive resize
   */
  useEffect(() => {
    const updateDimensions = () => {
      const isMobile = window.innerWidth < 768;
      const viewportWidth = window.innerWidth;
      const maxGameWidth = isMobile
        ? Math.min(viewportWidth * 0.95, 500)
        : Math.min(viewportWidth * 0.6, 500);

      const availableWidth = containerRef.current?.offsetWidth || maxGameWidth;
      const calculatedWidth = Math.min(availableWidth, maxGameWidth);

      setDimensions(calculateDimensions(calculatedWidth));
    };

    setTimeout(updateDimensions, 100);

    let resizeTimer: NodeJS.Timeout;
    const debouncedResize = () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(updateDimensions, 150);
    };

    window.addEventListener('resize', debouncedResize);
    return () => {
      window.removeEventListener('resize', debouncedResize);
      clearTimeout(resizeTimer);
    };
  }, []);

  /**
   * Session timer - tracks elapsed time
   */
  useEffect(() => {
    if (!isLoading && !isGameOver && !isPaused && sessionId) {
      sessionTimerRef.current = setInterval(() => {
        setSessionTime(prev => prev + 1);
      }, 1000);

      return () => {
        if (sessionTimerRef.current) {
          clearInterval(sessionTimerRef.current);
        }
      };
    }
    return undefined;
  }, [isLoading, isGameOver, isPaused, sessionId]);

  /**
   * Auto-save session every 30 seconds
   */
  useEffect(() => {
    if (!isLoading && !isGameOver && sessionId) {
      autoSaveTimerRef.current = setInterval(() => {
        saveSession();
      }, ZEN_AUTO_SAVE_INTERVAL);

      return () => {
        if (autoSaveTimerRef.current) {
          clearInterval(autoSaveTimerRef.current);
        }
      };
    }
    return undefined;
  }, [isLoading, isGameOver, sessionId, score, linesCleared, combos, grid, blocks]);

  /**
   * Save current session to localStorage
   */
  const saveSession = useCallback(() => {
    if (!sessionId) return;

    const session: SessionData = {
      sessionId,
      startTime: Date.now() - (sessionTime * 1000),
      currentTime: Date.now(),
      score,
      linesCleared,
      combos,
      grid,
      blocks: blocks.map(b => ({
        shape: b.shape,
        color: b.color,
      })),
    };

    try {
      localStorage.setItem('zen-mode-session', JSON.stringify(session));
    } catch (error) {
      console.error('Failed to save session:', error);
    }
  }, [sessionId, sessionTime, score, linesCleared, combos, grid, blocks]);

  /**
   * Spawn 3 random blocks from config
   */
  const spawnBlocks = useCallback(() => {
    if (!configRef.current) return;

    const newBlocks: BlockData[] = [];
    const availableBlocks = configRef.current.blocks;

    // Calculate weighted random selection based on frequency
    const totalFrequency = availableBlocks.reduce((sum, b) => sum + b.frequency, 0);

    const selectedBlocks = [];
    for (let i = 0; i < 3; i++) {
      let random = Math.random() * totalFrequency;
      let selectedBlock = availableBlocks[0];

      for (const block of availableBlocks) {
        random -= block.frequency;
        if (random <= 0) {
          selectedBlock = block;
          break;
        }
      }

      // Use muted, calming versions of the colors
      const zenColor = mutedColor(selectedBlock.color);
      const blockWidth = selectedBlock.shape[0].length * dimensions.cellSize;

      selectedBlocks.push({
        config: selectedBlock,
        color: zenColor,
        width: blockWidth,
      });
    }

    // Calculate positioning
    const totalBlocksWidth = selectedBlocks.reduce((sum, block) => sum + block.width, 0);
    const gap = dimensions.cellSize * 0.5;
    const totalGapsWidth = gap * 4;
    const totalNeededWidth = totalBlocksWidth + totalGapsWidth;
    const availableWidth = dimensions.stageWidth - (dimensions.gridOffsetX * 2);

    let currentX = dimensions.gridOffsetX + (availableWidth - totalNeededWidth) / 2 + gap;

    for (let i = 0; i < selectedBlocks.length; i++) {
      const { config, color, width } = selectedBlocks[i];

      newBlocks.push({
        id: `block-${Date.now()}-${i}`,
        shape: config.shape,
        color,
        x: currentX,
        y: dimensions.spawnY,
        originalX: currentX,
        originalY: dimensions.spawnY,
      });

      currentX += width + gap;
    }

    // Spawn with gentle staggered animation
    setBlocks([]);
    newBlocks.forEach((block, index) => {
      setTimeout(() => {
        setBlocks(prev => [...prev, block]);
      }, index * ZEN_BLOCK_SPAWN_DELAY);
    });
  }, [dimensions]);

  /**
   * Convert colors to muted, calming versions
   */
  const mutedColor = (color: string): string => {
    // Parse hex color
    const hex = color.replace('#', '');
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);

    // Desaturate and lighten for calm aesthetic
    const avg = (r + g + b) / 3;
    const newR = Math.floor(r * 0.6 + avg * 0.4);
    const newG = Math.floor(g * 0.6 + avg * 0.4);
    const newB = Math.floor(b * 0.6 + avg * 0.4);

    // Convert back to hex
    return `#${newR.toString(16).padStart(2, '0')}${newG.toString(16).padStart(2, '0')}${newB.toString(16).padStart(2, '0')}`;
  };

  /**
   * Convert world coordinates to grid position
   */
  const worldToGrid = useCallback((worldX: number, worldY: number) => {
    const gridX = worldX - dimensions.gridOffsetX;
    const gridY = worldY - dimensions.gridOffsetY;

    if (gridX < 0 || gridY < 0 ||
        gridX >= GRID_SIZE * dimensions.cellSize ||
        gridY >= GRID_SIZE * dimensions.cellSize) {
      return null;
    }

    const col = Math.floor(gridX / dimensions.cellSize);
    const row = Math.floor(gridY / dimensions.cellSize);

    if (row < 0 || col < 0 || row >= GRID_SIZE || col >= GRID_SIZE) {
      return null;
    }

    return { row, col };
  }, [dimensions]);

  /**
   * Check if block can be placed at position
   */
  const canPlaceBlock = useCallback((row: number, col: number, shape: number[][]) => {
    if (row < 0 || col < 0) return false;
    if (row + shape.length > GRID_SIZE) return false;
    if (col + shape[0].length > GRID_SIZE) return false;

    for (let r = 0; r < shape.length; r++) {
      for (let c = 0; c < shape[r].length; c++) {
        if (shape[r][c] === 1 && grid[row + r][col + c] !== 0) {
          return false;
        }
      }
    }

    return true;
  }, [grid]);

  /**
   * Check if any moves are available
   */
  const checkMovesAvailable = useCallback((currentBlocks: BlockData[]) => {
    for (const block of currentBlocks) {
      for (let row = 0; row < GRID_SIZE; row++) {
        for (let col = 0; col < GRID_SIZE; col++) {
          if (canPlaceBlock(row, col, block.shape)) {
            return true;
          }
        }
      }
    }
    return false;
  }, [canPlaceBlock]);

  /**
   * Check for game over
   */
  useEffect(() => {
    if (blocks.length > 0 && !isLoading && !isGameOver) {
      const timer = setTimeout(() => {
        const movesAvailable = checkMovesAvailable(blocks);
        if (!movesAvailable) {
          handleGameOver();
        }
      }, 100);
      return () => clearTimeout(timer);
    }
    return undefined;
  }, [blocks, isLoading, isGameOver, checkMovesAvailable]);

  /**
   * Check and clear completed lines
   */
  const checkAndClearLines = useCallback((currentGrid: number[][]) => {
    const newGrid = currentGrid.map(row => [...row]);
    let cleared = 0;

    // Check rows
    for (let row = 0; row < GRID_SIZE; row++) {
      if (newGrid[row].every(cell => cell !== 0)) {
        newGrid[row].fill(0);
        cleared++;
      }
    }

    // Check columns
    for (let col = 0; col < GRID_SIZE; col++) {
      const columnFilled = newGrid.every(row => row[col] !== 0);
      if (columnFilled) {
        for (let row = 0; row < GRID_SIZE; row++) {
          newGrid[row][col] = 0;
        }
        cleared++;
      }
    }

    return { cleared, newGrid };
  }, []);

  /**
   * Place block on grid
   */
  const placeBlock = useCallback((blockId: string, row: number, col: number, shape: number[][], color: string) => {
    const newGrid = grid.map(row => [...row]);
    const colorValue = parseInt(color.replace('#', ''), 16);
    let cellsPlaced = 0;

    for (let r = 0; r < shape.length; r++) {
      for (let c = 0; c < shape[r].length; c++) {
        if (shape[r][c] === 1) {
          newGrid[row + r][col + c] = colorValue;
          cellsPlaced++;
        }
      }
    }

    setGrid(newGrid);

    // Gentle sound and haptic feedback
    soundEffects.play('blockPlace', { volume: 0.5 });
    haptics.triggerCustom(15); // Softer haptic

    // Remove placed block
    setBlocks(prev => prev.filter(b => b.id !== blockId));

    // Add score for cells
    const cellScore = cellsPlaced * 10;
    setScore(prev => prev + cellScore);

    // Check for line clears
    setTimeout(() => {
      const { cleared, newGrid: clearedGrid } = checkAndClearLines(newGrid);

      if (cleared > 0) {
        setGrid(clearedGrid);
        setLinesCleared(prev => prev + cleared);

        // Gentle feedback
        soundEffects.play('lineClear', { volume: 0.6 });
        haptics.triggerCustom(20);

        // Update combo
        setComboCount(prev => {
          const newCombo = prev + 1;
          const comboMultiplier = configRef.current?.comboBonus || 0.25;
          const lineScore = cleared * 100 * (1 + newCombo * comboMultiplier);
          setScore(prevScore => prevScore + lineScore);

          if (newCombo > 1) {
            soundEffects.playCombo(newCombo);
            setCombos(prevCombos => prevCombos + 1);
            haptics.triggerCustom([15, 10, 15]);
          }

          return newCombo;
        });
      } else {
        setComboCount(0);
      }

      // Spawn new blocks when all are placed
      const remainingBlocks = blocks.filter(b => b.id !== blockId);
      if (remainingBlocks.length === 0) {
        setTimeout(spawnBlocks, 500);
      }
    }, 100);
  }, [grid, blocks, spawnBlocks, checkAndClearLines]);

  /**
   * Find nearest valid position for magnetic snap
   */
  const findNearestValidPosition = useCallback((x: number, y: number, shape: number[][]) => {
    const snapRadius = dimensions.cellSize * 1.5;
    const centerRow = Math.round((y - dimensions.gridOffsetY) / dimensions.cellSize);
    const centerCol = Math.round((x - dimensions.gridOffsetX) / dimensions.cellSize);

    let bestPosition: { row: number; col: number; distance: number } | null = null;

    for (let radius = 0; radius <= 2; radius++) {
      for (let row = centerRow - radius; row <= centerRow + radius; row++) {
        for (let col = centerCol - radius; col <= centerCol + radius; col++) {
          if (row < 0 || col < 0 || row >= GRID_SIZE || col >= GRID_SIZE) continue;

          if (canPlaceBlock(row, col, shape)) {
            const posX = dimensions.gridOffsetX + col * dimensions.cellSize;
            const posY = dimensions.gridOffsetY + row * dimensions.cellSize;
            const distance = Math.sqrt(Math.pow(x - posX, 2) + Math.pow(y - posY, 2));

            if (distance <= snapRadius) {
              if (!bestPosition || distance < bestPosition.distance) {
                bestPosition = { row, col, distance };
              }
            }
          }
        }
      }
    }

    return bestPosition ? { row: bestPosition.row, col: bestPosition.col } : null;
  }, [dimensions, canPlaceBlock]);

  /**
   * Handle drag move
   */
  const handleDragMove = useCallback((blockId: string) => (e: Konva.KonvaEventObject<DragEvent>) => {
    const block = blocks.find(b => b.id === blockId);
    if (!block) return;

    const shape = e.target;
    const x = shape.x();
    const y = shape.y();

    const gridPos = worldToGrid(x, y);

    if (gridPos) {
      const { row, col } = gridPos;
      const isValid = canPlaceBlock(row, col, block.shape);
      setDragPreview({ row, col, shape: block.shape, isValid });
    } else {
      setDragPreview(null);
    }
  }, [blocks, worldToGrid, canPlaceBlock]);

  /**
   * Handle drag end
   */
  const handleDragEnd = useCallback((blockId: string) => (e: Konva.KonvaEventObject<DragEvent>) => {
    const block = blocks.find(b => b.id === blockId);
    if (!block) return;

    setDragPreview(null);

    const shape = e.target;
    const x = shape.x();
    const y = shape.y();

    const gridPos = worldToGrid(x, y);
    let targetRow: number;
    let targetCol: number;

    if (gridPos && canPlaceBlock(gridPos.row, gridPos.col, block.shape)) {
      targetRow = gridPos.row;
      targetCol = gridPos.col;
    } else {
      const nearestPos = findNearestValidPosition(x, y, block.shape);

      if (nearestPos) {
        targetRow = nearestPos.row;
        targetCol = nearestPos.col;
      } else {
        // Return to original position with zen-like smooth animation
        shape.to({
          x: block.originalX,
          y: block.originalY,
          duration: ZEN_ANIMATION_DURATION,
        });
        return;
      }
    }

    // Snap to grid with smooth animation
    const snapX = dimensions.gridOffsetX + targetCol * dimensions.cellSize;
    const snapY = dimensions.gridOffsetY + targetRow * dimensions.cellSize;

    shape.to({
      x: snapX,
      y: snapY,
      duration: ZEN_ANIMATION_DURATION,
      onFinish: () => {
        placeBlock(blockId, targetRow, targetCol, block.shape, block.color);
      }
    });
  }, [blocks, worldToGrid, canPlaceBlock, findNearestValidPosition, placeBlock, dimensions]);

  /**
   * Handle game over
   */
  const handleGameOver = useCallback(() => {
    setIsGameOver(true);

    // Soft game over feedback
    soundEffects.play('gameOver', { volume: 0.4 });
    haptics.triggerCustom([30, 20, 30]);

    // Save to leaderboard
    saveLevelProgress({
      levelId: sessionId,
      mode: 'zen',
      completed: true,
      highScore: score,
      stars: 0,
      time: sessionTime,
      lastPlayed: new Date().toISOString(),
      attempts: 0,
    });

    // Clear saved session
    localStorage.removeItem('zen-mode-session');
  }, [sessionId, score, sessionTime]);

  /**
   * Handle voluntary quit
   */
  const handleQuit = useCallback(() => {
    saveSession();
    setShowQuitConfirm(false);
    window.location.href = '/modes';
  }, [saveSession]);

  /**
   * Format time display (HH:MM:SS)
   */
  const formatTime = (seconds: number): string => {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = seconds % 60;

    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    return `${minutes}:${secs.toString().padStart(2, '0')}`;
  };

  if (isLoading) {
    return (
      <div className="w-full flex flex-col items-center" ref={containerRef}>
        <div className="flex items-center justify-center rounded-xl shadow-lg p-6 border"
             style={{
               width: dimensions.stageWidth,
               height: dimensions.stageHeight,
               backgroundColor: ZEN_COLORS.background,
               borderColor: ZEN_COLORS.gridBorder,
             }}>
          <div className="text-center">
            <div className="animate-spin rounded-full h-16 w-16 border-b-4 mx-auto mb-4"
                 style={{ borderColor: ZEN_COLORS.validPreview }}></div>
            <p style={{ color: ZEN_COLORS.text }} className="text-xl font-medium">
              Loading Zen Mode...
            </p>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="w-full flex flex-col items-center" ref={containerRef}>
      {/* Session Stats HUD */}
      <div className="mb-4 p-4 rounded-lg shadow-md border w-full max-w-2xl"
           style={{
             backgroundColor: ZEN_COLORS.background,
             borderColor: ZEN_COLORS.gridBorder,
           }}>
        <div className="grid grid-cols-3 gap-4 text-center">
          <div>
            <div style={{ color: ZEN_COLORS.textSecondary }} className="text-sm">Time</div>
            <div style={{ color: ZEN_COLORS.text }} className="text-2xl font-bold">
              {formatTime(sessionTime)}
            </div>
          </div>
          <div>
            <div style={{ color: ZEN_COLORS.textSecondary }} className="text-sm">Score</div>
            <div style={{ color: ZEN_COLORS.text }} className="text-2xl font-bold">
              {score.toLocaleString()}
            </div>
          </div>
          <div>
            <div style={{ color: ZEN_COLORS.textSecondary }} className="text-sm">Lines</div>
            <div style={{ color: ZEN_COLORS.text }} className="text-2xl font-bold">
              {linesCleared}
            </div>
          </div>
        </div>
      </div>

      {/* Konva Stage */}
      <div className="rounded-xl shadow-lg p-6 border"
           style={{
             touchAction: 'none',
             userSelect: 'none',
             WebkitUserSelect: 'none',
             backgroundColor: ZEN_COLORS.background,
             borderColor: ZEN_COLORS.gridBorder,
           }}>
        <Stage
          width={dimensions.stageWidth}
          height={dimensions.stageHeight}
          ref={stageRef}
          listening={!isGameOver && !isPaused}
        >
          {/* Grid Layer */}
          <Layer>
            <Rect
              x={dimensions.gridOffsetX}
              y={dimensions.gridOffsetY}
              width={GRID_SIZE * dimensions.cellSize}
              height={GRID_SIZE * dimensions.cellSize}
              fill={ZEN_COLORS.gridFill}
              stroke={ZEN_COLORS.gridBorder}
              strokeWidth={2}
              cornerRadius={12}
            />

            {/* Grid cells */}
            {Array.from({ length: GRID_SIZE }).map((_, row) =>
              Array.from({ length: GRID_SIZE }).map((_, col) => {
                const cellValue = grid[row][col];
                const x = dimensions.gridOffsetX + col * dimensions.cellSize;
                const y = dimensions.gridOffsetY + row * dimensions.cellSize;

                return (
                  <Group key={`cell-${row}-${col}`}>
                    <Rect
                      x={x}
                      y={y}
                      width={dimensions.cellSize}
                      height={dimensions.cellSize}
                      stroke={ZEN_COLORS.cellBorder}
                      strokeWidth={1}
                    />

                    {cellValue !== 0 && (
                      <Rect
                        x={x + 3}
                        y={y + 3}
                        width={dimensions.cellSize - 6}
                        height={dimensions.cellSize - 6}
                        fill={`#${cellValue.toString(16).padStart(6, '0')}`}
                        cornerRadius={8}
                        shadowColor="rgba(0,0,0,0.1)"
                        shadowBlur={3}
                        shadowOffset={{x: 0, y: 1}}
                        shadowOpacity={0.2}
                      />
                    )}
                  </Group>
                );
              })
            )}

            <Text
              text="Breathe, relax, and play at your pace"
              x={dimensions.gridOffsetX}
              y={dimensions.spawnY - dimensions.cellSize}
              fontSize={Math.max(12, Math.min(16, dimensions.cellSize * 0.3))}
              fill={ZEN_COLORS.textSecondary}
              fontStyle="400"
              width={dimensions.stageWidth - (dimensions.gridOffsetX * 2)}
              align="center"
            />
          </Layer>

          {/* Preview Layer */}
          <Layer>
            {dragPreview && (
              <>
                {dragPreview.shape.map((row, r) =>
                  row.map((cell, c) => {
                    if (cell === 1) {
                      const x = dimensions.gridOffsetX + (dragPreview.col + c) * dimensions.cellSize;
                      const y = dimensions.gridOffsetY + (dragPreview.row + r) * dimensions.cellSize;

                      return (
                        <Rect
                          key={`preview-${r}-${c}`}
                          x={x + 3}
                          y={y + 3}
                          width={dimensions.cellSize - 6}
                          height={dimensions.cellSize - 6}
                          fill={dragPreview.isValid ? ZEN_COLORS.validPreview : ZEN_COLORS.invalidPreview}
                          opacity={0.5}
                          cornerRadius={8}
                          listening={false}
                        />
                      );
                    }
                    return null;
                  })
                )}
              </>
            )}
          </Layer>

          {/* Blocks Layer */}
          <Layer>
            {blocks.map((block) => {
              return (
                <Group
                  key={block.id}
                  x={block.x}
                  y={block.y}
                  draggable={!isGameOver && !isPaused}
                  onDragMove={handleDragMove(block.id)}
                  onDragEnd={handleDragEnd(block.id)}
                  onDragStart={(e) => {
                    e.target.moveToTop();
                    haptics.triggerCustom(10); // Very gentle pickup
                  }}
                  onMouseEnter={(e) => {
                    const stage = e.target.getStage();
                    if (stage && !isGameOver && !isPaused) {
                      stage.container().style.cursor = 'grab';
                    }
                  }}
                  onMouseLeave={(e) => {
                    const stage = e.target.getStage();
                    if (stage) {
                      stage.container().style.cursor = 'default';
                    }
                  }}
                >
                  {block.shape.map((row, r) =>
                    row.map((cell, c) => {
                      if (cell === 1) {
                        const x = c * dimensions.cellSize;
                        const y = r * dimensions.cellSize;

                        return (
                          <Rect
                            key={`${r}-${c}`}
                            x={x}
                            y={y}
                            width={dimensions.cellSize - 6}
                            height={dimensions.cellSize - 6}
                            fill={block.color}
                            stroke="#ffffff"
                            strokeWidth={2}
                            cornerRadius={10}
                            shadowColor="rgba(0,0,0,0.15)"
                            shadowBlur={8}
                            shadowOffset={{x: 0, y: 2}}
                            shadowOpacity={0.3}
                          />
                        );
                      }
                      return null;
                    })
                  )}
                </Group>
              );
            })}
          </Layer>
        </Stage>
      </div>

      {/* Combo indicator (subtle) */}
      {comboCount > 1 && (
        <div className="mt-4 px-4 py-2 rounded-lg border shadow-sm"
             style={{
               backgroundColor: ZEN_COLORS.background,
               borderColor: ZEN_COLORS.validPreview,
             }}>
          <span style={{ color: ZEN_COLORS.textSecondary }} className="font-medium">
            Combo:
          </span>{' '}
          <span style={{ color: ZEN_COLORS.validPreview }} className="font-bold">
            x{comboCount}
          </span>
        </div>
      )}

      {/* Control buttons */}
      <div className="mt-4 flex gap-3">
        <button
          onClick={() => setIsPaused(!isPaused)}
          className="px-4 py-2 rounded-lg font-medium shadow-sm border transition-colors"
          style={{
            backgroundColor: ZEN_COLORS.background,
            borderColor: ZEN_COLORS.gridBorder,
            color: ZEN_COLORS.text,
          }}
        >
          {isPaused ? 'Resume' : 'Pause'}
        </button>
        <button
          onClick={() => setShowQuitConfirm(true)}
          className="px-4 py-2 rounded-lg font-medium shadow-sm border transition-colors"
          style={{
            backgroundColor: ZEN_COLORS.background,
            borderColor: ZEN_COLORS.invalidPreview,
            color: ZEN_COLORS.text,
          }}
        >
          Save & Quit
        </button>
      </div>

      {/* Game Over Modal */}
      {isGameOver && (
        <div className="fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50">
          <div className="rounded-2xl shadow-2xl p-8 max-w-md mx-4 text-center"
               style={{ backgroundColor: ZEN_COLORS.background }}>
            <div className="text-6xl mb-4">üßò</div>
            <h2 className="text-3xl font-bold mb-2" style={{ color: ZEN_COLORS.text }}>
              Session Complete
            </h2>
            <p style={{ color: ZEN_COLORS.textSecondary }} className="mb-4">
              No more moves available
            </p>
            <div className="rounded-lg p-6 mb-6 border"
                 style={{
                   backgroundColor: ZEN_COLORS.gridFill,
                   borderColor: ZEN_COLORS.gridBorder,
                 }}>
              <div className="grid grid-cols-2 gap-4 mb-4">
                <div>
                  <div style={{ color: ZEN_COLORS.textSecondary }} className="text-sm">
                    Time Played
                  </div>
                  <div style={{ color: ZEN_COLORS.text }} className="text-xl font-bold">
                    {formatTime(sessionTime)}
                  </div>
                </div>
                <div>
                  <div style={{ color: ZEN_COLORS.textSecondary }} className="text-sm">
                    Lines Cleared
                  </div>
                  <div style={{ color: ZEN_COLORS.text }} className="text-xl font-bold">
                    {linesCleared}
                  </div>
                </div>
              </div>
              <div style={{ color: ZEN_COLORS.textSecondary }} className="text-sm mb-1">
                Final Score
              </div>
              <div style={{ color: ZEN_COLORS.text }} className="text-4xl font-bold">
                {score.toLocaleString()}
              </div>
            </div>
            <button
              onClick={() => window.location.reload()}
              className="w-full font-bold py-3 px-6 rounded-lg transition-all shadow-lg"
              style={{
                backgroundColor: ZEN_COLORS.validPreview,
                color: 'white',
              }}
            >
              New Session
            </button>
          </div>
        </div>
      )}

      {/* Quit Confirmation Modal */}
      {showQuitConfirm && (
        <div className="fixed inset-0 bg-black bg-opacity-40 flex items-center justify-center z-50">
          <div className="rounded-2xl shadow-2xl p-8 max-w-md mx-4"
               style={{ backgroundColor: ZEN_COLORS.background }}>
            <h3 className="text-2xl font-bold mb-4" style={{ color: ZEN_COLORS.text }}>
              Save Session?
            </h3>
            <p style={{ color: ZEN_COLORS.textSecondary }} className="mb-6">
              Your progress will be saved and you can continue later.
            </p>
            <div className="flex gap-3">
              <button
                onClick={() => setShowQuitConfirm(false)}
                className="flex-1 py-2 px-4 rounded-lg font-medium border"
                style={{
                  backgroundColor: ZEN_COLORS.background,
                  borderColor: ZEN_COLORS.gridBorder,
                  color: ZEN_COLORS.text,
                }}
              >
                Cancel
              </button>
              <button
                onClick={handleQuit}
                className="flex-1 py-2 px-4 rounded-lg font-medium"
                style={{
                  backgroundColor: ZEN_COLORS.validPreview,
                  color: 'white',
                }}
              >
                Save & Quit
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Pause Overlay */}
      {isPaused && (
        <div className="fixed inset-0 bg-black bg-opacity-30 flex items-center justify-center z-40">
          <div className="rounded-xl shadow-xl p-6"
               style={{ backgroundColor: ZEN_COLORS.background }}>
            <div className="text-4xl mb-2 text-center">‚è∏Ô∏è</div>
            <p style={{ color: ZEN_COLORS.text }} className="text-xl font-bold">
              Paused
            </p>
          </div>
        </div>
      )}

      {/* Audio Controls */}
      <div className="absolute top-4 right-4 z-40">
        <AudioControls />
      </div>
    </div>
  );
}
