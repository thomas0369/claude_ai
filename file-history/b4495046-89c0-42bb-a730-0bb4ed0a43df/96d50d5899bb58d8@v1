import { spawn, ChildProcess } from 'child_process';
import path from 'path';

export interface PythonExecutorOptions {
  scriptName: string;
  args?: string[];
  stdin?: string; // JSON string to pass via stdin
  timeout?: number;
  onStdout?: (data: string) => void;
  onStderr?: (data: string) => void;
}

export interface PythonExecutionResult {
  stdout: string;
  stderr: string;
  exitCode: number;
}

/**
 * Utility class for executing Python scripts with consistent error handling,
 * path resolution, and timeout management.
 */
export class PythonExecutor {
  private static readonly DEFAULT_TIMEOUT = 120000; // 2 minutes

  /**
   * Get the repository root path from environment or default
   */
  private static getRepoRoot(): string {
    return process.env.REPO_ROOT || path.join(process.cwd(), '..');
  }

  /**
   * Execute a Python script and return the result
   *
   * @param options - Execution options
   * @returns Promise resolving to stdout content
   * @throws Error if script fails or times out
   */
  static async execute(options: PythonExecutorOptions): Promise<string> {
    const timeout = options.timeout || this.DEFAULT_TIMEOUT;

    return Promise.race([
      this._executeProcess(options),
      this._createTimeoutPromise(timeout, options.scriptName)
    ]);
  }

  /**
   * Create a ReadableStream for Server-Sent Events from Python script output
   *
   * @param options - Execution options
   * @returns ReadableStream for SSE responses
   */
  static createStreamingResponse(options: PythonExecutorOptions): ReadableStream {
    const scriptPath = path.join(this.getRepoRoot(), 'scripts', options.scriptName);
    const encoder = new TextEncoder();

    return new ReadableStream({
      start(controller) {
        const pythonProcess = spawn('python3', [scriptPath, ...(options.args || [])], {
          env: { ...process.env, PYTHONUNBUFFERED: '1' } // Disable Python output buffering
        });

        pythonProcess.stdout.on('data', (data) => {
          const chunk = data.toString();

          // Send to custom handler if provided
          options.onStdout?.(chunk);

          // Parse and send SSE events
          const lines = chunk.split('\n');
          for (const line of lines) {
            if (line.trim().startsWith('{')) {
              try {
                // Validate it's parseable JSON
                JSON.parse(line);
                controller.enqueue(encoder.encode(`data: ${line}\n\n`));
              } catch (e) {
                // Skip invalid JSON lines
                console.warn(`[Python ${options.scriptName}] Invalid JSON:`, line.slice(0, 100));
              }
            }
          }
        });

        pythonProcess.stderr.on('data', (data) => {
          const chunk = data.toString();
          console.error(`[Python ${options.scriptName}] stderr:`, chunk.slice(0, 200));
          options.onStderr?.(chunk);
        });

        pythonProcess.on('close', (code) => {
          if (code !== 0) {
            controller.enqueue(
              encoder.encode(`data: ${JSON.stringify({
                error: true,
                message: `Python process failed with exit code ${code}`,
                code
              })}\n\n`)
            );
          }
          controller.close();
        });

        pythonProcess.on('error', (error) => {
          console.error(`[Python ${options.scriptName}] Spawn failed:`, error.message);
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify({
              error: true,
              message: `Failed to start Python process: ${error.message}`
            })}\n\n`)
          );
          controller.close();
        });
      }
    });
  }

  /**
   * Internal method to execute the Python process
   */
  private static _executeProcess(options: PythonExecutorOptions): Promise<string> {
    const scriptPath = path.join(this.getRepoRoot(), 'scripts', options.scriptName);
    const args = options.args || [];

    return new Promise((resolve, reject) => {
      const pythonProcess = spawn('python3', [scriptPath, ...args]);

      let stdout = '';
      let stderr = '';

      // If stdin data is provided, write it to the process
      if (options.stdin) {
        pythonProcess.stdin.write(options.stdin);
        pythonProcess.stdin.end();
      }

      pythonProcess.stdout.on('data', (data) => {
        const chunk = data.toString();
        stdout += chunk;
        options.onStdout?.(chunk);
      });

      pythonProcess.stderr.on('data', (data) => {
        const chunk = data.toString();
        stderr += chunk;
        options.onStderr?.(chunk);
      });

      pythonProcess.on('close', (code) => {
        if (code !== 0) {
          // Log full error server-side
          console.error(`[Python ${options.scriptName}] Process failed:`, {
            code,
            stderr: stderr.slice(0, 500)
          });

          reject(new Error(
            `Python script failed with code ${code}: ${this._sanitizeError(stderr)}`
          ));
        } else {
          resolve(stdout);
        }
      });

      pythonProcess.on('error', (error) => {
        console.error(`[Python ${options.scriptName}] Spawn failed:`, error);
        reject(new Error(`Failed to start Python process: ${error.message}`));
      });
    });
  }

  /**
   * Create a timeout promise that rejects after the specified duration
   */
  private static _createTimeoutPromise(timeout: number, scriptName: string): Promise<never> {
    return new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Python script '${scriptName}' timed out after ${timeout}ms`));
      }, timeout);
    });
  }

  /**
   * Sanitize error messages to avoid exposing sensitive information
   * Only shows detailed errors in development mode
   */
  private static _sanitizeError(stderr: string): string {
    if (process.env.NODE_ENV === 'development') {
      return stderr.slice(0, 500); // Limit length even in dev
    }

    // In production, only return generic error
    return 'Script execution failed. Check server logs for details.';
  }

  /**
   * Validate that required Python dependencies are installed
   *
   * @param dependencies - List of Python package names to check
   * @returns Promise<string[]> - List of missing packages
   */
  static async validateDependencies(dependencies: string[]): Promise<string[]> {
    const missing: string[] = [];

    for (const dep of dependencies) {
      try {
        await this.execute({
          scriptName: '../node_modules/.bin/python3', // Use absolute python3
          args: ['-c', `import ${dep}`],
          timeout: 5000
        });
      } catch (error) {
        missing.push(dep);
      }
    }

    return missing;
  }
}
