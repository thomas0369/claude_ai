/**
 * DeepSeek Vision API Client
 * ===========================
 *
 * TypeScript client for DeepSeek-VL2 vision model.
 * Supports intelligent PDF datasheet extraction with rate limiting and cost controls.
 *
 * Based on Python implementation: scripts/deepseek_vision_client.py
 *
 * Usage:
 *   const client = new DeepSeekVisionClient({ apiKey: 'sk-xxx' });
 *   const result = await client.extractFromImage(imageBase64);
 */

import {
  type DeepSeekConfig,
  type ExtractionResult,
  type DeepSeekAPIRequest,
  type DeepSeekAPIResponse,
  type RateLimitState,
  type ExtractionStats,
  DeepSeekAPIError,
  DeepSeekRateLimitError,
  DeepSeekCostLimitError,
  ExtractionResultSchema,
  DEFAULT_CONFIG,
  DEEPSEEK_PRICING,
} from './types';

export class DeepSeekVisionClient {
  private config: Required<DeepSeekConfig>;
  private state: RateLimitState;
  private durations: number[] = [];
  private successCount: number = 0;
  private failureCount: number = 0;

  constructor(config: DeepSeekConfig) {
    // Merge with defaults
    this.config = {
      ...DEFAULT_CONFIG,
      ...config,
    } as Required<DeepSeekConfig>;

    // Validate API key
    if (!this.config.apiKey) {
      throw new Error(
        'API key required. Set DEEPSEEK_API_KEY environment variable or pass apiKey parameter.'
      );
    }

    // Initialize state
    this.state = {
      requestTimes: [],
      totalCost: 0,
      requestCount: 0,
    };
  }

  /**
   * Extract structured data from a single datasheet image
   */
  async extractFromImage(
    imageBase64: string,
    temperature: number = 0.1
  ): Promise<ExtractionResult | null> {
    // Check rate limit
    await this.checkRateLimit();

    // Check cost limit
    const estimatedCost = this.estimateCost(1);
    this.checkCostLimit(estimatedCost);

    // Create API request payload
    const payload: DeepSeekAPIRequest = {
      model: 'deepseek-vl2',
      messages: [
        {
          role: 'user',
          content: [
            {
              type: 'text',
              text: this.createExtractionPrompt(),
            },
            {
              type: 'image_url',
              image_url: {
                url: `data:image/png;base64,${imageBase64}`,
              },
            },
          ],
        },
      ],
      temperature,
      max_tokens: 2000,
    };

    // Call API with retry logic
    try {
      const result = await this.callAPIWithRetry(payload);

      // Update cost tracking
      this.state.totalCost += estimatedCost;
      this.state.requestCount += 1;

      return result;
    } catch (error) {
      console.error('DeepSeek extraction failed:', error);
      return null;
    }
  }

  /**
   * Extract data from multiple PDF page images and aggregate results
   */
  async extractFromImages(
    imageBase64List: string[],
    aggregate: boolean = true
  ): Promise<ExtractionResult | ExtractionResult[] | null> {
    const results: ExtractionResult[] = [];

    for (const imageBase64 of imageBase64List) {
      const result = await this.extractFromImage(imageBase64);
      if (result) {
        results.push(result);
      }
    }

    if (results.length === 0) {
      return null;
    }

    if (aggregate && results.length > 1) {
      return this.mergeExtractionResults(results);
    }

    return results.length === 1 ? results[0] : results;
  }

  /**
   * Get current usage statistics
   */
  getStats(): ExtractionStats {
    const totalAttempts = this.successCount + this.failureCount;
    return {
      requestCount: this.state.requestCount,
      totalCost: this.state.totalCost,
      averageDuration:
        this.durations.length > 0
          ? this.durations.reduce((a, b) => a + b, 0) / this.durations.length
          : 0,
      successRate: totalAttempts > 0 ? (this.successCount / totalAttempts) * 100 : 0,
    };
  }

  /**
   * Reset cost and request counters
   */
  resetStats(): void {
    this.state.totalCost = 0;
    this.state.requestCount = 0;
    this.state.requestTimes = [];
    this.durations = [];
    this.successCount = 0;
    this.failureCount = 0;
  }

  /**
   * Call DeepSeek API with retry logic and exponential backoff
   */
  private async callAPIWithRetry(
    payload: DeepSeekAPIRequest,
    attempt: number = 0
  ): Promise<ExtractionResult | null> {
    try {
      const startTime = Date.now();

      // Record request time for rate limiting
      this.state.requestTimes.push(new Date());

      // Make API request
      const controller = new AbortController();
      const timeoutId = setTimeout(
        () => controller.abort(),
        this.config.timeout
      );

      const response = await fetch(
        `${this.config.baseUrl}/chat/completions`,
        {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${this.config.apiKey}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
          signal: controller.signal,
        }
      );

      clearTimeout(timeoutId);

      const elapsed = Date.now() - startTime;
      console.log(`DeepSeek API response in ${(elapsed / 1000).toFixed(2)}s`);

      // Handle specific status codes
      if (response.status === 401) {
        throw new DeepSeekAPIError(
          'Authentication failed - invalid API key',
          401
        );
      }

      if (response.status === 429) {
        if (attempt < this.config.retries) {
          const waitTime = Math.pow(2, attempt) * 5000;
          console.warn(`Rate limited, waiting ${waitTime / 1000}s...`);
          await this.sleep(waitTime);
          return this.callAPIWithRetry(payload, attempt + 1);
        } else {
          throw new DeepSeekRateLimitError(
            'Rate limit exceeded, no retries left'
          );
        }
      }

      if (response.status >= 500) {
        if (attempt < this.config.retries) {
          console.warn(
            `Server error ${response.status}, retrying (attempt ${attempt + 1}/${this.config.retries})...`
          );
          await this.sleep(2000);
          return this.callAPIWithRetry(payload, attempt + 1);
        } else {
          throw new DeepSeekAPIError(
            `Server error: ${response.status}`,
            response.status
          );
        }
      }

      if (!response.ok) {
        const errorText = await response.text();
        throw new DeepSeekAPIError(
          `API error: ${response.status} - ${errorText}`,
          response.status
        );
      }

      // Parse response
      const result: DeepSeekAPIResponse = await response.json();

      // Validate response structure
      if (!result.choices || result.choices.length === 0) {
        console.error('Unexpected response structure:', result);
        return null;
      }

      const content = result.choices[0].message.content;

      // Parse JSON from response (handle markdown code blocks)
      const extractedData = this.parseResponse(content);

      if (!extractedData) {
        return null;
      }

      // Validate with Zod schema
      try {
        const validated = ExtractionResultSchema.parse(extractedData);

        // Track success and duration
        this.durations.push(elapsed);
        this.successCount++;

        return validated;
      } catch (error) {
        console.error('Response validation failed:', error);
        console.debug('Raw data:', extractedData);
        this.failureCount++;
        return null;
      }
    } catch (error) {
      // Track failure
      this.failureCount++;

      if (error instanceof DeepSeekAPIError || error instanceof DeepSeekRateLimitError) {
        throw error;
      }

      if (error instanceof Error && error.name === 'AbortError') {
        if (attempt < this.config.retries) {
          console.warn('Request timeout, retrying...');
          return this.callAPIWithRetry(payload, attempt + 1);
        } else {
          throw new Error(`Timeout after ${this.config.retries} attempts`);
        }
      }

      if (attempt < this.config.retries) {
        console.warn('Request failed, retrying...');
        await this.sleep(2000);
        return this.callAPIWithRetry(payload, attempt + 1);
      }

      throw error;
    }
  }

  /**
   * Parse JSON from API response (handles markdown code blocks)
   */
  private parseResponse(content: string): any {
    let jsonContent = content.trim();

    // Extract JSON from markdown code blocks
    if (jsonContent.includes('```json')) {
      const match = jsonContent.match(/```json\s*([\s\S]*?)\s*```/);
      if (match) {
        jsonContent = match[1];
      }
    } else if (jsonContent.includes('```')) {
      const match = jsonContent.match(/```\s*([\s\S]*?)\s*```/);
      if (match) {
        jsonContent = match[1];
      }
    }

    try {
      return JSON.parse(jsonContent);
    } catch (error) {
      console.error('Failed to parse JSON:', error);
      console.debug('Content preview:', jsonContent.substring(0, 500));
      return null;
    }
  }

  /**
   * Merge results from multiple pages (take first non-null value for each field)
   */
  private mergeExtractionResults(
    results: ExtractionResult[]
  ): ExtractionResult {
    if (results.length === 0) {
      throw new Error('No extraction results to merge');
    }

    const merged: ExtractionResult = JSON.parse(JSON.stringify(results[0]));

    for (const result of results.slice(1)) {
      // Merge nested objects (power, efficiency, etc.)
      for (const [key, value] of Object.entries(result)) {
        if (
          typeof value === 'object' &&
          value !== null &&
          !Array.isArray(value)
        ) {
          for (const [subKey, subValue] of Object.entries(value)) {
            if (
              (merged as any)[key][subKey] === null &&
              subValue !== null
            ) {
              (merged as any)[key][subKey] = subValue;
            }
          }
        } else if (Array.isArray(value)) {
          // Merge arrays (certifications) - remove duplicates
          const mergedArray = (merged as any)[key] || [];
          (merged as any)[key] = Array.from(new Set([...mergedArray, ...value]));
        } else if ((merged as any)[key] === null && value !== null) {
          // Use first non-null value
          (merged as any)[key] = value;
        }
      }
    }

    return merged;
  }

  /**
   * Check rate limit and sleep if necessary
   */
  private async checkRateLimit(): Promise<void> {
    const now = new Date();
    const oneMinuteAgo = new Date(now.getTime() - 60000);

    // Remove requests older than 1 minute
    this.state.requestTimes = this.state.requestTimes.filter(
      (time) => time > oneMinuteAgo
    );

    // Check if at limit
    if (this.state.requestTimes.length >= this.config.maxRequestsPerMinute) {
      const oldestRequest = this.state.requestTimes[0];
      const sleepTime = 60000 - (now.getTime() - oldestRequest.getTime());

      if (sleepTime > 0) {
        console.warn(
          `Rate limit reached, sleeping ${(sleepTime / 1000).toFixed(1)}s`
        );
        await this.sleep(sleepTime);
      }
    }
  }

  /**
   * Estimate API cost based on token usage
   */
  private estimateCost(imageCount: number): number {
    const inputCost =
      (DEEPSEEK_PRICING.AVG_INPUT_TOKENS_PER_IMAGE * imageCount / 1_000_000) *
      DEEPSEEK_PRICING.INPUT_PER_M_TOKENS;

    const outputCost =
      (DEEPSEEK_PRICING.AVG_OUTPUT_TOKENS_PER_IMAGE * imageCount / 1_000_000) *
      DEEPSEEK_PRICING.OUTPUT_PER_M_TOKENS;

    return inputCost + outputCost;
  }

  /**
   * Check cost limit and throw if exceeded
   */
  private checkCostLimit(estimatedCost: number): void {
    if (this.state.totalCost + estimatedCost > this.config.maxCostUsd) {
      throw new DeepSeekCostLimitError(
        `Cost limit reached: $${this.state.totalCost.toFixed(4)} + ` +
          `$${estimatedCost.toFixed(4)} > $${this.config.maxCostUsd.toFixed(2)} limit`,
        this.state.totalCost,
        estimatedCost,
        this.config.maxCostUsd
      );
    }
  }

  /**
   * Create extraction prompt for BESS datasheets
   */
  private createExtractionPrompt(): string {
    return `Extract technical specifications from this battery energy storage system (BESS) datasheet.

Extract the following information in JSON format:

{
  "model_name": "exact product model name",
  "manufacturer": "manufacturer name",
  "power": {
    "rated_power_kw": number or null,
    "max_power_kw": number or null,
    "continuous_power_kw": number or null
  },
  "efficiency": {
    "peak_percent": number or null,
    "rated_percent": number or null
  },
  "voltage": {
    "nominal_v": number or null,
    "max_v": number or null,
    "min_v": number or null
  },
  "physical": {
    "width_mm": number or null,
    "height_mm": number or null,
    "depth_mm": number or null,
    "weight_kg": number or null
  },
  "environmental": {
    "operating_temp_min_c": number or null,
    "operating_temp_max_c": number or null,
    "humidity_max_percent": number or null
  },
  "certifications": ["list of certifications"],
  "battery": {
    "capacity_kwh": number or null,
    "type": "battery chemistry type",
    "cycles": number or null
  }
}

Rules:
- Extract only values explicitly stated in the document
- Use null for missing values
- Extract numeric values without units
- For ranges, use the nominal/typical value
- Model name should be the exact product designation
- Return ONLY valid JSON, no additional text`;
  }

  /**
   * Sleep for specified milliseconds
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}
