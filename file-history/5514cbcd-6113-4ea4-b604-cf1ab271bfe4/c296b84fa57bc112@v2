# Git-based PDF Storage - Setup Guide

## √úbersicht

PDFs werden **direkt in Ihr GitHub Repository** committed, sodass:
- ‚úÖ Alle PDFs versioniert sind
- ‚úÖ PDFs automatisch zu Vercel deployed werden
- ‚úÖ Team-Mitglieder PDFs hinzuf√ºgen k√∂nnen
- ‚úÖ GitHub als Backup dient

## Verzeichnis-Struktur

```
public/data/
‚îú‚îÄ‚îÄ pdfs/              # ‚úÖ IN GIT COMMITTED
‚îÇ   ‚îî‚îÄ‚îÄ {manufacturer}/
‚îÇ       ‚îî‚îÄ‚îÄ {model}/
‚îÇ           ‚îú‚îÄ‚îÄ datasheet.pdf     # Committed to Git
‚îÇ           ‚îú‚îÄ‚îÄ extracted.json    # Committed to Git
‚îÇ           ‚îî‚îÄ‚îÄ metadata.json     # Committed to Git
‚îÇ
‚îî‚îÄ‚îÄ staging/           # ‚ùå NICHT COMMITTED (lokal/tempor√§r)
    ‚îî‚îÄ‚îÄ products/
        ‚îî‚îÄ‚îÄ {uuid}.json           # Nur lokal
```

## Setup-Schritte

### 1. .gitignore Anpassen

F√ºgen Sie zu `benchmark-app/.gitignore` hinzu:

```gitignore
# PDF Import System
# Keep PDFs in Git, exclude staging data
public/data/staging/          # Tempor√§re ungepr√ºfte Daten
!public/data/pdfs/            # PDFs SOLLEN committed werden
```

### 2. Git LFS Installieren (Optional, aber empfohlen)

Git LFS (Large File Storage) ist ideal f√ºr PDFs:

```bash
# Installation
# macOS
brew install git-lfs

# Windows
# Download von: https://git-lfs.github.com/

# Linux
sudo apt-get install git-lfs

# Git LFS initialisieren
git lfs install

# PDFs f√ºr LFS tracken
git lfs track "*.pdf"

# .gitattributes committen
git add .gitattributes
git commit -m "chore: Configure Git LFS for PDF files"
```

**Vorteile von Git LFS**:
- Kleinere Repository-Gr√∂√üe
- Schnellere Clone-Zeiten
- Bessere Performance f√ºr gro√üe Dateien

### 3. Vorhandene PDFs Committen

Falls Sie bereits PDFs haben:

```bash
cd benchmark-app

# Alle PDFs zum Staging hinzuf√ºgen
git add public/data/pdfs/

# Committen
git commit -m "feat: Add existing PDF datasheets

ü§ñ Generated with Claude Code"

# Zu GitHub pushen
git push origin main
```

## Verwendung

### Option 1: Automatisches Commit (Empfohlen)

PDFs werden automatisch committed nach dem Upload:

```typescript
import { savePDFToGit } from '@/lib/pdf/git-storage';

// PDF speichern und automatisch committen
await savePDFToGit(
  'BYD',
  'Cube Pro C230',
  pdfBuffer,
  {
    originalFilename: 'datasheet.pdf',
    fileSize: pdfBuffer.byteLength,
    pages: 4,
    source: 'manual_upload',
  },
  {
    autoCommit: true,       // ‚úÖ Automatisch committen
    autoPush: false,        // ‚ùå Manuell pushen (sicherer)
    useGitLFS: true,        // ‚úÖ Git LFS verwenden
  }
);
```

### Option 2: Batch-Commit

Mehrere PDFs auf einmal committen:

```typescript
import { commitMultiplePDFs } from '@/lib/pdf/git-storage';

// Nach Import von vielen PDFs
await commitMultiplePDFs(
  'feat: Add 50 PDF datasheets from ZEREZ import\n\nü§ñ Generated with Claude Code',
  false // autoPush = false
);
```

### Option 3: Manuelles Git

Klassische Git-Befehle verwenden:

```bash
# Status pr√ºfen
git status public/data/pdfs/

# Alle PDFs hinzuf√ºgen
git add public/data/pdfs/

# Committen
git commit -m "feat: Add new datasheets"

# Pushen
git push origin main
```

## API Integration

### API Route mit automatischem Commit

```typescript
// app/api/pdf/upload/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { savePDFToGit } from '@/lib/pdf/git-storage';

export async function POST(request: NextRequest) {
  try {
    const formData = await request.formData();
    const file = formData.get('pdf') as File;
    const manufacturer = formData.get('manufacturer') as string;
    const model = formData.get('model') as string;

    const buffer = Buffer.from(await file.arrayBuffer());

    // PDF speichern und zu Git committen
    const location = await savePDFToGit(
      manufacturer,
      model,
      buffer,
      {
        originalFilename: file.name,
        fileSize: file.size,
        pages: 0, // Wird sp√§ter gef√ºllt
        source: 'manual_upload',
      },
      {
        autoCommit: true,
        autoPush: false,
        useGitLFS: true,
      }
    );

    return NextResponse.json({
      success: true,
      location,
      message: 'PDF saved and committed to Git',
    });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to save PDF', message: error.message },
      { status: 500 }
    );
  }
}
```

## Commit-Strategie

### Einzelne PDFs (auto-commit)

```typescript
// Jedes PDF wird sofort committed
const options = {
  autoCommit: true,
  autoPush: false,  // Manuelle Kontrolle
  commitMessage: (manufacturer, model) =>
    `feat: Add ${manufacturer} ${model} datasheet\n\nü§ñ Generated with Claude Code`,
};
```

### Batch-Import (manueller commit)

```typescript
// 1. Alle PDFs herunterladen (ohne commit)
for (const product of products) {
  await savePDFToFilesystem(...);  // Kein Git
}

// 2. Alle auf einmal committen
await commitMultiplePDFs(
  `feat: Add ${products.length} datasheets from ZEREZ import\n\nü§ñ Generated with Claude Code`,
  false
);

// 3. Manuell pushen nach Pr√ºfung
// git push origin main
```

## GitHub Actions Integration (Optional)

Automatisches Deployment zu Vercel nach PDF-Commits:

```yaml
# .github/workflows/deploy-pdfs.yml
name: Deploy PDFs to Vercel

on:
  push:
    paths:
      - 'benchmark-app/public/data/pdfs/**'
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Deploy to Vercel
        run: vercel --prod
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
```

## Repository-Limits

### GitHub Limits
- **Einzeldatei**: Max 100 MB
- **Repository**: Empfohlen < 1 GB (soft limit)
- **Mit Git LFS**: Bis zu mehrere GB m√∂glich

### Empfehlungen
- ‚úÖ PDFs < 10 MB: Direkt in Git
- ‚úÖ PDFs 10-50 MB: Git LFS verwenden
- ‚ö†Ô∏è PDFs > 50 MB: Komprimieren oder separates Storage

### Beispiel-Kalkulation
- 1000 PDFs √ó 3 MB durchschnittlich = 3 GB
- Mit Git LFS: Kein Problem ‚úÖ
- Ohne Git LFS: Grenzwertig (Repository wird gro√ü)

## Monitoring

### Git Status pr√ºfen

```typescript
import { getPDFsGitStatus } from '@/lib/pdf/git-storage';

const status = await getPDFsGitStatus();
console.log('Staged:', status.staged.length);
console.log('Modified:', status.modified.length);
console.log('Untracked:', status.untracked.length);
```

### Dashboard-Integration

Zeigen Sie den Status in der UI:

```typescript
// app/admin/pdfs/page.tsx
export default async function PDFAdminPage() {
  const status = await getPDFsGitStatus();

  return (
    <div>
      <h2>PDF Git Status</h2>
      <p>Uncommitted PDFs: {status.untracked.length}</p>
      <button onClick={() => commitMultiplePDFs(...)}>
        Commit All PDFs
      </button>
    </div>
  );
}
```

## Sicherheits-√úberlegungen

### ‚úÖ Vorteile
- Versionskontrolle (alle √Ñnderungen nachverfolgbar)
- Backup (GitHub ist Ihr Backup)
- Team-Collaboration (PRs f√ºr neue PDFs)
- Audit-Trail (wer, was, wann)

### ‚ö†Ô∏è Beachten
- PDFs sind √∂ffentlich sichtbar (√∂ffentliches Repo)
- Gro√üe Bin√§rdateien machen Repository langsam
- Git LFS empfohlen f√ºr viele/gro√üe PDFs

### üîí Private PDFs
Falls PDFs vertraulich sind:

1. **Private Repository** verwenden
2. **Oder**: PDFs in separatem private Repo
3. **Oder**: GitHub Releases (privat) verwenden
4. **Oder**: Externe Storage (S3) mit Access Control

## Troubleshooting

### Problem: "Git not available"

```bash
# Git installieren
# macOS
brew install git

# Windows
# Download von: https://git-scm.com/

# Linux
sudo apt-get install git
```

### Problem: "File too large"

```bash
# Git LFS verwenden
git lfs track "*.pdf"
git add .gitattributes
git commit -m "chore: Enable Git LFS"

# Gro√üe Datei erneut hinzuf√ºgen
git add public/data/pdfs/
git commit -m "feat: Add large PDF with LFS"
```

### Problem: "Push failed"

```bash
# Repository-Gr√∂√üe pr√ºfen
git count-objects -vH

# Gro√üe Dateien finden
git rev-list --objects --all | \
  git cat-file --batch-check='%(objectsize) %(objectname) %(rest)' | \
  sort -nr | head -20

# Ggf. Git LFS nachtr√§glich aktivieren
git lfs migrate import --include="*.pdf"
```

## Best Practices

### ‚úÖ DO
- Git LFS f√ºr PDFs verwenden
- Aussagekr√§ftige Commit-Messages
- Batch-Commits f√ºr viele PDFs
- Regelm√§√üig pushen
- `.gitignore` f√ºr `staging/` verwenden

### ‚ùå DON'T
- Sehr gro√üe PDFs (> 100 MB) ohne LFS
- Auto-push ohne Pr√ºfung
- Staging-Daten committen
- PDFs ohne Metadaten

## Vergleich: Git vs. Externes Storage

### Git Storage (Ihre Wahl) ‚úÖ
```
Vorteile:
+ Versionskontrolle
+ Einfaches Deployment
+ Kein externes Service
+ Team-Collaboration via PRs
+ Kostenlos (GitHub Free)

Nachteile:
- Repository-Gr√∂√üe w√§chst
- Langsamer bei vielen gro√üen Dateien
- 100 MB Limit pro Datei
```

### Externes Storage (S3, Cloudflare R2)
```
Vorteile:
+ Unbegrenzte Gr√∂√üe
+ Schneller f√ºr sehr viele Dateien
+ CDN-Integration
+ Granulare Access Control

Nachteile:
- Zus√§tzliches Service
- Monatliche Kosten
- Komplexere Setup
- Keine Versionskontrolle
```

## Fazit

**Empfehlung f√ºr Ihr Projekt**:

‚úÖ **Git + Git LFS** f√ºr PDFs verwenden

**Warum?**
1. Einfache Integration (bereits in Git)
2. Kostenlos mit GitHub
3. Automatisches Vercel Deployment
4. Perfekt f√ºr 1000-5000 PDFs
5. Versionskontrolle inklusive

**Setup-Zeit**: ~10 Minuten
**Kosten**: $0 (GitHub Free + Git LFS Free Tier)
**Maintenance**: Minimal

Sie haben die richtige Entscheidung getroffen! üöÄ
