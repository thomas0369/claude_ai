/**
 * Git-based PDF Storage Manager
 * ==============================
 *
 * Automatically commits PDFs to GitHub repository
 *
 * Features:
 * - Save PDFs to repository
 * - Automatic git commit
 * - Optional git push
 * - Git LFS support (optional)
 */

import { promises as fs } from 'fs';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import {
  getStorageLocation,
  savePDF as savePDFToFilesystem,
  PDFStorageMetadata,
  PDFStorageLocation,
} from './storage';

const execAsync = promisify(exec);

export interface GitStorageOptions {
  /** Automatically commit after saving PDF */
  autoCommit?: boolean;
  /** Automatically push after commit */
  autoPush?: boolean;
  /** Branch to commit to (default: current branch) */
  branch?: string;
  /** Commit message template */
  commitMessage?: (manufacturer: string, model: string) => string;
  /** Enable Git LFS for PDFs (recommended for large files) */
  useGitLFS?: boolean;
}

const DEFAULT_OPTIONS: Required<GitStorageOptions> = {
  autoCommit: true,
  autoPush: false, // Manual push by default for safety
  branch: 'main',
  commitMessage: (manufacturer, model) =>
    `feat: Add PDF datasheet for ${manufacturer} ${model}\n\nü§ñ Generated with Claude Code\nhttps://claude.com/claude-code`,
  useGitLFS: false,
};

/**
 * Check if Git is available
 */
async function isGitAvailable(): Promise<boolean> {
  try {
    await execAsync('git --version');
    return true;
  } catch {
    return false;
  }
}

/**
 * Check if we're in a Git repository
 */
async function isGitRepository(): Promise<boolean> {
  try {
    await execAsync('git rev-parse --git-dir', {
      cwd: process.cwd(),
    });
    return true;
  } catch {
    return false;
  }
}

/**
 * Check if Git LFS is installed and initialized
 */
async function isGitLFSAvailable(): Promise<boolean> {
  try {
    await execAsync('git lfs version');
    return true;
  } catch {
    return false;
  }
}

/**
 * Get current Git branch
 */
async function getCurrentBranch(): Promise<string> {
  try {
    const { stdout } = await execAsync('git branch --show-current', {
      cwd: process.cwd(),
    });
    return stdout.trim();
  } catch {
    return 'main';
  }
}

/**
 * Initialize Git LFS for PDFs (if not already initialized)
 */
async function initializeGitLFS(): Promise<void> {
  const lfsAvailable = await isGitLFSAvailable();
  if (!lfsAvailable) {
    throw new Error(
      'Git LFS not installed. Install it from: https://git-lfs.github.com/'
    );
  }

  try {
    // Check if .gitattributes already tracks PDFs
    const gitattributesPath = path.join(process.cwd(), '.gitattributes');
    let content = '';
    try {
      content = await fs.readFile(gitattributesPath, 'utf-8');
    } catch {
      // File doesn't exist yet
    }

    if (!content.includes('*.pdf filter=lfs')) {
      // Add PDF tracking to .gitattributes
      const newLine = '*.pdf filter=lfs diff=lfs merge=lfs -text\n';
      await fs.appendFile(gitattributesPath, newLine);
      console.log('‚úÖ Git LFS configured for PDF files');

      // Commit .gitattributes
      await execAsync('git add .gitattributes', { cwd: process.cwd() });
      await execAsync(
        'git commit -m "chore: Configure Git LFS for PDF files"',
        { cwd: process.cwd() }
      );
    }
  } catch (error) {
    console.warn('Could not initialize Git LFS:', error);
  }
}

/**
 * Commit PDF files to Git
 */
async function commitPDF(
  location: PDFStorageLocation,
  manufacturer: string,
  model: string,
  commitMessage: string
): Promise<void> {
  const repoRoot = process.cwd();

  try {
    // Stage PDF and metadata files
    const relativeDir = path.relative(repoRoot, location.directory);
    await execAsync(`git add "${relativeDir}/"`, { cwd: repoRoot });

    // Check if there are changes to commit
    const { stdout: status } = await execAsync('git status --porcelain', {
      cwd: repoRoot,
    });

    if (!status.trim()) {
      console.log('‚ÑπÔ∏è No changes to commit (PDF already in repository)');
      return;
    }

    // Commit
    await execAsync(`git commit -m "${commitMessage.replace(/"/g, '\\"')}"`, {
      cwd: repoRoot,
    });

    console.log(`‚úÖ PDF committed to Git: ${manufacturer} ${model}`);
  } catch (error) {
    console.error('‚ùå Failed to commit PDF to Git:', error);
    throw new Error(
      `Git commit failed: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }
}

/**
 * Push commits to remote
 */
async function pushToRemote(branch: string): Promise<void> {
  try {
    // Check if remote exists
    const { stdout: remotes } = await execAsync('git remote', {
      cwd: process.cwd(),
    });

    if (!remotes.trim()) {
      console.warn('‚ö†Ô∏è No Git remote configured, skipping push');
      return;
    }

    // Push to remote
    await execAsync(`git push origin "${branch}"`, {
      cwd: process.cwd(),
      timeout: 120000, // 2 minute timeout
    });

    console.log(`‚úÖ PDF pushed to remote (branch: ${branch})`);
  } catch (error) {
    console.error('‚ùå Failed to push to remote:', error);
    throw new Error(
      `Git push failed: ${error instanceof Error ? error.message : 'Unknown error'}`
    );
  }
}

/**
 * Save PDF to Git repository with automatic commit
 */
export async function savePDFToGit(
  manufacturer: string,
  model: string,
  pdfBuffer: Buffer,
  metadata: Omit<PDFStorageMetadata, 'sha256' | 'uploadedAt'>,
  options: GitStorageOptions = {}
): Promise<PDFStorageLocation> {
  // Merge with defaults
  const opts = { ...DEFAULT_OPTIONS, ...options };

  // Validate Git is available
  const gitAvailable = await isGitAvailable();
  if (!gitAvailable) {
    throw new Error(
      'Git is not available. Please install Git to use Git storage.'
    );
  }

  const isRepo = await isGitRepository();
  if (!isRepo) {
    throw new Error(
      'Not a Git repository. Please initialize Git first: git init'
    );
  }

  // Initialize Git LFS if requested
  if (opts.useGitLFS) {
    await initializeGitLFS();
  }

  // Save PDF to filesystem (same as before)
  const location = await savePDFToFilesystem(
    manufacturer,
    model,
    pdfBuffer,
    metadata
  );

  // Auto-commit if enabled
  if (opts.autoCommit) {
    const commitMsg = opts.commitMessage(manufacturer, model);
    await commitPDF(location, manufacturer, model, commitMsg);

    // Auto-push if enabled
    if (opts.autoPush) {
      const branch = opts.branch || (await getCurrentBranch());
      await pushToRemote(branch);
    }
  }

  return location;
}

/**
 * Batch commit multiple PDFs
 */
export async function commitMultiplePDFs(
  message: string,
  autoPush: boolean = false
): Promise<void> {
  const repoRoot = process.cwd();
  const pdfsDir = path.join(repoRoot, 'public', 'data', 'pdfs');

  try {
    // Stage all PDF files
    await execAsync(`git add "${pdfsDir}/"`, { cwd: repoRoot });

    // Check if there are changes
    const { stdout: status } = await execAsync('git status --porcelain', {
      cwd: repoRoot,
    });

    if (!status.trim()) {
      console.log('‚ÑπÔ∏è No changes to commit');
      return;
    }

    // Commit
    await execAsync(`git commit -m "${message.replace(/"/g, '\\"')}"`, {
      cwd: repoRoot,
    });

    console.log(`‚úÖ Committed ${status.split('\n').length} changes`);

    // Push if requested
    if (autoPush) {
      const branch = await getCurrentBranch();
      await pushToRemote(branch);
    }
  } catch (error) {
    console.error('‚ùå Failed to commit PDFs:', error);
    throw error;
  }
}

/**
 * Get Git status for PDFs directory
 */
export async function getPDFsGitStatus(): Promise<{
  staged: string[];
  modified: string[];
  untracked: string[];
}> {
  const repoRoot = process.cwd();
  const pdfsDir = path.join(repoRoot, 'public', 'data', 'pdfs');

  try {
    const { stdout } = await execAsync('git status --porcelain', {
      cwd: repoRoot,
    });

    const staged: string[] = [];
    const modified: string[] = [];
    const untracked: string[] = [];

    for (const line of stdout.split('\n')) {
      if (!line.trim()) continue;

      const status = line.substring(0, 2);
      const file = line.substring(3);

      // Only include files in pdfs directory
      if (!file.includes('pdfs/')) continue;

      if (status.startsWith('A') || status.startsWith('M')) {
        staged.push(file);
      } else if (status.includes('M')) {
        modified.push(file);
      } else if (status.startsWith('??')) {
        untracked.push(file);
      }
    }

    return { staged, modified, untracked };
  } catch {
    return { staged: [], modified: [], untracked: [] };
  }
}

/**
 * Check if PDF is tracked by Git
 */
export async function isPDFInGit(
  manufacturer: string,
  model: string
): Promise<boolean> {
  const location = getStorageLocation(manufacturer, model);
  const repoRoot = process.cwd();
  const relativePath = path.relative(repoRoot, location.pdfPath);

  try {
    await execAsync(`git ls-files --error-unmatch "${relativePath}"`, {
      cwd: repoRoot,
    });
    return true;
  } catch {
    return false;
  }
}
