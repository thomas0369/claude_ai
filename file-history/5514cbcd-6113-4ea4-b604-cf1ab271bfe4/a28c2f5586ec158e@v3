#!/usr/bin/env python3
"""
DeepSeek Vision API Client
============================

Uses DeepSeek-VL2 model for intelligent PDF datasheet extraction.
Supports table understanding, OCR, and structured data extraction.

Usage:
    client = DeepSeekVisionClient(api_key="your-api-key")
    result = client.extract_datasheet(image_path)
"""

import os
import json
import base64
import logging
import time
from pathlib import Path
from typing import Dict, List, Optional, Union
from collections import deque
from datetime import datetime, timedelta
import requests

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)


class DeepSeekVisionClient:
    """Client for DeepSeek Vision API with rate limiting and cost controls."""

    def __init__(
        self,
        api_key: Optional[str] = None,
        base_url: str = "https://api.deepseek.com/v1",
        max_requests_per_minute: int = 60,
        max_cost_usd: float = 1.0,
        timeout: int = 60,
        retries: int = 3
    ):
        """
        Initialize DeepSeek Vision client with safety controls.

        Args:
            api_key: DeepSeek API key (defaults to DEEPSEEK_API_KEY env var)
            base_url: API base URL
            max_requests_per_minute: Rate limit (default: 60)
            max_cost_usd: Maximum spend limit (default: $1.00)
            timeout: Request timeout in seconds (default: 60)
            retries: Number of retry attempts (default: 3)
        """
        self.api_key = api_key or os.getenv("DEEPSEEK_API_KEY")
        if not self.api_key:
            raise ValueError("API key required. Set DEEPSEEK_API_KEY environment variable or pass api_key parameter.")

        self.base_url = base_url.rstrip('/')
        self.headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }

        # Rate limiting
        self.max_requests_per_minute = max_requests_per_minute
        self.request_times = deque()

        # Cost controls
        self.max_cost_usd = max_cost_usd
        self.total_cost_usd = 0.0
        self.request_count = 0

        # Request configuration
        self.timeout = timeout
        self.retries = retries

    def _check_rate_limit(self):
        """Enforce rate limiting."""
        now = datetime.now()
        cutoff = now - timedelta(minutes=1)

        # Remove requests older than 1 minute
        while self.request_times and self.request_times[0] < cutoff:
            self.request_times.popleft()

        # Check if at limit
        if len(self.request_times) >= self.max_requests_per_minute:
            sleep_time = 60 - (now - self.request_times[0]).total_seconds()
            if sleep_time > 0:
                logger.warning(f"‚è±Ô∏è Rate limit reached, sleeping {sleep_time:.1f}s")
                time.sleep(sleep_time)

    def _estimate_cost(self, image_count: int = 1) -> float:
        """Estimate API cost. DeepSeek: $0.14/M input, $0.28/M output tokens."""
        # Average: ~2000 input + 500 output per image
        input_cost = (2000 * image_count / 1_000_000) * 0.14
        output_cost = (500 * image_count / 1_000_000) * 0.28
        return input_cost + output_cost

    def _check_cost_limit(self, estimated_cost: float):
        """Enforce cost limits."""
        if self.total_cost_usd + estimated_cost > self.max_cost_usd:
            raise RuntimeError(
                f"üí∞ Cost limit reached: ${self.total_cost_usd:.4f} + "
                f"${estimated_cost:.4f} > ${self.max_cost_usd:.2f} limit"
            )

    def _encode_image(self, image_path: Path) -> str:
        """Encode image to base64."""
        with open(image_path, 'rb') as f:
            return base64.b64encode(f.read()).decode('utf-8')

    def _create_extraction_prompt(self) -> str:
        """Create structured prompt for datasheet extraction."""
        return """Extract technical specifications from this battery energy storage system (BESS) datasheet.

Extract the following information in JSON format:

{
  "model_name": "exact product model name",
  "manufacturer": "manufacturer name",
  "power": {
    "rated_power_kw": number or null,
    "max_power_kw": number or null,
    "continuous_power_kw": number or null
  },
  "efficiency": {
    "peak_percent": number or null,
    "rated_percent": number or null
  },
  "voltage": {
    "nominal_v": number or null,
    "max_v": number or null,
    "min_v": number or null
  },
  "physical": {
    "width_mm": number or null,
    "height_mm": number or null,
    "depth_mm": number or null,
    "weight_kg": number or null
  },
  "environmental": {
    "operating_temp_min_c": number or null,
    "operating_temp_max_c": number or null,
    "humidity_max_percent": number or null
  },
  "certifications": ["list of certifications"],
  "battery": {
    "capacity_kwh": number or null,
    "type": "battery chemistry type",
    "cycles": number or null
  }
}

Rules:
- Extract only values explicitly stated in the document
- Use null for missing values
- Extract numeric values without units
- For ranges, use the nominal/typical value
- Model name should be the exact product designation
- Return ONLY valid JSON, no additional text"""

    def extract_from_image(self, image_path: Union[str, Path], temperature: float = 0.1) -> Optional[Dict]:
        """
        Extract structured data from datasheet image with safety controls.

        Args:
            image_path: Path to image file
            temperature: Model temperature (lower = more deterministic)

        Returns:
            Extracted structured data or None if failed
        """
        image_path = Path(image_path)

        if not image_path.exists():
            logger.error(f"‚ùå Image not found: {image_path}")
            return None

        # Check rate limit
        self._check_rate_limit()

        # Check cost limit
        estimated_cost = self._estimate_cost(1)
        try:
            self._check_cost_limit(estimated_cost)
        except RuntimeError as e:
            logger.error(str(e))
            return None

        # Encode image
        try:
            image_b64 = self._encode_image(image_path)
            logger.debug(f"üì∏ Encoded image: {len(image_b64)} bytes base64")
        except Exception as e:
            logger.error(f"‚ùå Failed to encode image: {e}")
            return None

        # Create request
        payload = {
            "model": "deepseek-vl2",
            "messages": [
                {
                    "role": "user",
                    "content": [
                        {
                            "type": "text",
                            "text": self._create_extraction_prompt()
                        },
                        {
                            "type": "image_url",
                            "image_url": {
                                "url": f"data:image/png;base64,{image_b64}"
                            }
                        }
                    ]
                }
            ],
            "temperature": temperature,
            "max_tokens": 2000
        }

        # Try with retries
        for attempt in range(self.retries):
            try:
                logger.debug(f"üîÑ Attempt {attempt + 1}/{self.retries}")
                start_time = time.time()

                # Record request time for rate limiting
                self.request_times.append(datetime.now())

                response = requests.post(
                    f"{self.base_url}/chat/completions",
                    headers=self.headers,
                    json=payload,
                    timeout=self.timeout
                )

                elapsed = time.time() - start_time
                logger.debug(f"‚è±Ô∏è API response in {elapsed:.2f}s")

                # Handle specific status codes
                if response.status_code == 401:
                    logger.error("‚ùå Authentication failed - invalid API key")
                    return None
                elif response.status_code == 429:
                    if attempt < self.retries - 1:
                        wait_time = (2 ** attempt) * 5
                        logger.warning(f"‚è≥ Rate limited, waiting {wait_time}s...")
                        time.sleep(wait_time)
                        continue
                    else:
                        logger.error("‚ùå Rate limit exceeded, no retries left")
                        return None
                elif response.status_code >= 500:
                    if attempt < self.retries - 1:
                        logger.warning(f"‚ö†Ô∏è Server error {response.status_code}, retrying...")
                        time.sleep(2)
                        continue
                    else:
                        logger.error(f"‚ùå Server error: {response.status_code}")
                        return None

                response.raise_for_status()

                result = response.json()

                # Validate response structure
                if 'choices' not in result or len(result['choices']) == 0:
                    logger.error(f"‚ùå Unexpected response structure: {list(result.keys())}")
                    return None

                content = result['choices'][0]['message']['content']
                logger.debug(f"üìù Response length: {len(content)} chars")

                # Parse JSON from response
                if '```json' in content:
                    content = content.split('```json')[1].split('```')[0]
                elif '```' in content:
                    content = content.split('```')[1].split('```')[0]

                try:
                    extracted_data = json.loads(content.strip())
                except json.JSONDecodeError as e:
                    logger.error(f"‚ùå Failed to parse JSON: {e}")
                    logger.debug(f"Content preview: {content[:500]}")
                    # Save problematic response
                    debug_file = image_path.parent / f"{image_path.stem}_failed_response.txt"
                    debug_file.write_text(content)
                    logger.info(f"üíæ Saved failed response to: {debug_file}")
                    return None

                # Update cost tracking
                self.total_cost_usd += estimated_cost
                self.request_count += 1

                logger.info(f"‚úÖ Extracted from {image_path.name}")
                logger.info(f"üí∞ Usage: {self.request_count} requests, ${self.total_cost_usd:.4f} total")

                return extracted_data

            except requests.Timeout:
                if attempt < self.retries - 1:
                    logger.warning(f"‚è±Ô∏è Timeout, retrying...")
                    continue
                else:
                    logger.error(f"‚ùå Timeout after {self.retries} attempts")
                    return None

            except requests.RequestException as e:
                if attempt < self.retries - 1:
                    logger.warning(f"‚ö†Ô∏è Request failed: {e}, retrying...")
                    time.sleep(2)
                    continue
                else:
                    logger.error(f"‚ùå API request failed: {e}")
                    return None

            except Exception as e:
                logger.exception(f"‚ùå Unexpected error: {e}")
                return None

        return None

    def extract_from_pdf_images(self, image_paths: List[Path], aggregate: bool = True) -> Optional[Union[Dict, List[Dict]]]:
        """
        Extract data from multiple PDF page images.

        Args:
            image_paths: List of image paths (PDF pages)
            aggregate: If True, merge results from all pages

        Returns:
            Aggregated dict, list of dicts, or None if no results
        """
        results = []

        for image_path in image_paths:
            result = self.extract_from_image(image_path)
            if result:
                results.append(result)

        if not results:
            return None

        if aggregate and len(results) > 1:
            # Merge results - take first non-null value for each field
            merged = results[0].copy()

            for result in results[1:]:
                for key, value in result.items():
                    if isinstance(value, dict):
                        for sub_key, sub_value in value.items():
                            if merged[key].get(sub_key) is None and sub_value is not None:
                                merged[key][sub_key] = sub_value
                    elif isinstance(value, list):
                        # Merge lists, remove duplicates
                        merged[key] = list(set(merged.get(key, []) + value))
                    elif merged.get(key) is None and value is not None:
                        merged[key] = value

            return merged

        return results[0] if len(results) == 1 else results


def main():
    """Test the DeepSeek Vision client."""
    import sys

    if len(sys.argv) < 2:
        print("Usage: python deepseek_vision_client.py <image_path>")
        sys.exit(1)

    image_path = Path(sys.argv[1])

    client = DeepSeekVisionClient()
    result = client.extract_from_image(image_path)

    if result:
        print(json.dumps(result, indent=2))
    else:
        print("Extraction failed")
        sys.exit(1)


if __name__ == "__main__":
    main()
