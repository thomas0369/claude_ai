"""EMA Crossover Trend Following Strategy"""

from typing import Dict, Tuple
import pandas as pd
import numpy as np
from .base_strategy import BaseStrategy, SignalDirection


class EMACrossStrategy(BaseStrategy):
    """
    EMA Crossover Strategy - Fast EMA crosses slow EMA

    Entry Conditions:
    - LONG: Fast EMA (21) crosses above Slow EMA (55) + ADX > 20
    - SHORT: Fast EMA (21) crosses below Slow EMA (55) + ADX > 20

    Scoring (100 points max):
    - Cross Strength: 30 points (angle + momentum)
    - ADX Trend Strength: 25 points
    - EMA Alignment (3,8,13,21,55): 20 points
    - Price vs EMAs: 15 points
    - Volume: 10 points
    """

    def __init__(self):
        super().__init__(
            name="EMA Cross",
            max_score=100,
            min_score=55  # 55% confidence minimum
        )

    def calculate_score(self, indicators: Dict, ohlcv: pd.DataFrame) -> Tuple[float, Dict]:
        """Calculate EMA cross strategy score"""
        score = 0
        breakdown = {}

        # Extract indicators
        ema_dict = indicators.get('ema', {})
        adx_values = indicators.get('adx', {}).get('adx', [])
        close_prices = ohlcv['close'].values
        volumes = ohlcv['volume'].values if 'volume' in ohlcv.columns else None

        # Required EMAs
        required_emas = ['ema_21', 'ema_55']
        if not all(ema in ema_dict for ema in required_emas):
            return 0, breakdown

        ema_21 = ema_dict['ema_21']
        ema_55 = ema_dict['ema_55']

        if len(ema_21) < 3 or len(ema_55) < 3:
            return 0, breakdown

        # 1. Cross Strength (30 points)
        # Check for recent cross
        current_diff = ema_21[-1] - ema_55[-1]
        prev_diff = ema_21[-2] - ema_55[-2]
        prev2_diff = ema_21[-3] - ema_55[-3]

        cross_score = 0
        # Fresh cross (within last 2 bars)
        if (current_diff > 0 and prev_diff <= 0) or (current_diff < 0 and prev2_diff >= 0):
            cross_score = 30  # Very recent cross
        elif (current_diff > 0 and prev2_diff <= 0) or (current_diff < 0 and prev2_diff >= 0):
            cross_score = 20  # Recent cross (2 bars ago)
        elif abs(current_diff) < abs(ema_55[-1]) * 0.001:
            # Very close to cross
            cross_score = 15
        elif abs(current_diff) / abs(ema_55[-1]) < 0.005:
            # Somewhat close
            cross_score = 8

        # Angle/momentum bonus
        if cross_score > 0:
            ema_21_momentum = (ema_21[-1] - ema_21[-5]) / ema_21[-5] if len(ema_21) >= 5 else 0
            if abs(ema_21_momentum) > 0.01:  # Strong momentum
                cross_score = min(30, cross_score + 5)

        score += cross_score
        breakdown['cross_strength'] = cross_score

        # 2. ADX Trend Strength (25 points)
        if len(adx_values) > 0:
            current_adx = adx_values[-1]
            if current_adx >= 40:
                adx_score = 25
            elif current_adx >= 30:
                adx_score = 20
            elif current_adx >= 25:
                adx_score = 15
            elif current_adx >= 20:
                adx_score = 10
            else:
                adx_score = 0
            score += adx_score
            breakdown['adx'] = adx_score
        else:
            breakdown['adx'] = 0

        # 3. EMA Alignment (20 points)
        alignment_emas = ['ema_8', 'ema_13', 'ema_21', 'ema_55', 'ema_89']
        if all(ema in ema_dict for ema in alignment_emas):
            ema_values = [ema_dict[ema][-1] for ema in alignment_emas]

            # Check for proper alignment
            bullish_aligned = all(ema_values[i] < ema_values[i+1] for i in range(len(ema_values)-1))
            bearish_aligned = all(ema_values[i] > ema_values[i+1] for i in range(len(ema_values)-1))

            if bullish_aligned or bearish_aligned:
                score += 20
                breakdown['alignment'] = 20
            else:
                # Partial alignment
                alignment_count = sum(
                    1 for i in range(len(ema_values)-1)
                    if (ema_values[i] < ema_values[i+1]) == (ema_values[0] < ema_values[1])
                )
                partial_score = int((alignment_count / (len(ema_values)-1)) * 20)
                score += partial_score
                breakdown['alignment'] = partial_score
        else:
            breakdown['alignment'] = 0

        # 4. Price vs EMAs (15 points)
        current_price = close_prices[-1]
        if 'ema_21' in ema_dict and 'ema_55' in ema_dict:
            ema21_val = ema_dict['ema_21'][-1]
            ema55_val = ema_dict['ema_55'][-1]

            # Price above both EMAs (bullish) or below both (bearish)
            if (current_price > ema21_val and current_price > ema55_val) or \
               (current_price < ema21_val and current_price < ema55_val):
                score += 15
                breakdown['price_position'] = 15
            elif (current_price > ema21_val) or (current_price < ema21_val):
                score += 8
                breakdown['price_position'] = 8
            else:
                breakdown['price_position'] = 0
        else:
            breakdown['price_position'] = 0

        # 5. Volume (10 points)
        if volumes is not None and len(volumes) >= 20:
            avg_volume = volumes[-20:].mean()
            current_volume = volumes[-1]
            if current_volume > avg_volume * 1.5:
                score += 10
                breakdown['volume'] = 10
            elif current_volume > avg_volume:
                score += 5
                breakdown['volume'] = 5
            else:
                breakdown['volume'] = 0
        else:
            breakdown['volume'] = 0

        return score, breakdown

    def determine_direction(self, indicators: Dict, ohlcv: pd.DataFrame, score: float) -> SignalDirection:
        """Determine trade direction based on EMA cross"""
        ema_dict = indicators.get('ema', {})
        adx_values = indicators.get('adx', {}).get('adx', [])

        if 'ema_21' not in ema_dict or 'ema_55' not in ema_dict:
            return SignalDirection.NEUTRAL

        ema_21 = ema_dict['ema_21']
        ema_55 = ema_dict['ema_55']

        if len(ema_21) < 2 or len(ema_55) < 2:
            return SignalDirection.NEUTRAL

        # ADX filter
        if len(adx_values) > 0 and adx_values[-1] < 20:
            return SignalDirection.NEUTRAL

        # Current position
        current_diff = ema_21[-1] - ema_55[-1]
        prev_diff = ema_21[-2] - ema_55[-2]

        # LONG: Fast EMA above Slow EMA (or just crossed above)
        if current_diff > 0 and (prev_diff <= 0 or current_diff > 0):
            return SignalDirection.LONG

        # SHORT: Fast EMA below Slow EMA (or just crossed below)
        elif current_diff < 0 and (prev_diff >= 0 or current_diff < 0):
            return SignalDirection.SHORT

        return SignalDirection.NEUTRAL
