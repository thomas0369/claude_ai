"""Additional Trading Strategies - Bollinger, Stochastic, ADX, SR, VWAP, Fib, Squeeze"""

from typing import Dict, Tuple
import pandas as pd
import numpy as np
from .base_strategy import BaseStrategy, SignalDirection


class BollingerBounceStrategy(BaseStrategy):
    """Bollinger Band Bounce Mean Reversion Strategy"""

    def __init__(self):
        super().__init__(name="Bollinger Bounce", max_score=100, min_score=60)

    def calculate_score(self, indicators: Dict, ohlcv: pd.DataFrame) -> Tuple[float, Dict]:
        score, breakdown = 0, {}
        bb_dict = indicators.get('bollinger_bands', {})
        close_prices = ohlcv['close'].values

        if not all(k in bb_dict for k in ['upper', 'lower', 'middle']):
            return 0, breakdown

        upper, lower, middle = bb_dict['upper'][-1], bb_dict['lower'][-1], bb_dict['middle'][-1]
        current_price = close_prices[-1]
        bb_width = upper - lower

        # Touch/penetration of bands (40 pts)
        dist_to_lower = (current_price - lower) / bb_width
        dist_to_upper = (upper - current_price) / bb_width

        if dist_to_lower < 0.1:
            score += 40
            breakdown['band_touch'] = 40
        elif dist_to_upper < 0.1:
            score += 40
            breakdown['band_touch'] = 40
        elif dist_to_lower < 0.2 or dist_to_upper < 0.2:
            score += 20
            breakdown['band_touch'] = 20
        else:
            breakdown['band_touch'] = 0

        # RSI confirmation (30 pts)
        if 'rsi' in indicators:
            rsi = indicators['rsi']['rsi'][-1]
            if (dist_to_lower < 0.15 and rsi < 35) or (dist_to_upper < 0.15 and rsi > 65):
                score += 30
                breakdown['rsi_confirm'] = 30
            else:
                breakdown['rsi_confirm'] = 0
        else:
            breakdown['rsi_confirm'] = 0

        # Bollinger squeeze (15 pts)
        if len(bb_dict['upper']) >= 20:
            avg_width = np.mean([bb_dict['upper'][i] - bb_dict['lower'][i] for i in range(-20, -1)])
            if bb_width < avg_width * 0.7:
                score += 15
                breakdown['squeeze'] = 15
            else:
                breakdown['squeeze'] = 0
        else:
            breakdown['squeeze'] = 0

        # Mean reversion setup (15 pts)
        if abs(current_price - middle) > bb_width * 0.3:
            score += 15
            breakdown['mean_reversion'] = 15
        else:
            breakdown['mean_reversion'] = 0

        return score, breakdown

    def determine_direction(self, indicators: Dict, ohlcv: pd.DataFrame, score: float) -> SignalDirection:
        bb_dict = indicators.get('bollinger_bands', {})
        if not all(k in bb_dict for k in ['upper', 'lower']):
            return SignalDirection.NEUTRAL

        current_price = ohlcv['close'].values[-1]
        upper, lower = bb_dict['upper'][-1], bb_dict['lower'][-1]
        bb_width = upper - lower

        if (current_price - lower) / bb_width < 0.15:
            return SignalDirection.LONG
        elif (upper - current_price) / bb_width < 0.15:
            return SignalDirection.SHORT
        return SignalDirection.NEUTRAL


class StochasticStrategy(BaseStrategy):
    """Stochastic Oscillator Oversold/Overbought Strategy"""

    def __init__(self):
        super().__init__(name="Stochastic", max_score=100, min_score=60)

    def calculate_score(self, indicators: Dict, ohlcv: pd.DataFrame) -> Tuple[float, Dict]:
        score, breakdown = 0, {}
        stoch_dict = indicators.get('stochastic', {})

        if 'k' not in stoch_dict or 'd' not in stoch_dict:
            return 0, breakdown

        k_values, d_values = stoch_dict['k'], stoch_dict['d']
        if len(k_values) < 3:
            return 0, breakdown

        k_current, d_current = k_values[-1], d_values[-1]

        # Oversold/Overbought (35 pts)
        if k_current < 20 or k_current > 80:
            score += 35
            breakdown['extreme'] = 35
        elif k_current < 30 or k_current > 70:
            score += 20
            breakdown['extreme'] = 20
        else:
            breakdown['extreme'] = 0

        # K/D Cross (30 pts)
        k_prev, d_prev = k_values[-2], d_values[-2]
        if (k_current > d_current and k_prev <= d_prev) or (k_current < d_current and k_prev >= d_prev):
            score += 30
            breakdown['cross'] = 30
        else:
            breakdown['cross'] = 0

        # Divergence (20 pts)
        close_prices = ohlcv['close'].values
        if len(k_values) >= 10 and len(close_prices) >= 10:
            price_change = close_prices[-1] - close_prices[-10]
            k_change = k_values[-1] - k_values[-10]
            if (price_change < 0 and k_change > 0) or (price_change > 0 and k_change < 0):
                score += 20
                breakdown['divergence'] = 20
            else:
                breakdown['divergence'] = 0
        else:
            breakdown['divergence'] = 0

        # Trend alignment (15 pts)
        if 'ema' in indicators and 'ema_55' in indicators['ema']:
            current_price = close_prices[-1]
            ema_55 = indicators['ema']['ema_55'][-1]
            if (current_price > ema_55 and k_current < 25) or (current_price < ema_55 and k_current > 75):
                score += 15
                breakdown['trend'] = 15
            else:
                breakdown['trend'] = 0
        else:
            breakdown['trend'] = 0

        return score, breakdown

    def determine_direction(self, indicators: Dict, ohlcv: pd.DataFrame, score: float) -> SignalDirection:
        stoch_dict = indicators.get('stochastic', {})
        if 'k' not in stoch_dict or 'd' not in stoch_dict:
            return SignalDirection.NEUTRAL

        k_values, d_values = stoch_dict['k'], stoch_dict['d']
        if len(k_values) < 2:
            return SignalDirection.NEUTRAL

        k_current, k_prev = k_values[-1], k_values[-2]
        d_current, d_prev = d_values[-1], d_values[-2]

        if k_current < 25 and k_current > k_prev and k_current > d_current:
            return SignalDirection.LONG
        elif k_current > 75 and k_current < k_prev and k_current < d_current:
            return SignalDirection.SHORT
        return SignalDirection.NEUTRAL


class ADXTrendStrategy(BaseStrategy):
    """ADX Trend Following Strategy"""

    def __init__(self):
        super().__init__(name="ADX Trend", max_score=100, min_score=65)

    def calculate_score(self, indicators: Dict, ohlcv: pd.DataFrame) -> Tuple[float, Dict]:
        score, breakdown = 0, {}
        adx_dict = indicators.get('adx', {})

        if 'adx' not in adx_dict:
            return 0, breakdown

        adx_values = adx_dict['adx']
        if len(adx_values) < 5:
            return 0, breakdown

        adx_current = adx_values[-1]

        # ADX strength (40 pts)
        if adx_current >= 40:
            score += 40
            breakdown['adx_strength'] = 40
        elif adx_current >= 30:
            score += 30
            breakdown['adx_strength'] = 30
        elif adx_current >= 25:
            score += 20
            breakdown['adx_strength'] = 20
        else:
            breakdown['adx_strength'] = 0

        # ADX rising (25 pts)
        adx_momentum = adx_values[-1] - adx_values[-5]
        if adx_momentum > 5:
            score += 25
            breakdown['adx_rising'] = 25
        elif adx_momentum > 2:
            score += 15
            breakdown['adx_rising'] = 15
        else:
            breakdown['adx_rising'] = 0

        # EMA alignment (20 pts)
        if 'ema' in indicators:
            ema_dict = indicators['ema']
            if all(f'ema_{p}' in ema_dict for p in [21, 55, 89]):
                ema_21, ema_55, ema_89 = ema_dict['ema_21'][-1], ema_dict['ema_55'][-1], ema_dict['ema_89'][-1]
                if (ema_21 > ema_55 > ema_89) or (ema_21 < ema_55 < ema_89):
                    score += 20
                    breakdown['ema_alignment'] = 20
                else:
                    breakdown['ema_alignment'] = 0
            else:
                breakdown['ema_alignment'] = 0
        else:
            breakdown['ema_alignment'] = 0

        # Price momentum (15 pts)
        close_prices = ohlcv['close'].values
        if len(close_prices) >= 10:
            price_momentum = (close_prices[-1] - close_prices[-10]) / close_prices[-10]
            if abs(price_momentum) > 0.02:
                score += 15
                breakdown['price_momentum'] = 15
            elif abs(price_momentum) > 0.01:
                score += 8
                breakdown['price_momentum'] = 8
            else:
                breakdown['price_momentum'] = 0
        else:
            breakdown['price_momentum'] = 0

        return score, breakdown

    def determine_direction(self, indicators: Dict, ohlcv: pd.DataFrame, score: float) -> SignalDirection:
        if 'ema' not in indicators or 'ema_55' not in indicators['ema']:
            return SignalDirection.NEUTRAL

        close_prices = ohlcv['close'].values
        ema_55 = indicators['ema']['ema_55'][-1]

        if close_prices[-1] > ema_55 and close_prices[-2] > ema_55:
            return SignalDirection.LONG
        elif close_prices[-1] < ema_55 and close_prices[-2] < ema_55:
            return SignalDirection.SHORT
        return SignalDirection.NEUTRAL


class VWAPMomentumStrategy(BaseStrategy):
    """VWAP Momentum Strategy"""

    def __init__(self):
        super().__init__(name="VWAP Momentum", max_score=100, min_score=60)

    def calculate_score(self, indicators: Dict, ohlcv: pd.DataFrame) -> Tuple[float, Dict]:
        score, breakdown = 0, {}

        # Calculate VWAP if not in indicators
        if 'vwap' not in indicators:
            if 'volume' not in ohlcv.columns:
                return 0, breakdown
            typical_price = (ohlcv['high'] + ohlcv['low'] + ohlcv['close']) / 3
            vwap = (typical_price * ohlcv['volume']).cumsum() / ohlcv['volume'].cumsum()
        else:
            vwap = indicators['vwap']

        if len(vwap) < 20:
            return 0, breakdown

        close_prices = ohlcv['close'].values
        vwap_current = vwap.iloc[-1] if isinstance(vwap, pd.Series) else vwap[-1]

        # Price vs VWAP (35 pts)
        price_vwap_diff = abs(close_prices[-1] - vwap_current) / vwap_current
        if price_vwap_diff < 0.002:
            score += 35
            breakdown['vwap_touch'] = 35
        elif price_vwap_diff < 0.005:
            score += 20
            breakdown['vwap_touch'] = 20
        else:
            breakdown['vwap_touch'] = 0

        # RSI momentum (25 pts)
        if 'rsi' in indicators:
            rsi = indicators['rsi']['rsi'][-1]
            if 45 < rsi < 70:
                score += 25
                breakdown['rsi'] = 25
            elif 30 < rsi < 55:
                score += 25
                breakdown['rsi'] = 25
            else:
                breakdown['rsi'] = 0
        else:
            breakdown['rsi'] = 0

        # Volume spike (20 pts)
        if 'volume' in ohlcv.columns:
            volumes = ohlcv['volume'].values
            if len(volumes) >= 20:
                avg_volume = volumes[-20:].mean()
                if volumes[-1] > avg_volume * 1.5:
                    score += 20
                    breakdown['volume'] = 20
                elif volumes[-1] > avg_volume:
                    score += 10
                    breakdown['volume'] = 10
                else:
                    breakdown['volume'] = 0
            else:
                breakdown['volume'] = 0
        else:
            breakdown['volume'] = 0

        # Trend alignment (20 pts)
        if 'ema' in indicators and 'ema_21' in indicators['ema']:
            ema_21 = indicators['ema']['ema_21'][-1]
            if (close_prices[-1] > vwap_current and close_prices[-1] > ema_21) or \
               (close_prices[-1] < vwap_current and close_prices[-1] < ema_21):
                score += 20
                breakdown['trend'] = 20
            else:
                breakdown['trend'] = 0
        else:
            breakdown['trend'] = 0

        return score, breakdown

    def determine_direction(self, indicators: Dict, ohlcv: pd.DataFrame, score: float) -> SignalDirection:
        if 'vwap' not in indicators:
            if 'volume' not in ohlcv.columns:
                return SignalDirection.NEUTRAL
            typical_price = (ohlcv['high'] + ohlcv['low'] + ohlcv['close']) / 3
            vwap = (typical_price * ohlcv['volume']).cumsum() / ohlcv['volume'].cumsum()
        else:
            vwap = indicators['vwap']

        close_prices = ohlcv['close'].values
        vwap_current = vwap.iloc[-1] if isinstance(vwap, pd.Series) else vwap[-1]
        vwap_prev = vwap.iloc[-2] if isinstance(vwap, pd.Series) else vwap[-2]

        # Bounce off VWAP
        if close_prices[-2] < vwap_prev and close_prices[-1] > vwap_current:
            return SignalDirection.LONG
        elif close_prices[-2] > vwap_prev and close_prices[-1] < vwap_current:
            return SignalDirection.SHORT
        return SignalDirection.NEUTRAL


# Registry of all strategies
STRATEGY_REGISTRY = [
    BollingerBounceStrategy,
    StochasticStrategy,
    ADXTrendStrategy,
    VWAPMomentumStrategy,
]
