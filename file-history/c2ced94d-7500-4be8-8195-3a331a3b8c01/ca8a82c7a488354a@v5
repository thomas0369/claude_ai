"""Multi-Strategy Screener - Scans all assets with multiple strategies"""

import sys
import os
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

from typing import List, Dict, Optional
import pandas as pd
import json
from datetime import datetime
import logging

# Import strategies
from strategies.base_strategy import BaseStrategy, Signal, SignalDirection
from strategies.rsi_extremes import RSIExtremesStrategy
from strategies.ema_cross import EMACrossStrategy
from strategies.macd_crossover import MACDCrossoverStrategy
from strategies.additional_strategies import (
    BollingerBounceStrategy,
    StochasticStrategy,
    ADXTrendStrategy,
    VWAPMomentumStrategy
)

# Import existing components
from indicators import (
    calculate_rsi, calculate_ema, calculate_adx, calculate_stochastic,
    calculate_bollinger_bands, calculate_macd, calculate_atr
)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class MultiStrategyScreener:
    """Screens multiple assets using multiple trading strategies"""

    # Default asset universe
    DEFAULT_ASSETS = [
        'EUR/USD', 'GBP/USD', 'USD/JPY', 'AUD/USD', 'USD/CHF',
        'XAU/USD', 'XAG/USD', 'USOIL', 'UKOIL',
        'US500', 'NAS100', 'GER40',
        'BTC/USD', 'ETH/USD'
    ]

    def __init__(
        self,
        assets: Optional[List[str]] = None,
        use_demo_data: bool = True,
        use_cache: bool = True
    ):
        """
        Initialize multi-strategy screener

        Args:
            assets: List of asset symbols to screen
            use_demo_data: If True, use demo data for testing
            use_cache: If True, use local data cache (recommended)
        """
        self.assets = assets or self.DEFAULT_ASSETS
        self.use_demo_data = use_demo_data
        self.use_cache = use_cache

        # Initialize cache manager if enabled
        self.cache_manager = None
        if use_cache and not use_demo_data:
            from data_cache_manager import DataCacheManager
            self.cache_manager = DataCacheManager()
            logger.info(f"‚úÖ Cache enabled - will use local data storage")

        # Initialize all strategies
        self.strategies: List[BaseStrategy] = [
            RSIExtremesStrategy(),
            EMACrossStrategy(),
            MACDCrossoverStrategy(),
            BollingerBounceStrategy(),
            StochasticStrategy(),
            ADXTrendStrategy(),
            VWAPMomentumStrategy(),
        ]

        logger.info(f"Initialized {len(self.strategies)} strategies for {len(self.assets)} assets")

    def fetch_data(self, symbol: str, timeframe: str = '1h', bars: int = 200) -> Optional[pd.DataFrame]:
        """
        Fetch OHLCV data for symbol (uses cache if available)

        Args:
            symbol: Asset symbol
            timeframe: Timeframe (1h, 45min, 30min, 4h, 1d)
            bars: Number of bars to fetch

        Returns:
            DataFrame with OHLCV data or None
        """
        if self.use_demo_data:
            # Generate demo data for testing
            return self._generate_demo_data(symbol, bars)

        # Try cache first (if enabled)
        if self.use_cache and self.cache_manager:
            cached_data = self.cache_manager.load_from_cache(symbol, timeframe, bars)
            if cached_data is not None and len(cached_data) >= min(50, bars):
                logger.debug(f"üì¶ Loaded {len(cached_data)} bars for {symbol} from cache")
                return cached_data
            else:
                logger.warning(f"‚ö†Ô∏è  Cache miss or insufficient data for {symbol}, falling back to API")

        # Fallback: fetch from actual data provider
        try:
            from capital_data_provider import CapitalDataProvider
            provider = CapitalDataProvider()
            return provider.fetch_ohlcv(symbol, timeframe, bars)
        except Exception as e:
            logger.warning(f"Could not fetch data for {symbol}: {e}")
            return None

    def _generate_demo_data(self, symbol: str, bars: int) -> pd.DataFrame:
        """Generate demo OHLCV data for testing"""
        import numpy as np

        # Generate realistic price data
        base_price = 1.2950 if 'USD' in symbol else 100.0
        dates = pd.date_range(end=datetime.now(), periods=bars, freq='1h')

        # Random walk with trend
        returns = np.random.normal(0.0001, 0.01, bars)
        prices = base_price * (1 + returns).cumprod()

        data = pd.DataFrame({
            'open': prices * (1 + np.random.uniform(-0.001, 0.001, bars)),
            'high': prices * (1 + np.random.uniform(0, 0.002, bars)),
            'low': prices * (1 - np.random.uniform(0, 0.002, bars)),
            'close': prices,
            'volume': np.random.uniform(10000, 50000, bars)
        }, index=dates)

        return data

    def calculate_indicators(self, ohlcv: pd.DataFrame) -> Dict:
        """Calculate all technical indicators"""
        indicators = {}

        try:
            # RSI - returns Series
            rsi_series = calculate_rsi(ohlcv, period=14)
            indicators['rsi'] = {'rsi': rsi_series.values.tolist() if hasattr(rsi_series, 'values') else rsi_series}

            # EMAs - each returns Series
            ema_periods = [3, 8, 13, 21, 55, 89, 144, 200]
            ema_dict = {}
            for period in ema_periods:
                ema_series = calculate_ema(ohlcv, period=period)
                ema_dict[f'ema_{period}'] = ema_series.values.tolist() if hasattr(ema_series, 'values') else ema_series
            indicators['ema'] = ema_dict

            # ADX - returns Series
            adx_series = calculate_adx(ohlcv, period=13)
            indicators['adx'] = {'adx': adx_series.values.tolist() if hasattr(adx_series, 'values') else adx_series}

            # Stochastic - returns tuple of (k, d)
            stoch_k, stoch_d = calculate_stochastic(ohlcv, k_period=13, d_period=5, smooth=8)
            indicators['stochastic'] = {
                'k': stoch_k.values.tolist() if hasattr(stoch_k, 'values') else stoch_k,
                'd': stoch_d.values.tolist() if hasattr(stoch_d, 'values') else stoch_d
            }

            # Bollinger Bands - returns tuple of (middle, upper, lower)
            bb_middle, bb_upper, bb_lower = calculate_bollinger_bands(ohlcv, period=21, std_dev=1.618)
            indicators['bollinger_bands'] = {
                'middle': bb_middle.values.tolist() if hasattr(bb_middle, 'values') else bb_middle,
                'upper': bb_upper.values.tolist() if hasattr(bb_upper, 'values') else bb_upper,
                'lower': bb_lower.values.tolist() if hasattr(bb_lower, 'values') else bb_lower
            }

            # MACD - returns tuple of (macd, signal, histogram)
            macd_line, signal_line, histogram = calculate_macd(ohlcv)
            indicators['macd'] = {
                'macd': macd_line.values.tolist() if hasattr(macd_line, 'values') else macd_line,
                'signal': signal_line.values.tolist() if hasattr(signal_line, 'values') else signal_line,
                'histogram': histogram.values.tolist() if hasattr(histogram, 'values') else histogram
            }

            # ATR - returns Series
            atr_series = calculate_atr(ohlcv, period=14)
            indicators['atr'] = {'atr': atr_series.values.tolist() if hasattr(atr_series, 'values') else atr_series}

        except Exception as e:
            logger.error(f"Error calculating indicators: {e}", exc_info=True)

        return indicators

    def screen_asset_with_strategy(
        self,
        symbol: str,
        strategy: BaseStrategy,
        ohlcv: pd.DataFrame
    ) -> Optional[Dict]:
        """
        Screen a single asset with a single strategy

        Returns:
            Dict with signal information or None
        """
        try:
            # Calculate indicators
            indicators = self.calculate_indicators(ohlcv)

            # Generate signal
            signal = strategy.generate_signal(indicators, ohlcv)

            if signal is None:
                return None

            # Return signal data (MARKET order - immediate execution)
            return {
                'symbol': symbol,
                'strategy': strategy.name,
                'direction': signal.direction.name,
                'order_type': signal.order_type,  # Always "MARKET"
                'score': round(signal.score, 2),
                'max_score': signal.max_score,
                'score_percentage': round(signal.score_percentage, 1),
                'confidence': round(signal.confidence, 1),
                'entry_price': round(signal.entry_price, 5),  # Current market price
                'stop_loss': round(signal.stop_loss, 5),
                'take_profit': round(signal.take_profit, 5),
                'risk_reward': round(signal.risk_reward_ratio, 2),
                'timestamp': signal.timestamp.isoformat(),
                'score_breakdown': signal.metadata.get('score_breakdown', {})
            }

        except Exception as e:
            logger.error(f"Error screening {symbol} with {strategy.name}: {e}")
            return None

    def screen_all(self) -> List[Dict]:
        """
        Screen all assets with all strategies

        Returns:
            List of all generated signals
        """
        all_signals = []

        logger.info(f"üîç Starting multi-strategy scan of {len(self.assets)} assets with {len(self.strategies)} strategies")

        for symbol in self.assets:
            logger.info(f"üìä Scanning {symbol}...")

            # Fetch data
            ohlcv = self.fetch_data(symbol)
            if ohlcv is None or len(ohlcv) < 50:
                logger.warning(f"‚ö†Ô∏è  Insufficient data for {symbol}")
                continue

            # Screen with each strategy
            for strategy in self.strategies:
                signal = self.screen_asset_with_strategy(symbol, strategy, ohlcv)
                if signal:
                    all_signals.append(signal)
                    logger.info(f"‚úÖ {symbol} | {strategy.name} | {signal['direction']} | Score: {signal['score']}/{signal['max_score']}")

        logger.info(f"\nüéØ Generated {len(all_signals)} signals from {len(self.assets)} assets")
        return all_signals

    def rank_signals(self, signals: List[Dict], top_n: int = 10) -> List[Dict]:
        """
        Rank signals by score percentage and return top N

        Args:
            signals: List of signal dicts
            top_n: Number of top signals to return

        Returns:
            Top N signals sorted by score percentage
        """
        # Sort by score percentage (descending)
        sorted_signals = sorted(signals, key=lambda x: x['score_percentage'], reverse=True)

        # Return top N
        return sorted_signals[:top_n]

    def save_signals(self, signals: List[Dict], filename: str = 'data/charts/data/index.json'):
        """Save signals to JSON file"""
        try:
            output_data = {
                'generated_at': datetime.now().isoformat(),
                'total_charts': len(signals),
                'charts': signals
            }

            # Ensure directory exists
            os.makedirs(os.path.dirname(filename), exist_ok=True)

            # Save to file
            with open(filename, 'w') as f:
                json.dump(output_data, f, indent=2)

            logger.info(f"üíæ Saved {len(signals)} signals to {filename}")

        except Exception as e:
            logger.error(f"Error saving signals: {e}")

    def generate_chart_data(self, signal: Dict, ohlcv: pd.DataFrame) -> Dict:
        """Generate detailed chart data for a signal"""
        indicators = self.calculate_indicators(ohlcv)

        # Extract last 50 bars for chart
        chart_data = ohlcv.tail(50)

        chart_dict = {
            'symbol': signal['symbol'],
            'timeframe': '1h',
            'signal': {
                'direction': signal['direction'].lower(),
                'entry_price': signal['entry_price'],
                'stop_loss': signal['stop_loss'],
                'take_profit': signal['take_profit'],
                'score': signal['score'],
                'confidence': signal['confidence']
            },
            'ohlcv': {
                'timestamps': chart_data.index.strftime('%Y-%m-%dT%H:%M:%S').tolist(),
                'open': chart_data['open'].round(5).tolist(),
                'high': chart_data['high'].round(5).tolist(),
                'low': chart_data['low'].round(5).tolist(),
                'close': chart_data['close'].round(5).tolist(),
                'volume': chart_data['volume'].round(0).tolist()
            },
            'indicators': {
                'rsi': indicators['rsi']['rsi'][-50:] if 'rsi' in indicators else [],
                'macd': {
                    'macd': indicators['macd']['macd'][-50:] if 'macd' in indicators else [],
                    'signal': indicators['macd']['signal'][-50:] if 'macd' in indicators else []
                }
            },
            'wave_analysis': {
                'current_wave': 5,
                'wave_type': signal['strategy'],
                'wave_confidence': signal['confidence'] / 100
            }
        }

        return chart_dict


def main():
    """Main execution"""
    # Initialize screener
    screener = MultiStrategyScreener(use_demo_data=True)

    # Screen all assets
    signals = screener.screen_all()

    # Rank and get top 10
    top_signals = screener.rank_signals(signals, top_n=10)

    # Convert for dashboard format and generate chart data
    dashboard_signals = []
    for signal in top_signals:
        # Get OHLCV data for this asset
        ohlcv = screener.fetch_data(signal['symbol'])

        dashboard_signal = {
            'symbol': signal['symbol'],
            'strategy': signal['strategy'],
            'timeframe': 'h1',
            'score': signal['score'],
            'direction': signal['direction'].lower(),
            'order_type': signal['order_type'],  # Always "MARKET"
            'entry_price': signal['entry_price'],  # Current market price for immediate execution
            'stop_loss': signal['stop_loss'],
            'take_profit': signal['take_profit'],
            'data_file': f"{signal['symbol'].replace('/', '_')}_h1_{datetime.now().strftime('%Y-%m-%d')}.json",
            'timestamp': signal['timestamp'],
            'wave_analysis': {
                'current_wave': 5,
                'wave_type': signal['strategy'],
                'wave_confidence': signal['confidence'] / 100
            }
        }
        dashboard_signals.append(dashboard_signal)

        # Generate and save chart data file
        if ohlcv is not None:
            chart_data = screener.generate_chart_data(signal, ohlcv)
            chart_filename = f"data/charts/data/{signal['symbol'].replace('/', '_')}_h1_{datetime.now().strftime('%Y-%m-%d')}.json"
            try:
                with open(chart_filename, 'w') as f:
                    json.dump(chart_data, f, indent=2)
                logger.info(f"üíæ Generated chart data: {chart_filename}")
            except Exception as e:
                logger.error(f"Error saving chart data for {signal['symbol']}: {e}")

    # Save top signals index
    screener.save_signals(dashboard_signals)

    logger.info(f"\nüéâ Complete! Top {len(top_signals)} signals and chart data saved to dashboard")


if __name__ == '__main__':
    main()
