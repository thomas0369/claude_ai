"""Base Strategy Class for All Trading Strategies"""

from abc import ABC, abstractmethod
from enum import Enum
from typing import Dict, Optional, Tuple
from dataclasses import dataclass
import pandas as pd


class SignalDirection(Enum):
    """Signal direction enumeration"""
    LONG = 1
    SHORT = -1
    NEUTRAL = 0


@dataclass
class Signal:
    """Trading signal data class - ALL SIGNALS ARE MARKET ORDERS (immediate execution)"""
    direction: SignalDirection
    score: float
    max_score: float
    entry_price: float  # Current market price for IMMEDIATE execution
    stop_loss: float
    take_profit: float
    confidence: float  # 0-100%
    timestamp: pd.Timestamp
    order_type: str = "MARKET"  # Always MARKET - no limit orders
    metadata: Dict = None  # Additional strategy-specific data

    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}

    @property
    def risk_reward_ratio(self) -> float:
        """Calculate risk:reward ratio"""
        risk = abs(self.entry_price - self.stop_loss)
        reward = abs(self.take_profit - self.entry_price)
        return reward / risk if risk > 0 else 0

    @property
    def score_percentage(self) -> float:
        """Score as percentage of max score"""
        return (self.score / self.max_score * 100) if self.max_score > 0 else 0


class BaseStrategy(ABC):
    """Abstract base class for all trading strategies"""

    def __init__(self, name: str, max_score: int, min_score: int):
        """
        Initialize base strategy

        Args:
            name: Strategy name
            max_score: Maximum possible score
            min_score: Minimum score required to generate a signal
        """
        self.name = name
        self.max_score = max_score
        self.min_score = min_score

    @abstractmethod
    def calculate_score(self, indicators: Dict, ohlcv: pd.DataFrame) -> Tuple[float, Dict]:
        """
        Calculate strategy score based on indicators

        Args:
            indicators: Dictionary of technical indicators
            ohlcv: OHLCV DataFrame

        Returns:
            Tuple of (total_score, score_breakdown)
        """
        pass

    @abstractmethod
    def determine_direction(self, indicators: Dict, ohlcv: pd.DataFrame, score: float) -> SignalDirection:
        """
        Determine trade direction

        Args:
            indicators: Dictionary of technical indicators
            ohlcv: OHLCV DataFrame
            score: Calculated score

        Returns:
            SignalDirection (LONG, SHORT, or NEUTRAL)
        """
        pass

    def calculate_stop_loss_take_profit(
        self,
        entry_price: float,
        direction: SignalDirection,
        atr: float = None
    ) -> Tuple[float, float]:
        """
        Calculate stop loss and take profit levels

        Args:
            entry_price: Entry price
            direction: Trade direction
            atr: Average True Range (optional, for dynamic SL/TP)

        Returns:
            Tuple of (stop_loss, take_profit)
        """
        # Default: Fibonacci-based 2.36% SL, 6.18% TP (Golden Ratio 2.618:1 R:R)
        sl_pct = 0.0236
        tp_pct = 0.0618

        if direction == SignalDirection.LONG:
            stop_loss = entry_price * (1 - sl_pct)
            take_profit = entry_price * (1 + tp_pct)
        elif direction == SignalDirection.SHORT:
            stop_loss = entry_price * (1 + sl_pct)
            take_profit = entry_price * (1 - tp_pct)
        else:
            stop_loss = entry_price
            take_profit = entry_price

        return stop_loss, take_profit

    def generate_signal(
        self,
        indicators: Dict,
        ohlcv: pd.DataFrame
    ) -> Optional[Signal]:
        """
        Generate trading signal

        Args:
            indicators: Dictionary of technical indicators
            ohlcv: OHLCV DataFrame

        Returns:
            Signal object or None if no signal
        """
        # Calculate score
        score, score_breakdown = self.calculate_score(indicators, ohlcv)

        # Check if score meets minimum threshold
        if score < self.min_score:
            return None

        # Determine direction
        direction = self.determine_direction(indicators, ohlcv, score)

        # No signal if neutral
        if direction == SignalDirection.NEUTRAL:
            return None

        # Get current market price for IMMEDIATE execution (not a limit order)
        current_price = float(ohlcv['close'].iloc[-1])

        # Calculate SL/TP
        atr = indicators.get('atr', {}).get('atr', [0])[-1] if 'atr' in indicators else None
        stop_loss, take_profit = self.calculate_stop_loss_take_profit(
            current_price,
            direction,
            atr
        )

        # Calculate confidence (score percentage)
        confidence = (score / self.max_score) * 100

        # Create signal (MARKET order - execute immediately at current price)
        signal = Signal(
            direction=direction,
            score=score,
            max_score=self.max_score,
            entry_price=current_price,  # Current market price
            stop_loss=stop_loss,
            take_profit=take_profit,
            confidence=confidence,
            timestamp=ohlcv.index[-1],
            order_type="MARKET",  # Always MARKET execution, never limit orders
            metadata={
                'strategy': self.name,
                'score_breakdown': score_breakdown
            }
        )

        return signal

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name='{self.name}', max_score={self.max_score})"
