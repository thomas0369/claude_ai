import { NextRequest, NextResponse } from 'next/server';
import { PythonExecutor } from '@/lib/python-executor';
import { PDFMatchResponse, PDFMatchResponseSchema } from '@/lib/zerez-types';
import { validateWithErrorHandling } from '@/lib/api-validation-helpers';
import path from 'path';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { products } = body;

    if (!products || products.length === 0) {
      return NextResponse.json(
        { error: 'No products provided' },
        { status: 400 }
      );
    }

    // Get repo root for PDF directory
    const REPO_ROOT = process.env.REPO_ROOT || path.join(process.cwd(), '..');

    // Execute PDF matching script
    const stdout = await PythonExecutor.execute({
      scriptName: 'zerez_pdf_matcher.py',
      args: [
        '--products', JSON.stringify(products),
        '--pdf-dir', path.join(REPO_ROOT, 'datasheets'),
        '--format', 'json'
      ],
      timeout: 60000 // 1 minute
    });

    // Parse Python response
    const pythonData = JSON.parse(stdout);

    // Validate response structure against Zod schema
    const result = validateWithErrorHandling(
      PDFMatchResponseSchema,
      { matches: pythonData },
      {
        operation: 'PDF matching',
        logContext: { totalMatches: pythonData.length },
        sampleData: pythonData[0]
      }
    );

    if (!result.success) return result.response;

    // Type-safe validated data
    return NextResponse.json<PDFMatchResponse>(result.data);
  } catch (error) {
    return NextResponse.json(
      {
        error: 'PDF matching failed',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
