import { NextRequest, NextResponse } from 'next/server';
import { PythonExecutor } from '@/lib/python-executor';
import { ZEREZSearchResponse, ZEREZSearchResponseSchema } from '@/lib/zerez-types';
import { validateWithErrorHandling } from '@/lib/api-validation-helpers';
import { validateUUIDFields, addOptionalStringFilters } from '@/lib/api-validation-utils';
import { isCertificateNormValue, CertificateNormValue } from '@/lib/zerez-constants';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    // Prepare filter object for Python script (only required filters)
    const filters: Record<string, unknown> = {
      isVerified: body.isVerified
      // is4105 removed - replaced by certificateNorms array filter (see below)
    };

    // Only add power filters if they're specified (not null/undefined)
    if (body.powerMin !== undefined && body.powerMin !== null) {
      filters.powerMin = body.powerMin;
    }
    if (body.powerMax !== undefined && body.powerMax !== null) {
      filters.powerMax = body.powerMax;
    }

    // Only add voltage filters if they're specified (not null/undefined)
    if (body.voltageMin !== undefined && body.voltageMin !== null) {
      filters.voltageMin = body.voltageMin;
    }
    if (body.voltageMax !== undefined && body.voltageMax !== null) {
      filters.voltageMax = body.voltageMax;
    }
    if (body.primaryEnergySource) {
      filters.primaryEnergySource = body.primaryEnergySource;
    }
    if (body.category) {
      filters.category = body.category;
    }

    // Certificate norms filter with runtime validation
    if (body.certificateNorms && Array.isArray(body.certificateNorms) && body.certificateNorms.length > 0) {
      // Validate each norm value at runtime
      const validNorms: CertificateNormValue[] = [];
      const invalidNorms: string[] = [];

      for (const norm of body.certificateNorms) {
        if (typeof norm === 'string') {
          if (isCertificateNormValue(norm)) {
            validNorms.push(norm);
          } else {
            invalidNorms.push(norm);
          }
        } else {
          invalidNorms.push(String(norm));
        }
      }

      // Reject request if any invalid norms provided
      if (invalidNorms.length > 0) {
        return NextResponse.json(
          {
            error: 'Invalid certificate norm values',
            details: {
              invalid: invalidNorms,
              message: 'Certificate norms must be one of: VDE-AR-N 4105, VDE-AR-N 4110, VDE-AR-N 4120, VDE-AR-N 4130, CE, IEC'
            }
          },
          { status: 400 }
        );
      }

      // Only add if we have valid norms
      if (validNorms.length > 0) {
        filters.certificateNorms = validNorms;
      }
    }

    // NEW: Date filters (using shared utility for consistency)
    addOptionalStringFilters(body, filters, [
      'createdAfter', 'createdBefore',
      'modifiedAfter', 'modifiedBefore'
    ]);

    // NEW: ID filters with UUID validation (using shared utility)
    if (body.manufacturerId || body.authorityId) {
      const uuidErrors = validateUUIDFields({
        ...(body.manufacturerId && { manufacturerId: body.manufacturerId }),
        ...(body.authorityId && { authorityId: body.authorityId })
      });

      if (uuidErrors.length > 0) {
        return NextResponse.json(
          {
            error: 'Invalid UUID parameters',
            details: uuidErrors
          },
          { status: 400 }
        );
      }

      if (body.manufacturerId && typeof body.manufacturerId === 'string') {
        filters.manufacturerId = body.manufacturerId.trim();
      }
      if (body.authorityId && typeof body.authorityId === 'string') {
        filters.authorityId = body.authorityId.trim();
      }
    }

    // Add maxResults if provided (for preview limit)
    if (body.maxResults !== undefined) {
      const maxResults = Number(body.maxResults);

      // Validate: must be positive integer between 1 and 1000
      if (!Number.isInteger(maxResults) || maxResults < 1 || maxResults > 1000) {
        return NextResponse.json(
          {
            error: 'Invalid maxResults parameter',
            message: 'maxResults must be an integer between 1 and 1000'
          },
          { status: 400 }
        );
      }

      filters.maxResults = maxResults;
    }

    // Execute Python GraphQL client with JSON input via stdin
    const stdout = await PythonExecutor.execute({
      scriptName: 'zerez_search_advanced.py',
      stdin: JSON.stringify(filters),
      timeout: 180000 // 3 minutes for large queries
    });

    // Parse Python response (now returns {units: [...], totalCount: number})
    const pythonData = JSON.parse(stdout);

    // Validate response structure against Zod schema
    // This catches Python-TypeScript schema mismatches at runtime
    const result = validateWithErrorHandling(
      ZEREZSearchResponseSchema,
      pythonData,
      {
        operation: 'ZEREZ search',
        logContext: {
          totalRecords: pythonData.units?.length || 0,
          totalCount: pythonData.totalCount
        },
        sampleData: pythonData.units?.[0]
      }
    );

    if (!result.success) return result.response;

    // Type-safe validated data
    return NextResponse.json<ZEREZSearchResponse>(result.data);
  } catch (error) {
    // PythonExecutor already logs detailed errors server-side
    return NextResponse.json(
      {
        error: 'Failed to search ZEREZ database',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
}
