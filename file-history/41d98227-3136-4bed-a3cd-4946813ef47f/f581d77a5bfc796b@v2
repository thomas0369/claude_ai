import { NextRequest, NextResponse } from 'next/server';
import { promises as fs } from 'fs';
import path from 'path';
import { createErrorResponse } from '@/lib/api-error-handler';

export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

type ProductToImport = {
  id: string;
  modelName?: string;
  [key: string]: unknown;
};

type ExistingProduct = {
  identification: {
    zerez_id?: string;
    model?: string;
    [key: string]: unknown;
  };
  [key: string]: unknown;
};

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { products, mode } = body as {
      products: ProductToImport[];
      mode: 'update' | 'add'
    };

    // Validate input
    if (!Array.isArray(products) || products.length === 0) {
      return NextResponse.json(
        { error: 'No products provided for import' },
        { status: 400 }
      );
    }

    if (mode !== 'update' && mode !== 'add') {
      return NextResponse.json(
        { error: 'Invalid mode. Must be "update" or "add"' },
        { status: 400 }
      );
    }

    // Path to the main products database
    const dbPath = path.join(process.cwd(), 'public', 'data', 'zerez', 'products.json');

    // Read existing database
    let existingProducts: ExistingProduct[] = [];
    try {
      const dbContent = await fs.readFile(dbPath, 'utf-8');
      existingProducts = JSON.parse(dbContent);
    } catch (error) {
      console.warn('Could not read existing database, starting fresh:', error);
      existingProducts = [];
    }

    let added = 0;
    let updated = 0;
    let skipped = 0;

    if (mode === 'update') {
      // Update mode: Replace existing products with same ZEREZ ID
      const productMap = new Map(
        existingProducts.map(p => [p.identification?.zerez_id || p.identification?.model, p])
      );

      for (const newProduct of products) {
        // Try to match by ID or model name
        const matchKey = newProduct.id || newProduct.modelName;

        if (matchKey && productMap.has(matchKey)) {
          // Update existing product - convert GraphQL format to database format
          const convertedProduct = convertGraphQLToDatabase(newProduct);
          productMap.set(matchKey, convertedProduct);
          updated++;
        } else {
          skipped++;
        }
      }

      existingProducts = Array.from(productMap.values());
    } else {
      // Add mode: Add only new products (skip duplicates)
      const existingIds = new Set(
        existingProducts.map(p => p.identification?.zerez_id || p.identification?.model)
      );

      for (const newProduct of products) {
        const matchKey = newProduct.id || newProduct.modelName;

        if (matchKey && !existingIds.has(matchKey)) {
          // Add new product - convert GraphQL format to database format
          const convertedProduct = convertGraphQLToDatabase(newProduct);
          existingProducts.push(convertedProduct);
          added++;
        } else {
          skipped++;
        }
      }
    }

    // Write updated database back to file
    await fs.writeFile(dbPath, JSON.stringify(existingProducts, null, 2), 'utf-8');

    return NextResponse.json({
      success: true,
      mode,
      added,
      updated,
      skipped,
      total: existingProducts.length
    });

  } catch (error) {
    return createErrorResponse('import to database', error);
  }
}

/**
 * Convert GraphQL API format to database JSON format
 */
function convertGraphQLToDatabase(graphqlProduct: ProductToImport): ExistingProduct {
  return {
    identification: {
      model: graphqlProduct.modelName || 'Unknown',
      zerez_id: graphqlProduct.id,
      manufacturer: (graphqlProduct as any).manufacturerName || 'Unknown',
      zerez_variant_count: 1
    },
    power: {
      rated_power_kw: (graphqlProduct as any).ratedPower || 0,
      max_power_kw: (graphqlProduct as any).maxPower || 0
    },
    electrical: {
      max_dc_voltage_v: (graphqlProduct as any).maxDcVoltage || 0,
      rated_ac_current_a: (graphqlProduct as any).ratedAcCurrent || 0
    },
    efficiency: {},
    physical: {},
    certifications: {
      zerez_certificate_id: (graphqlProduct as any).certificateId || '',
      zerez_norm: (graphqlProduct as any).certificateNorm || null,
      zerez_cert_date: (graphqlProduct as any).certificateDate || null
    },
    data_source: {
      source: 'zerez_graphql_api',
      pdf_filename: null,
      extraction_method: 'graphql_import',
      confidence_level: 10,
      parsed_at: new Date().toISOString(),
      source_file: null
    }
  };
}
