/**
 * API Validation Utilities
 *
 * Shared validation helpers for Next.js API routes.
 * Provides consistent validation patterns, error responses, and type guards.
 */

/**
 * UUID validation regex (accepts all UUID formats)
 *
 * Format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
 *
 * NOTE: ZEREZ uses non-standard UUIDs that don't follow RFC 4122 v4 format
 * (variant field starts with '3' instead of '8'/'9'/'a'/'b').
 * This regex accepts any UUID-like format to support ZEREZ integration.
 *
 * @example
 * ```typescript
 * UUID_REGEX.test('550e8400-e29b-41d4-a716-446655440000') // true (v4)
 * UUID_REGEX.test('6314260b-364a-4d53-368d-08dd4b5a9353') // true (ZEREZ format)
 * UUID_REGEX.test('not-a-uuid') // false
 * ```
 */
export const UUID_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;

/**
 * Strict UUID v4 validation regex (RFC 4122 compliant)
 * Use this only when you specifically need RFC 4122 v4 format validation.
 */
export const UUID_V4_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

/**
 * Validate a string is a valid UUID format (any version)
 *
 * @param value - String to validate
 * @returns true if valid UUID format, false otherwise
 *
 * @example
 * ```typescript
 * if (!isValidUUID(productId)) {
 *   return NextResponse.json({ error: 'Invalid UUID' }, { status: 400 });
 * }
 * ```
 */
export function isValidUUID(value: unknown): value is string {
  return typeof value === 'string' && UUID_REGEX.test(value);
}

/**
 * Validate a string is a valid UUID v4 format (strict RFC 4122)
 * Use isValidUUID() instead for ZEREZ integration compatibility.
 *
 * @deprecated Use isValidUUID() for ZEREZ compatibility
 */
export function isValidUUIDv4(value: unknown): value is string {
  return typeof value === 'string' && UUID_V4_REGEX.test(value);
}

/**
 * Validation result type for API responses
 */
export type ValidationError = {
  field: string;
  message: string;
  value?: unknown;
};

/**
 * Validate UUID field with standardized error response
 *
 * @param fieldName - Name of the field being validated (for error messages)
 * @param value - Value to validate
 * @returns ValidationError if invalid, null if valid
 *
 * @example
 * ```typescript
 * const error = validateUUIDField('manufacturerId', body.manufacturerId);
 * if (error) {
 *   return NextResponse.json({
 *     error: `Invalid ${error.field}`,
 *     message: error.message
 *   }, { status: 400 });
 * }
 * ```
 */
export function validateUUIDField(
  fieldName: string,
  value: unknown
): ValidationError | null {
  if (!value) return null; // Optional field

  if (typeof value !== 'string') {
    return {
      field: fieldName,
      message: `${fieldName} must be a string`,
      value: typeof value
    };
  }

  const trimmedValue = value.trim();

  if (!isValidUUID(trimmedValue)) {
    return {
      field: fieldName,
      message: `${fieldName} must be a valid UUID format (e.g., 550e8400-e29b-41d4-a716-446655440000)`,
      value: trimmedValue
    };
  }

  return null;
}

/**
 * Validate multiple UUID fields at once
 *
 * @param fields - Object mapping field names to values
 * @returns Array of ValidationErrors (empty if all valid)
 *
 * @example
 * ```typescript
 * const errors = validateUUIDFields({
 *   manufacturerId: body.manufacturerId,
 *   authorityId: body.authorityId
 * });
 *
 * if (errors.length > 0) {
 *   return NextResponse.json({
 *     error: 'Validation failed',
 *     details: errors
 *   }, { status: 400 });
 * }
 * ```
 */
export function validateUUIDFields(
  fields: Record<string, unknown>
): ValidationError[] {
  const errors: ValidationError[] = [];

  for (const [fieldName, value] of Object.entries(fields)) {
    const error = validateUUIDField(fieldName, value);
    if (error) errors.push(error);
  }

  return errors;
}

/**
 * Add optional string filters to filters object (with trim and empty check)
 *
 * Safely adds string filter values to a filters object, only if they exist
 * and are non-empty after trimming. Handles the common pattern of:
 * "if (value && value.trim() !== '') filters.key = value"
 *
 * @param body - Request body object
 * @param filters - Target filters object to populate
 * @param fieldNames - Array of field names to process
 *
 * @example
 * ```typescript
 * const filters = {};
 * addOptionalStringFilters(body, filters, [
 *   'createdAfter', 'createdBefore',
 *   'modifiedAfter', 'modifiedBefore'
 * ]);
 * // filters now contains only non-empty values
 * ```
 */
export function addOptionalStringFilters(
  body: Record<string, unknown>,
  filters: Record<string, unknown>,
  fieldNames: string[]
): void {
  for (const fieldName of fieldNames) {
    const value = body[fieldName];
    if (typeof value === 'string' && value.trim() !== '') {
      filters[fieldName] = value;
    }
  }
}

/**
 * Invalid item details for array validation
 */
export type InvalidItem = {
  index: number;
  id?: string;
  reason: string;
};

/**
 * Result of UUID array validation
 */
export type UUIDArrayValidationResult = {
  valid: boolean;
  invalidItems?: InvalidItem[];
  error?: string;
};

/**
 * Validate an array of UUID strings with comprehensive error reporting
 *
 * Performs multiple validation checks:
 * - Array existence and type
 * - Non-empty array
 * - Length limits (optional)
 * - Each item is a valid UUID string
 *
 * @param fieldName - Name of the field being validated (for error messages)
 * @param value - Value to validate (should be string array)
 * @param options - Optional validation constraints
 * @param options.minLength - Minimum array length (default: 1)
 * @param options.maxLength - Maximum array length (default: no limit)
 * @returns Validation result with detailed error information
 *
 * @example
 * ```typescript
 * const result = validateUUIDArray('unitIds', body.unitIds, { maxLength: 100 });
 * if (!result.valid) {
 *   return NextResponse.json({
 *     error: result.error,
 *     details: result.invalidItems?.slice(0, 5),
 *     totalInvalid: result.invalidItems?.length
 *   }, { status: 400 });
 * }
 * ```
 */
export function validateUUIDArray(
  fieldName: string,
  value: unknown,
  options?: { minLength?: number; maxLength?: number }
): UUIDArrayValidationResult {
  const minLength = options?.minLength ?? 1;
  const maxLength = options?.maxLength;

  // Check if value exists and is array
  if (!value || !Array.isArray(value)) {
    return {
      valid: false,
      error: `${fieldName} must be a non-empty array`
    };
  }

  // Check minimum length
  if (value.length < minLength) {
    return {
      valid: false,
      error: `${fieldName} must contain at least ${minLength} item(s), received ${value.length}`
    };
  }

  // Check maximum length
  if (maxLength && value.length > maxLength) {
    return {
      valid: false,
      error: `Maximum ${maxLength} items allowed in ${fieldName}, received ${value.length}`
    };
  }

  // Validate each UUID
  const invalidItems: InvalidItem[] = [];

  for (let i = 0; i < value.length; i++) {
    const item = value[i];

    // Type check
    if (typeof item !== 'string') {
      invalidItems.push({
        index: i,
        id: String(item),
        reason: 'Not a string'
      });
      continue;
    }

    // UUID validation
    if (!isValidUUID(item)) {
      invalidItems.push({
        index: i,
        id: item,
        reason: 'Invalid UUID format'
      });
      continue;
    }
  }

  if (invalidItems.length > 0) {
    return {
      valid: false,
      error: `${invalidItems.length} invalid UUID(s) found in ${fieldName}`,
      invalidItems
    };
  }

  return { valid: true };
}

/**
 * Find duplicate values in an array
 *
 * @param values - Array of values to check for duplicates
 * @returns Object with duplicate count and error message, or null if no duplicates
 *
 * @example
 * ```typescript
 * const duplicateError = findDuplicates(unitIds);
 * if (duplicateError) {
 *   return NextResponse.json({
 *     error: 'Duplicate IDs found',
 *     message: duplicateError.message
 *   }, { status: 400 });
 * }
 * ```
 */
export function findDuplicates<T>(
  values: T[]
): { count: number; message: string } | null {
  const uniqueValues = new Set(values);
  const duplicateCount = values.length - uniqueValues.size;

  if (duplicateCount > 0) {
    return {
      count: duplicateCount,
      message: `Found ${duplicateCount} duplicate value(s)`
    };
  }

  return null;
}
