import { NextRequest, NextResponse } from 'next/server';
import { PythonExecutor } from '@/lib/python-executor';
import { isValidUUID, findDuplicates } from '@/lib/api-validation-utils';
import { getZEREZPath } from '@/lib/zerez-constants';
import { createErrorResponse } from '@/lib/api-error-handler';

// Disable response caching for SSE
export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { units } = body;

    // Validate: units must exist and be non-empty array
    if (!units || !Array.isArray(units) || units.length === 0) {
      return NextResponse.json(
        { error: 'No units provided', message: 'units must be a non-empty array' },
        { status: 400 }
      );
    }

    // Validate: array length limit (max 100 units per import)
    if (units.length > 100) {
      return NextResponse.json(
        {
          error: 'Too many units',
          message: `Maximum 100 units allowed per import, received ${units.length}`
        },
        { status: 400 }
      );
    }

    // Validate: each unit must be an object with required fields
    const invalidUnits: Array<{index: number, reason: string}> = [];
    const REQUIRED_FIELDS = ['id', 'modelName'] as const;

    for (let i = 0; i < units.length; i++) {
      const unit = units[i];

      // Type check
      if (!unit || typeof unit !== 'object') {
        invalidUnits.push({index: i, reason: 'Not an object'});
        continue;
      }

      // ID validation
      if (!unit.id) {
        invalidUnits.push({index: i, reason: 'Missing id field'});
        continue;
      }

      if (!isValidUUID(unit.id)) {
        invalidUnits.push({index: i, reason: `Invalid UUID format: ${String(unit.id).substring(0, 20)}`});
        continue;
      }

      // Required fields validation
      for (const field of REQUIRED_FIELDS) {
        if (!(field in unit) || unit[field] === null || unit[field] === undefined) {
          invalidUnits.push({index: i, reason: `Missing required field: ${field}`});
          break;
        }
      }
    }

    if (invalidUnits.length > 0) {
      return NextResponse.json(
        {
          error: 'Invalid units',
          message: `${invalidUnits.length} invalid unit(s) found`,
          details: invalidUnits.slice(0, 5), // Show first 5 with reasons
          totalInvalid: invalidUnits.length
        },
        { status: 400 }
      );
    }

    // Validate: check for duplicate IDs
    const unitIds = units.map((u: any) => u.id);
    const duplicateError = findDuplicates(unitIds);
    if (duplicateError) {
      return NextResponse.json(
        {
          error: 'Duplicate unit IDs',
          message: duplicateError.message
        },
        { status: 400 }
      );
    }

    // Calculate dynamic timeout based on observed performance
    // Observed: ~0.02s per unit (JSON save is very fast)
    // Using: 0.1s per unit (5x safety margin for system variation)
    const ACTUAL_SECONDS_PER_UNIT = 0.02;
    const SAFETY_MULTIPLIER = 5; // 5x margin for system delays
    const SECONDS_PER_UNIT = ACTUAL_SECONDS_PER_UNIT * SAFETY_MULTIPLIER;

    const BASE_TIMEOUT_MS = 10000; // 10s startup buffer (Python initialization)
    const TIMEOUT_PER_UNIT_MS = SECONDS_PER_UNIT * 1000;
    const MIN_TIMEOUT_MS = 15000; // 15s minimum for small batches (0-1 units)
    const MAX_TIMEOUT_MS = 300000; // 5 minute hard limit (reduced from 10)

    // Calculate with bounds checking
    const calculatedTimeout = BASE_TIMEOUT_MS + (units.length * TIMEOUT_PER_UNIT_MS);
    const timeout = Math.max(MIN_TIMEOUT_MS, Math.min(calculatedTimeout, MAX_TIMEOUT_MS));

    // Log timeout calculation in development
    if (process.env.NODE_ENV === 'development') {
      console.log(`[import-details] Timeout: ${timeout}ms for ${units.length} units (${(timeout/1000).toFixed(1)}s)`);
    }

    // Create SSE stream using Python Executor with new JSON saver
    const stream = PythonExecutor.createStreamingResponse({
      scriptName: 'zerez_json_saver.py',
      args: [
        '--units', JSON.stringify(units),
        '--output-dir', getZEREZPath('IMPORTS'),
        '--stream-progress',
        '--single-file'  // Save all products to one timestamped file
      ],
      timeout
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache, no-transform',
        'Connection': 'keep-alive',
        'X-Accel-Buffering': 'no', // Disable Nginx buffering
      },
    });
  } catch (error) {
    return createErrorResponse('import ZEREZ products', error);
  }
}
