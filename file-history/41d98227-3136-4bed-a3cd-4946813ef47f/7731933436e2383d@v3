/**
 * ZEREZ GraphQL Client (TypeScript)
 * ==================================
 *
 * Direct GraphQL API client for ZEREZ database.
 * Ported from Python to run in Vercel serverless functions.
 *
 * API Endpoint: https://app-zerez-weeu-gatewaysvc-prod-01.azurewebsites.net/graphql/
 */

import { GraphQLClient } from 'graphql-request';

// GraphQL introspection query to discover enum types
const INTROSPECTION_QUERY = `
  query IntrospectSchema {
    __schema {
      types {
        name
        kind
        enumValues {
          name
          description
        }
      }
    }
  }
`;

// GraphQL query for tenant resolution
const GET_TENANT_QUERY = `
  query GetTenant($id: UUID!) {
    tenant(id: $id) {
      id
      tenantName
    }
  }
`;

// GraphQL query for all tenants
const GET_ALL_TENANTS_QUERY = `
  query GetAllTenants($skip: Int, $take: Int) {
    tenants(skip: $skip, take: $take) {
      totalCount
      items {
        id
        tenantName
      }
    }
  }
`;

// GraphQL query for unit search
const UNIT_SEARCH_QUERY = `
  query getUnitsForUnitsOverview($skip: Int, $take: Int, $where: UnitOverviewFilterInput, $order: [UnitOverviewSortInput!]) {
    unitOverview(skip: $skip, take: $take, where: $where, order: $order) {
      totalCount
      items {
        id
        isImported
        tenantId
        certificateAuthorityId
        modelName
        manufacturerId
        ratedCurrent
        unitCode
        maxActivePower
        hasActivePowerRange
        hasApparentPowerRange
        certificateId
        maxActivePowerRange
        maxApparentPowerRange
        minActivePowerRange
        minApparentPowerRange
        ratedVoltage
        unitTypeId
        createdAt
        modifiedAt
        certificateNormIssueDateDescriptions
        is4105
        category
        certificateIsImported
        isVerified
        certificateIssueDate
        certificateHolderId
        primaryEnergySource
        certificateNumber
        validityStartDate
        validityEndDate
        inEditByTenantId
        withTG8Rev25Conformity
        certificateValidityStatusName
        certificateValidityStatusId
        certificateTypeId
        hasActiveErrorReport
        __typename
      }
      __typename
    }
  }
`;

/**
 * ZEREZ Unit interface
 */
export interface ZEREZUnit {
  // Core identifiers
  id: string;
  unitCode?: string | null;
  modelName?: string | null;
  certificateNumber?: string | null;

  // Power ratings
  maxActivePower?: number | null;
  maxActivePowerRange?: number | null;
  minActivePowerRange?: number | null;
  maxApparentPowerRange?: number | null;
  minApparentPowerRange?: number | null;

  // Electrical
  ratedVoltage?: number | null;
  ratedCurrent?: number | null;

  // Classification
  primaryEnergySource?: string | null;
  category?: string | null;
  unitTypeId?: string | null;

  // Certification
  certificateId?: string | null;
  certificateIssueDate?: string | null;
  certificateAuthorityId?: string | null;
  certificateAuthorityName?: string | null; // Resolved via tenant() query
  certificateHolderId?: string | null;
  manufacturerId?: string | null;
  manufacturerName?: string | null; // Resolved via tenant() query
  certificateValidityStatusName?: string | null;
  certificateNormIssueDateDescriptions?: string | null;

  // Status
  isVerified: boolean;
  isImported: boolean;
  is4105: boolean;

  // Dates
  createdAt?: string | null;
  modifiedAt?: string | null;
  validityStartDate?: string | null;
  validityEndDate?: string | null;
}

/**
 * Tenant interface (manufacturer or certificate authority)
 */
export interface Tenant {
  id: string;
  name: string;
}

/**
 * Search filters for ZEREZ units
 */
export interface SearchFilters {
  powerMinKw?: number | null;
  powerMaxKw?: number | null;
  primaryEnergySource?: string | null;
  category?: string | null;
  isVerified?: boolean | null;
  is4105?: boolean | null;
  voltageMin?: number | null;
  voltageMax?: number | null;
  certificateNorms?: string[] | null;
  manufacturerId?: string | null;
  authorityId?: string | null;
  createdAfter?: string | null;
  createdBefore?: string | null;
  modifiedAfter?: string | null;
  modifiedBefore?: string | null;
}

/**
 * ZEREZ GraphQL Client
 */
export class ZEREZGraphQLClient {
  private client: GraphQLClient;
  private enumCache: Map<string, string[]> = new Map();
  private manufacturerNameCache: Map<string, string | null> = new Map();
  private authorityNameCache: Map<string, string | null> = new Map();
  private initialized: boolean = false;

  constructor() {
    this.client = new GraphQLClient(
      'https://app-zerez-weeu-gatewaysvc-prod-01.azurewebsites.net/graphql/',
      {
        headers: {
          'Content-Type': 'application/json',
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
        },
        timeout: 30000,
      }
    );
  }

  /**
   * Initialize client (load enum values)
   * Must be called before using the client
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;

    try {
      await this.loadEnumValues();
      this.initialized = true;
    } catch (error) {
      console.error('Failed to initialize ZEREZ client:', error);
      // Continue without enum validation
      this.initialized = true;
    }
  }

  /**
   * Validate UUID format
   */
  private isValidUUID(uuid: string | null | undefined): boolean {
    if (!uuid) return false;

    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    return uuidRegex.test(uuid);
  }

  /**
   * Load enum values via GraphQL introspection
   */
  private async loadEnumValues(): Promise<void> {
    try {
      const response: any = await this.client.request(INTROSPECTION_QUERY);

      const types = response.__schema?.types || [];

      for (const typeDef of types) {
        if (typeDef.kind === 'ENUM' && typeDef.enumValues) {
          const enumName = typeDef.name;
          const enumValues = typeDef.enumValues.map((ev: any) => ev.name);
          this.enumCache.set(enumName, enumValues);
        }
      }

      console.log(`Discovered ${this.enumCache.size} enum types`);
    } catch (error) {
      console.warn('Failed to load enum values:', error);
    }
  }

  /**
   * Get available values for an enum type
   */
  getEnumValues(enumName: string): string[] {
    return this.enumCache.get(enumName) || [];
  }

  /**
   * Get all enum types and their values
   */
  getAllEnumTypes(): Record<string, string[]> {
    const result: Record<string, string[]> = {};
    this.enumCache.forEach((values, key) => {
      result[key] = values;
    });
    return result;
  }

  /**
   * Validate enum value
   */
  private validateEnumValue(enumType: string, value: string): boolean {
    const validValues = this.enumCache.get(enumType);
    if (!validValues) {
      console.warn(`Unknown enum type '${enumType}'`);
      return false;
    }

    if (!validValues.includes(value)) {
      console.warn(`Invalid value '${value}' for enum '${enumType}'`);
      return false;
    }

    return true;
  }

  /**
   * Get all tenants (manufacturers)
   */
  async getAllTenants(): Promise<Tenant[]> {
    const allTenants: Tenant[] = [];
    let skip = 0;
    const take = 1000;

    try {
      while (true) {
        const response: any = await this.client.request(GET_ALL_TENANTS_QUERY, {
          skip,
          take,
        });

        const items = response.tenants?.items || [];
        const totalCount = response.tenants?.totalCount || 0;

        for (const item of items) {
          if (item.id && item.tenantName) {
            allTenants.push({
              id: item.id,
              name: item.tenantName,
            });
          }
        }

        if (skip + items.length >= totalCount || items.length === 0) {
          break;
        }

        skip += items.length;
      }

      // Sort by name for better UX
      allTenants.sort((a, b) => a.name.localeCompare(b.name));

      return allTenants;
    } catch (error) {
      console.error('Failed to fetch tenants:', error);
      throw error;
    }
  }

  /**
   * Get unique certificate authority IDs from units sample
   */
  async getCertificateAuthorities(): Promise<Tenant[]> {
    try {
      // Sample 10,000 units to find unique authority IDs
      const filters: SearchFilters = {};
      const response: any = await this.client.request(UNIT_SEARCH_QUERY, {
        skip: 0,
        take: 10000,
        where: this.buildWhereClause(filters),
        order: {},
      });

      const items = response.unitOverview?.items || [];

      // Extract unique authority IDs
      const authorityIds = new Set<string>();
      for (const item of items) {
        if (item.certificateAuthorityId && this.isValidUUID(item.certificateAuthorityId)) {
          authorityIds.add(item.certificateAuthorityId);
        }
      }

      // Resolve IDs to names
      const authorities: Tenant[] = [];
      for (const id of Array.from(authorityIds)) {
        try {
          const response: any = await this.client.request(GET_TENANT_QUERY, { id });

          if (response.tenant?.tenantName) {
            authorities.push({
              id,
              name: response.tenant.tenantName,
            });
          }
        } catch (error) {
          console.warn(`Failed to resolve authority ${id}:`, error);
        }
      }

      // Sort by name
      authorities.sort((a, b) => a.name.localeCompare(b.name));

      return authorities;
    } catch (error) {
      console.error('Failed to fetch certificate authorities:', error);
      throw error;
    }
  }

  /**
   * Resolve tenant name from ID
   */
  private async resolveTenantName(
    id: string,
    cache: Map<string, string | null>
  ): Promise<string | null> {
    // Check cache first
    if (cache.has(id)) {
      return cache.get(id) || null;
    }

    // Validate UUID
    if (!this.isValidUUID(id)) {
      console.warn(`Invalid UUID: ${id}`);
      cache.set(id, null);
      return null;
    }

    try {
      const response: any = await this.client.request(GET_TENANT_QUERY, { id });

      const name = response.tenant?.tenantName || null;
      cache.set(id, name);
      return name;
    } catch (error) {
      console.warn(`Failed to resolve tenant ${id}:`, error);
      cache.set(id, null);
      return null;
    }
  }

  /**
   * Resolve manufacturer names for units
   */
  private async resolveManufacturerNames(units: ZEREZUnit[]): Promise<void> {
    const uniqueIds = new Set<string>();

    for (const unit of units) {
      if (unit.manufacturerId) {
        uniqueIds.add(unit.manufacturerId);
      }
    }

    // Resolve names in parallel (batch of 10 at a time to avoid rate limits)
    const ids = Array.from(uniqueIds);
    const batchSize = 10;

    for (let i = 0; i < ids.length; i += batchSize) {
      const batch = ids.slice(i, i + batchSize);
      await Promise.all(
        batch.map(id => this.resolveTenantName(id, this.manufacturerNameCache))
      );
    }

    // Apply resolved names to units
    for (const unit of units) {
      if (unit.manufacturerId) {
        unit.manufacturerName = this.manufacturerNameCache.get(unit.manufacturerId) || null;
      }
    }
  }

  /**
   * Resolve certificate authority names for units
   */
  private async resolveCertificateAuthorityNames(units: ZEREZUnit[]): Promise<void> {
    const uniqueIds = new Set<string>();

    for (const unit of units) {
      if (unit.certificateAuthorityId) {
        uniqueIds.add(unit.certificateAuthorityId);
      }
    }

    // Resolve names in parallel (batch of 10 at a time)
    const ids = Array.from(uniqueIds);
    const batchSize = 10;

    for (let i = 0; i < ids.length; i += batchSize) {
      const batch = ids.slice(i, i + batchSize);
      await Promise.all(
        batch.map(id => this.resolveTenantName(id, this.authorityNameCache))
      );
    }

    // Apply resolved names to units
    for (const unit of units) {
      if (unit.certificateAuthorityId) {
        unit.certificateAuthorityName = this.authorityNameCache.get(unit.certificateAuthorityId) || null;
      }
    }
  }

  /**
   * Build GraphQL where clause from filters
   */
  private buildWhereClause(filters: SearchFilters): any {
    // Base filter matching ZEREZ's default structure
    const baseFilter = {
      or: [
        {
          ratedVoltage: {
            gte: 0,
          },
        },
        {
          ratedVoltage: {
            eq: null,
          },
        },
      ],
      replacedByUnitId: {
        eq: null,
      },
    };

    const where: any = {
      and: [baseFilter],
    };

    // Power range filter
    if (filters.powerMinKw != null || filters.powerMaxKw != null) {
      const powerFilter: any = {};
      if (filters.powerMinKw != null) {
        powerFilter.gte = filters.powerMinKw;
      }
      if (filters.powerMaxKw != null) {
        powerFilter.lte = filters.powerMaxKw;
      }
      where.and.push({
        maxActivePower: powerFilter,
      });
    }

    // Primary energy source filter
    if (filters.primaryEnergySource) {
      if (this.validateEnumValue('PrimaryEnergySource', filters.primaryEnergySource)) {
        where.and.push({
          primaryEnergySource: {
            eq: filters.primaryEnergySource,
          },
        });
      }
    }

    // Category filter
    if (filters.category) {
      if (this.validateEnumValue('Category', filters.category)) {
        where.and.push({
          category: {
            eq: filters.category,
          },
        });
      }
    }

    // Verification status
    if (filters.isVerified != null) {
      where.and.push({
        isVerified: {
          eq: filters.isVerified,
        },
      });
    }

    // 4105 compliance
    if (filters.is4105 != null) {
      where.and.push({
        is4105: {
          eq: filters.is4105,
        },
      });
    }

    // Voltage range filter
    if (filters.voltageMin != null || filters.voltageMax != null) {
      const voltageFilter: any = {};
      if (filters.voltageMin != null) {
        voltageFilter.gte = filters.voltageMin;
      }
      if (filters.voltageMax != null) {
        voltageFilter.lte = filters.voltageMax;
      }
      where.and.push({
        ratedVoltage: voltageFilter,
      });
    }

    // Certificate norms filter
    if (filters.certificateNorms && filters.certificateNorms.length > 0) {
      const normsOrClause = [];
      for (const norm of filters.certificateNorms) {
        normsOrClause.push({
          certificateNormIssueDateDescriptions: {
            contains: norm,
          },
        });
      }
      where.and.push({ or: normsOrClause });
    }

    // Manufacturer filter
    if (filters.manufacturerId) {
      where.and.push({
        manufacturerId: {
          eq: filters.manufacturerId,
        },
      });
    }

    // Authority filter
    if (filters.authorityId) {
      where.and.push({
        certificateAuthorityId: {
          eq: filters.authorityId,
        },
      });
    }

    // Date filters
    if (filters.createdAfter != null || filters.createdBefore != null) {
      const createdFilter: any = {};
      if (filters.createdAfter != null) {
        createdFilter.gte = filters.createdAfter;
      }
      if (filters.createdBefore != null) {
        createdFilter.lte = filters.createdBefore;
      }
      where.and.push({
        createdAt: createdFilter,
      });
    }

    if (filters.modifiedAfter != null || filters.modifiedBefore != null) {
      const modifiedFilter: any = {};
      if (filters.modifiedAfter != null) {
        modifiedFilter.gte = filters.modifiedAfter;
      }
      if (filters.modifiedBefore != null) {
        modifiedFilter.lte = filters.modifiedBefore;
      }
      where.and.push({
        modifiedAt: modifiedFilter,
      });
    }

    return where;
  }

  /**
   * Search ZEREZ units
   */
  async searchUnits(
    filters: SearchFilters,
    take: number = 100,
    maxResults?: number
  ): Promise<{ units: ZEREZUnit[]; totalCount: number }> {
    const where = this.buildWhereClause(filters);
    const allUnits: ZEREZUnit[] = [];
    let totalCount = 0;
    let skip = 0;

    try {
      while (true) {
        const response: any = await this.client.request(UNIT_SEARCH_QUERY, {
          skip,
          take,
          where,
          order: {},
        });

        const items = response.unitOverview?.items || [];
        totalCount = response.unitOverview?.totalCount || 0;

        for (const item of items) {
          const unit: ZEREZUnit = {
            id: item.id,
            unitCode: item.unitCode,
            modelName: item.modelName,
            certificateNumber: item.certificateNumber,
            maxActivePower: item.maxActivePower,
            maxActivePowerRange: item.maxActivePowerRange,
            minActivePowerRange: item.minActivePowerRange,
            maxApparentPowerRange: item.maxApparentPowerRange,
            minApparentPowerRange: item.minApparentPowerRange,
            ratedVoltage: item.ratedVoltage,
            ratedCurrent: item.ratedCurrent,
            primaryEnergySource: item.primaryEnergySource,
            category: item.category,
            unitTypeId: item.unitTypeId,
            certificateId: item.certificateId,
            certificateIssueDate: item.certificateIssueDate,
            certificateAuthorityId: item.certificateAuthorityId,
            certificateHolderId: item.certificateHolderId,
            manufacturerId: item.manufacturerId,
            certificateValidityStatusName: item.certificateValidityStatusName,
            certificateNormIssueDateDescriptions: item.certificateNormIssueDateDescriptions,
            isVerified: item.isVerified || false,
            isImported: item.isImported || false,
            is4105: item.is4105 || false,
            createdAt: item.createdAt,
            modifiedAt: item.modifiedAt,
            validityStartDate: item.validityStartDate,
            validityEndDate: item.validityEndDate,
          };
          allUnits.push(unit);
        }

        // Check limits - stop fetching more but don't return yet (need name resolution)
        if (maxResults && allUnits.length >= maxResults) {
          break; // Exit loop but continue to name resolution
        }

        if (skip + items.length >= totalCount || items.length === 0) {
          break;
        }

        skip += items.length;
      }

      // Resolve manufacturer and authority names in parallel
      // This must happen BEFORE slicing to maxResults
      await Promise.all([
        this.resolveManufacturerNames(allUnits),
        this.resolveCertificateAuthorityNames(allUnits),
      ]);

      // Apply maxResults limit after name resolution
      const finalUnits = maxResults ? allUnits.slice(0, maxResults) : allUnits;

      return {
        units: finalUnits,
        totalCount,
      };
    } catch (error) {
      console.error('Search units failed:', error);
      throw error;
    }
  }
}

/**
 * Singleton instance
 */
let clientInstance: ZEREZGraphQLClient | null = null;

/**
 * Get or create ZEREZ client singleton
 */
export async function getZEREZClient(): Promise<ZEREZGraphQLClient> {
  if (!clientInstance) {
    clientInstance = new ZEREZGraphQLClient();
    await clientInstance.initialize();
  }
  return clientInstance;
}
