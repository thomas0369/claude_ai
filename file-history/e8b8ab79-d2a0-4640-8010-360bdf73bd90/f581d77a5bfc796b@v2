import { NextRequest, NextResponse } from 'next/server';
import { promises as fs } from 'fs';
import path from 'path';
import { z } from 'zod';
import { createErrorResponse } from '@/lib/api-error-handler';

export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

// Zod schemas for input validation (防止 injection attacks)
const ProductToImportSchema = z.object({
  id: z.string().uuid('Invalid product ID format'),
  modelName: z.string().min(1).max(200).optional(),
  manufacturerName: z.string().max(200).optional(),
  ratedPower: z.number().nonnegative().optional(),
  maxPower: z.number().nonnegative().optional(),
  maxDcVoltage: z.number().nonnegative().optional(),
  ratedAcCurrent: z.number().nonnegative().optional(),
  certificateId: z.string().max(200).optional(),
  certificateNorm: z.string().max(100).optional(),
  certificateDate: z.string().optional(),
}).strict(); // Reject unexpected keys (防止 prototype pollution)

const ImportRequestSchema = z.object({
  products: z.array(ProductToImportSchema).min(1).max(1000),
  mode: z.enum(['replace', 'merge', 'add']),
}).strict();

type ProductToImport = z.infer<typeof ProductToImportSchema>;

type ExistingProduct = {
  identification: {
    zerez_id?: string;
    model?: string;
    [key: string]: unknown;
  };
  [key: string]: unknown;
};

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    // Validate input with Zod (防止 invalid/malicious data)
    const validationResult = ImportRequestSchema.safeParse(body);

    if (!validationResult.success) {
      return NextResponse.json(
        {
          error: 'Invalid request data',
          details: validationResult.error.issues.map(err => ({
            path: err.path.join('.'),
            message: err.message,
          })),
        },
        { status: 400 }
      );
    }

    const { products, mode } = validationResult.data;

    // Path to the main products database
    const dbPath = path.join(process.cwd(), 'public', 'data', 'zerez', 'products.json');

    // Validate dbPath stays within allowed directory (防止 path traversal)
    const resolvedDbPath = path.resolve(dbPath);
    const allowedDir = path.resolve(process.cwd(), 'public');
    if (!resolvedDbPath.startsWith(allowedDir)) {
      return NextResponse.json(
        { error: 'Invalid database path' },
        { status: 403 }
      );
    }

    // Read existing database
    let existingProducts: ExistingProduct[] = [];
    try {
      const dbContent = await fs.readFile(dbPath, 'utf-8');
      existingProducts = JSON.parse(dbContent);
    } catch (error) {
      console.warn('Could not read existing database, starting fresh:', error);
      existingProducts = [];
    }

    let added = 0;
    let updated = 0;
    let skipped = 0;

    if (mode === 'replace') {
      // Replace mode: Clear entire database and import fresh (DESTRUCTIVE)
      existingProducts = [];
      for (const newProduct of products) {
        const convertedProduct = convertGraphQLToDatabase(newProduct);
        existingProducts.push(convertedProduct);
        added++;
      }
    } else if (mode === 'merge') {
      // Merge mode: Update existing + add new (RECOMMENDED)
      const productMap = new Map(
        existingProducts.map(p => [p.identification?.zerez_id || p.identification?.model, p])
      );

      for (const newProduct of products) {
        const matchKey = newProduct.id || newProduct.modelName;
        const convertedProduct = convertGraphQLToDatabase(newProduct);

        if (matchKey && productMap.has(matchKey)) {
          // Update existing product
          productMap.set(matchKey, convertedProduct);
          updated++;
        } else {
          // Add new product
          productMap.set(matchKey || `unknown-${Date.now()}-${Math.random()}`, convertedProduct);
          added++;
        }
      }

      existingProducts = Array.from(productMap.values());
    } else {
      // Add mode: Add only new products (skip duplicates, preserve existing)
      const existingIds = new Set(
        existingProducts.map(p => p.identification?.zerez_id || p.identification?.model)
      );

      for (const newProduct of products) {
        const matchKey = newProduct.id || newProduct.modelName;

        if (matchKey && !existingIds.has(matchKey)) {
          // Add new product - convert GraphQL format to database format
          const convertedProduct = convertGraphQLToDatabase(newProduct);
          existingProducts.push(convertedProduct);
          added++;
        } else {
          skipped++;
        }
      }
    }

    // Write updated database back to file
    await fs.writeFile(dbPath, JSON.stringify(existingProducts, null, 2), 'utf-8');

    return NextResponse.json({
      success: true,
      mode,
      added,
      updated,
      skipped,
      total: existingProducts.length
    });

  } catch (error) {
    return createErrorResponse('import to database', error);
  }
}

/**
 * Convert GraphQL API format to database JSON format
 */
function convertGraphQLToDatabase(graphqlProduct: ProductToImport): ExistingProduct {
  return {
    identification: {
      model: graphqlProduct.modelName || 'Unknown',
      zerez_id: graphqlProduct.id,
      manufacturer: graphqlProduct.manufacturerName || 'Unknown',
      zerez_variant_count: 1
    },
    power: {
      rated_power_kw: graphqlProduct.ratedPower || 0,
      max_power_kw: graphqlProduct.maxPower || 0
    },
    electrical: {
      max_dc_voltage_v: graphqlProduct.maxDcVoltage || 0,
      rated_ac_current_a: graphqlProduct.ratedAcCurrent || 0
    },
    efficiency: {},
    physical: {},
    certifications: {
      zerez_certificate_id: graphqlProduct.certificateId || '',
      zerez_norm: graphqlProduct.certificateNorm || null,
      zerez_cert_date: graphqlProduct.certificateDate || null
    },
    data_source: {
      source: 'zerez_graphql_api',
      pdf_filename: null,
      extraction_method: 'graphql_import',
      confidence_level: 10,
      parsed_at: new Date().toISOString(),
      source_file: null
    }
  };
}
