import { NextRequest, NextResponse } from 'next/server';
import { promises as fs } from 'fs';
import path from 'path';
import { z } from 'zod';
import { createErrorResponse } from '@/lib/api-error-handler';
import type { EnhancedProductData } from '@/lib/types-enhanced';
import {
  canEditProduct,
  canEditField,
  validateEditPermission,
  getDataSource,
} from '@/lib/edit-permissions';
import { DataEnricher } from '@/lib/data-enrichment';
import { validateFieldValue, EDITABLE_FIELDS_ARRAY } from '@/lib/edit-validation-schemas';

export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

// Request validation schema
const EditRequestSchema = z.object({
  productId: z.string().min(1, 'Product ID is required'),
  field: z.enum(EDITABLE_FIELDS_ARRAY, {
    errorMap: () => ({ message: 'Invalid or non-editable field' })
  }),
  newValue: z.union([z.string(), z.number()]),
}).strict();

/**
 * Edit Product API Endpoint
 *
 * SECURITY RULES:
 * 1. Only PDF-imported products can be edited
 * 2. ZEREZ products are read-only (403 Forbidden)
 * 3. Calculated fields cannot be edited
 * 4. Server-side validation required
 *
 * POST /api/products/edit
 * Body: { productId, field, newValue }
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    // Validate request
    const validationResult = EditRequestSchema.safeParse(body);
    if (!validationResult.success) {
      return NextResponse.json(
        {
          error: 'Invalid request data',
          details: validationResult.error.issues.map(err => ({
            path: err.path.join('.'),
            message: err.message,
          })),
        },
        { status: 400 }
      );
    }

    const { productId, field, newValue } = validationResult.data;

    // Validate field value with field-specific schema
    const fieldValidation = validateFieldValue(field, newValue);
    if (!fieldValidation.success) {
      return NextResponse.json(
        {
          error: 'Validation Error',
          message: fieldValidation.error,
          field,
          value: newValue,
        },
        { status: 400 }
      );
    }

    // Use validated value
    const validatedValue = fieldValidation.data!;

    // Load products database
    const dbPath = path.join(process.cwd(), 'public', 'data', 'zerez', 'products.json');
    const dbContent = await fs.readFile(dbPath, 'utf-8');
    const products: EnhancedProductData[] = JSON.parse(dbContent);

    // Find product by ZEREZ ID
    const productIndex = products.findIndex(
      p => p.identification.zerez_id === productId
    );

    if (productIndex === -1) {
      return NextResponse.json(
        { error: 'Product not found', productId },
        { status: 404 }
      );
    }

    const product = products[productIndex];

    // CRITICAL: Validate edit permissions (server-side security)
    try {
      validateEditPermission(product, field);
    } catch (error) {
      return NextResponse.json(
        {
          error: 'FORBIDDEN',
          message: error instanceof Error ? error.message : 'Edit not allowed',
          details: {
            productId,
            field,
            dataSource: getDataSource(product),
            reason: error instanceof Error ? error.message : 'Permission denied',
          },
        },
        { status: 403 }
      );
    }

    // Get old value for logging
    const oldValue = getNestedValue(product, field);

    // Update the field value with validated value
    setNestedValue(product, field, validatedValue);

    // Update last_updated timestamp
    product.data_source.last_updated = new Date().toISOString();

    // Auto-update validation status to "review" after edit
    if (product.data_source.validation_status !== 'rejected') {
      product.data_source.validation_status = 'needs_review';
    }

    // Update product in array
    products[productIndex] = product;

    // Re-enrich product to update calculated fields
    // This ensures power_density, power_to_weight, etc. are recalculated
    const enrichedProducts = DataEnricher.enrichProducts(products as any);

    // Write back to file
    await fs.writeFile(dbPath, JSON.stringify(enrichedProducts, null, 2), 'utf-8');

    // Log the edit (for future edit history feature)
    console.log('[Product Edit]', {
      timestamp: new Date().toISOString(),
      productId,
      field,
      oldValue,
      newValue,
      dataSource: getDataSource(product),
    });

    // Return updated product for client-side state update (avoids page reload)
    return NextResponse.json({
      success: true,
      message: 'Product updated successfully',
      updatedProduct: enrichedProducts[productIndex], // Client can update state directly
      details: {
        productId,
        field,
        oldValue,
        newValue: validatedValue,
        validationStatus: enrichedProducts[productIndex].data_source.validation_status,
        updatedAt: enrichedProducts[productIndex].data_source.last_updated,
      },
    });

  } catch (error) {
    return createErrorResponse('edit product', error);
  }
}

/**
 * Get nested object value by dot-notation path
 * Example: getNestedValue(obj, "efficiency.peak_percent")
 */
function getNestedValue(obj: any, path: string): any {
  return path.split('.').reduce((current, key) => current?.[key], obj);
}

/**
 * Set nested object value by dot-notation path
 * Example: setNestedValue(obj, "efficiency.peak_percent", 97.5)
 */
function setNestedValue(obj: any, path: string, value: any): void {
  const keys = path.split('.');
  const lastKey = keys.pop();

  if (!lastKey) return;

  const target = keys.reduce((current, key) => {
    // Initialize nested object if doesn't exist
    if (!current[key] || typeof current[key] !== 'object') {
      current[key] = {};
    }
    return current[key];
  }, obj);

  target[lastKey] = value;
}
