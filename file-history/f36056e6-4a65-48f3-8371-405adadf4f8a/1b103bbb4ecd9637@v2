"""
Test Script for Claude Validation Queue Integration

Tests the complete integration of the Claude validation queue system
including queue management, caching, and API endpoints.
"""

import sys
from pathlib import Path

# Add src to path
sys.path.insert(0, str(Path(__file__).parent / 'src'))

from claude_validation_queue import ClaudeValidationQueue
import json
from datetime import datetime


def test_queue_creation():
    """Test creating a validation queue instance."""
    print("\n" + "=" * 60)
    print("TEST 1: Queue Creation")
    print("=" * 60)

    queue = ClaudeValidationQueue(
        max_validations_per_day=20,
        min_score_for_validation=85,
        cache_dir="data/test_claude_cache"
    )

    print(f"‚úÖ Queue created successfully")
    print(f"   - Max validations/day: {queue.max_validations_per_day}")
    print(f"   - Min score: {queue.min_score_for_validation}")
    print(f"   - Cache directory: {queue.cache_dir}")

    return queue


def test_should_validate(queue):
    """Test validation eligibility checks."""
    print("\n" + "=" * 60)
    print("TEST 2: Validation Eligibility Checks")
    print("=" * 60)

    test_cases = [
        ("EUR/USD", 120, "High score signal"),
        ("GBP/USD", 85, "Minimum threshold signal"),
        ("XAU/USD", 70, "Below threshold signal"),
        ("USOIL", 150, "Elite signal"),
    ]

    for symbol, score, description in test_cases:
        should_validate, reason = queue.should_validate(symbol, score)

        status = "‚úÖ VALIDATE" if should_validate else "‚è≠Ô∏è  SKIP"
        print(f"\n{status} - {description}")
        print(f"   Symbol: {symbol}")
        print(f"   Score: {score}")
        print(f"   Reason: {reason}")


def test_enqueue_validation(queue):
    """Test enqueueing validation requests."""
    print("\n" + "=" * 60)
    print("TEST 3: Enqueue Validation Requests")
    print("=" * 60)

    test_signals = [
        {
            "symbol": "EUR/USD",
            "score": 120,
            "direction": "long",
            "current_price": 1.0850,
            "stop_loss": 1.0800,
            "take_profit": 1.0950,
            "leverage": 20,
            "tradeable": True,
            "timestamp": datetime.now().isoformat()
        },
        {
            "symbol": "GBP/USD",
            "score": 95,
            "direction": "short",
            "current_price": 1.2650,
            "stop_loss": 1.2700,
            "take_profit": 1.2550,
            "leverage": 20,
            "tradeable": True,
            "timestamp": datetime.now().isoformat()
        },
        {
            "symbol": "XAU/USD",
            "score": 150,
            "direction": "long",
            "current_price": 2050.50,
            "stop_loss": 2030.00,
            "take_profit": 2080.00,
            "leverage": 10,
            "tradeable": True,
            "timestamp": datetime.now().isoformat()
        }
    ]

    for signal in test_signals:
        enqueued, reason = queue.enqueue_validation(
            symbol=signal['symbol'],
            screening_result=signal
        )

        status = "‚úÖ ENQUEUED" if enqueued else "‚è≠Ô∏è  SKIPPED"
        print(f"\n{status} - {signal['symbol']} (Score: {signal['score']})")
        print(f"   Reason: {reason}")

    # Show queue status
    status = queue.get_queue_status()
    print(f"\nüìä Queue Status:")
    print(f"   - Queue size: {status['queue_size']}")
    print(f"   - Validations today: {status['validations_today']}/{status['max_validations']}")
    print(f"   - Quota remaining: {status['quota_remaining']}")


def test_cache_operations(queue):
    """Test caching functionality."""
    print("\n" + "=" * 60)
    print("TEST 4: Cache Operations")
    print("=" * 60)

    # Create test validation result
    validation_result = {
        'decision': 'buy',
        'confidence': 0.85,
        'justification': 'Strong Elliott Wave structure with good risk/reward',
        'concerns': 'Watch for resistance at 1.0900',
        'enhanced_score': 130
    }

    # Cache the result
    cached = queue.cache_validation_result(
        symbol="EUR/USD",
        base_score=120,
        validation_result=validation_result,
        decision_time=2.5
    )

    print(f"‚úÖ Cached validation result for EUR/USD")
    print(f"   - Base score: {cached.base_score}")
    print(f"   - Enhanced score: {cached.enhanced_score}")
    print(f"   - Confidence: {cached.confidence:.0%}")
    print(f"   - Decision time: {cached.decision_time:.2f}s")

    # Try to retrieve from cache
    retrieved = queue.get_cached_result("EUR/USD", 120)

    if retrieved:
        print(f"\n‚úÖ Retrieved from cache successfully")
        print(f"   - Decision: {retrieved.decision}")
        print(f"   - Confidence: {retrieved.confidence:.0%}")
        print(f"   - Enhanced score: {retrieved.enhanced_score}")
    else:
        print(f"\n‚ùå Failed to retrieve from cache")

    # Try with different score (should miss cache)
    missed = queue.get_cached_result("EUR/USD", 125)
    if missed:
        print(f"\n‚ö†Ô∏è  Unexpected cache hit for different score")
    else:
        print(f"\n‚úÖ Cache miss for different score (expected)")


def test_performance_tracking(queue):
    """Test performance statistics tracking."""
    print("\n" + "=" * 60)
    print("TEST 5: Performance Tracking")
    print("=" * 60)

    # Add some test validation results
    test_results = [
        {
            'symbol': 'EUR/USD',
            'base_score': 120,
            'validation': {
                'decision': 'buy',
                'confidence': 0.85,
                'justification': 'Strong setup',
                'concerns': '',
                'enhanced_score': 130
            },
            'decision_time': 2.5
        },
        {
            'symbol': 'GBP/USD',
            'base_score': 95,
            'validation': {
                'decision': 'sell',
                'confidence': 0.75,
                'justification': 'Decent signal',
                'concerns': 'Some volatility concerns',
                'enhanced_score': 105
            },
            'decision_time': 3.2
        },
        {
            'symbol': 'XAU/USD',
            'base_score': 150,
            'validation': {
                'decision': 'buy',
                'confidence': 0.92,
                'justification': 'Excellent Elliott Wave pattern',
                'concerns': '',
                'enhanced_score': 160
            },
            'decision_time': 2.8
        }
    ]

    for result in test_results:
        queue.cache_validation_result(
            symbol=result['symbol'],
            base_score=result['base_score'],
            validation_result=result['validation'],
            decision_time=result['decision_time']
        )

    # Get performance stats
    perf = queue.get_performance_stats()

    print(f"\nüìä Performance Statistics:")
    print(f"   - Total validations: {perf['total_validations']}")
    print(f"   - Avg confidence: {perf['avg_confidence']:.0%}")
    print(f"   - Avg enhancement: +{perf['avg_enhancement']:.1f} points")
    print(f"   - Avg decision time: {perf['avg_decision_time']:.2f}s")
    print(f"   - High confidence rate: {perf['high_confidence_rate']:.0%}")

    if perf['validation_outcomes']:
        print(f"\nüìà Validation Outcomes:")
        for outcome, count in perf['validation_outcomes'].items():
            print(f"   - {outcome}: {count}")


def test_state_persistence(queue):
    """Test state persistence to JSON file."""
    print("\n" + "=" * 60)
    print("TEST 6: State Persistence")
    print("=" * 60)

    # Save current state
    queue._save_state()
    print(f"‚úÖ State saved to: {queue.state_file}")

    # Create a new queue instance (should load saved state)
    new_queue = ClaudeValidationQueue(
        max_validations_per_day=20,
        min_score_for_validation=85,
        cache_dir="data/test_claude_cache"
    )

    print(f"\n‚úÖ New queue instance created (loaded from state)")

    # Compare states
    old_status = queue.get_queue_status()
    new_status = new_queue.get_queue_status()

    print(f"\nüìä State Comparison:")
    print(f"   - Old validations today: {old_status['validations_today']}")
    print(f"   - New validations today: {new_status['validations_today']}")
    print(f"   - Old cache size: {old_status['cache_size']}")
    print(f"   - New cache size: {new_status['cache_size']}")

    if old_status['validations_today'] == new_status['validations_today']:
        print(f"\n‚úÖ State persisted correctly!")
    else:
        print(f"\n‚ö†Ô∏è  State mismatch detected")


def run_all_tests():
    """Run all validation queue tests."""
    print("\n")
    print("=" * 60)
    print("üß™ CLAUDE VALIDATION QUEUE - INTEGRATION TESTS")
    print("=" * 60)

    try:
        # Run tests
        queue = test_queue_creation()
        test_should_validate(queue)
        test_enqueue_validation(queue)
        test_cache_operations(queue)
        test_performance_tracking(queue)
        test_state_persistence(queue)

        print("\n" + "=" * 60)
        print("‚úÖ ALL TESTS PASSED")
        print("=" * 60)
        print("\nClaude Validation Queue is ready for production!")
        print("\nNext steps:")
        print("1. Start the backend: python src/web_backend.py")
        print("2. Open dashboard: http://localhost:5000/dashboard")
        print("3. Navigate to Claude AI tab to configure settings")
        print("4. Run signal scans with Claude validation enabled")

    except Exception as e:
        print("\n" + "=" * 60)
        print("‚ùå TEST FAILED")
        print("=" * 60)
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()
        return False

    return True


if __name__ == "__main__":
    success = run_all_tests()
    sys.exit(0 if success else 1)
