"""
Unit tests for signal_history.py module.

Tests the SignalHistoryManager class which manages trading signal history
in SQLite database with performance tracking and A/B testing capabilities.
"""

import pytest
import sqlite3
from datetime import datetime, timezone, timedelta
from signal_history import SignalHistoryManager


class TestSignalHistoryManager:
    """Test suite for SignalHistoryManager class."""

    def test_initialization(self, temp_db_path):
        """Test SignalHistoryManager initialization and database creation."""
        manager = SignalHistoryManager(db_path=temp_db_path)

        # Database file should exist
        import os
        assert os.path.exists(temp_db_path)

        # Should have signals table
        with sqlite3.connect(temp_db_path) as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name='signals'")
            result = cursor.fetchone()
            assert result is not None

    def test_add_signal(self, temp_db_path):
        """Test adding a new trading signal to database."""
        manager = SignalHistoryManager(db_path=temp_db_path)

        signal_id = manager.add_signal(
            symbol="EUR/USD",
            direction="LONG",
            score=95,
            current_price=1.1000,
            entry_price=1.1000,
            stop_loss=1.0950,
            take_profit=1.1100,
            leverage=10,
            score_breakdown={"elliott_wave": 50, "ict": 45},
            indicators={"rsi": 65, "ema_8": 1.0990},
            timeframe="1h"
        )

        # Should return a signal ID
        assert signal_id is not None
        assert isinstance(signal_id, str)
        assert len(signal_id) > 0

        # Signal should be in database
        signals = manager.get_signals(signal_id=signal_id)
        assert len(signals) == 1
        assert signals[0]['symbol'] == "EUR/USD"
        assert signals[0]['direction'] == "LONG"
        assert signals[0]['score'] == 95

    def test_add_signal_with_claude_validation(self, temp_db_path):
        """Test adding a signal with Claude validation data."""
        manager = SignalHistoryManager(db_path=temp_db_path)

        signal_id = manager.add_signal(
            symbol="GBP/USD",
            direction="SHORT",
            score=88,
            current_price=1.2500,
            entry_price=1.2500,
            stop_loss=1.2550,
            take_profit=1.2400,
            leverage=5,
            score_breakdown={"elliott_wave": 44, "ict": 44},
            indicators={"rsi": 35},
            timeframe="4h",
            enhanced_score=105,
            claude_confidence=85,
            claude_justification="Strong bearish Elliott Wave pattern",
            data_quality_score=95
        )

        # Retrieve signal
        signals = manager.get_signals(signal_id=signal_id)
        signal = signals[0]

        # Should have Claude validation data
        assert signal['claude_validated'] == 1
        assert signal['enhanced_score'] == 105
        assert signal['claude_confidence'] == 85
        assert "bearish" in signal['claude_justification']

    def test_get_signals_with_filters(self, temp_db_path):
        """Test retrieving signals with various filters."""
        manager = SignalHistoryManager(db_path=temp_db_path)

        # Add multiple signals
        symbols = ["EUR/USD", "GBP/USD", "EUR/USD", "XAU/USD"]
        directions = ["LONG", "SHORT", "LONG", "LONG"]

        for symbol, direction in zip(symbols, directions):
            manager.add_signal(
                symbol=symbol,
                direction=direction,
                score=90,
                current_price=1.1000,
                entry_price=1.1000,
                stop_loss=1.0950,
                take_profit=1.1100,
                leverage=10,
                score_breakdown={},
                indicators={},
                timeframe="1h"
            )

        # Test symbol filter
        eur_signals = manager.get_signals(symbol="EUR/USD")
        assert len(eur_signals) == 2

        # Test limit
        limited_signals = manager.get_signals(limit=2)
        assert len(limited_signals) == 2

        # Test days filter
        all_signals = manager.get_signals(days=1)
        assert len(all_signals) == 4

    def test_update_signal_outcome_win(self, temp_db_path):
        """Test updating signal outcome for a winning trade."""
        manager = SignalHistoryManager(db_path=temp_db_path)

        # Add signal
        signal_id = manager.add_signal(
            symbol="EUR/USD",
            direction="LONG",
            score=95,
            current_price=1.1000,
            entry_price=1.1000,
            stop_loss=1.0950,
            take_profit=1.1100,
            leverage=10,
            score_breakdown={},
            indicators={},
            timeframe="1h"
        )

        # Update with win outcome
        updated = manager.update_signal_outcome(
            signal_id=signal_id,
            outcome="closed_win",
            actual_exit_price=1.1100,
            notes="Hit take profit"
        )

        assert updated is True

        # Check updated signal
        signals = manager.get_signals(signal_id=signal_id)
        signal = signals[0]

        assert signal['status'] == "closed_win"
        assert signal['actual_exit_price'] == 1.1100
        assert signal['pnl_percentage'] is not None
        assert signal['pnl_percentage'] > 0  # Should be profit

    def test_update_signal_outcome_loss(self, temp_db_path):
        """Test updating signal outcome for a losing trade."""
        manager = SignalHistoryManager(db_path=temp_db_path)

        # Add signal
        signal_id = manager.add_signal(
            symbol="EUR/USD",
            direction="LONG",
            score=85,
            current_price=1.1000,
            entry_price=1.1000,
            stop_loss=1.0950,
            take_profit=1.1100,
            leverage=10,
            score_breakdown={},
            indicators={},
            timeframe="1h"
        )

        # Update with loss outcome
        updated = manager.update_signal_outcome(
            signal_id=signal_id,
            outcome="stopped_out",
            actual_exit_price=1.0950,
            notes="Hit stop loss"
        )

        assert updated is True

        # Check updated signal
        signals = manager.get_signals(signal_id=signal_id)
        signal = signals[0]

        assert signal['status'] == "stopped_out"
        assert signal['pnl_percentage'] is not None
        assert signal['pnl_percentage'] < 0  # Should be loss

    def test_get_performance_stats(self, temp_db_path):
        """Test getting performance statistics."""
        manager = SignalHistoryManager(db_path=temp_db_path)

        # Add and close multiple signals
        # 3 wins, 2 losses
        for i in range(5):
            signal_id = manager.add_signal(
                symbol="EUR/USD",
                direction="LONG",
                score=90,
                current_price=1.1000,
                entry_price=1.1000,
                stop_loss=1.0950,
                take_profit=1.1100,
                leverage=10,
                score_breakdown={},
                indicators={},
                timeframe="1h",
                enhanced_score=100 if i < 3 else None,  # First 3 are Claude-validated
                claude_confidence=85 if i < 3 else None
            )

            # Close first 3 as wins, last 2 as losses
            if i < 3:
                manager.update_signal_outcome(
                    signal_id=signal_id,
                    outcome="closed_win",
                    actual_exit_price=1.1100
                )
            else:
                manager.update_signal_outcome(
                    signal_id=signal_id,
                    outcome="stopped_out",
                    actual_exit_price=1.0950
                )

        # Get performance stats
        stats = manager.get_performance_stats()

        # Check overall stats
        assert stats['total_signals'] == 5
        assert stats['total_closed'] == 5
        assert stats['total_wins'] == 3
        assert stats['total_losses'] == 2
        assert stats['win_rate'] == 60.0

        # Check A/B testing stats
        ab_testing = stats['ab_testing']
        assert ab_testing['claude_validated']['count'] == 3
        assert ab_testing['screener_only']['count'] == 2

    def test_get_performance_stats_by_symbol(self, temp_db_path):
        """Test getting performance statistics filtered by symbol."""
        manager = SignalHistoryManager(db_path=temp_db_path)

        # Add signals for different symbols
        for symbol in ["EUR/USD", "EUR/USD", "GBP/USD"]:
            signal_id = manager.add_signal(
                symbol=symbol,
                direction="LONG",
                score=90,
                current_price=1.1000,
                entry_price=1.1000,
                stop_loss=1.0950,
                take_profit=1.1100,
                leverage=10,
                score_breakdown={},
                indicators={},
                timeframe="1h"
            )

            manager.update_signal_outcome(
                signal_id=signal_id,
                outcome="closed_win",
                actual_exit_price=1.1100
            )

        # Get stats for EUR/USD only
        stats = manager.get_performance_stats(symbol="EUR/USD")
        assert stats['total_signals'] == 2

        # Get stats for all symbols
        stats_all = manager.get_performance_stats()
        assert stats_all['total_signals'] == 3

    def test_get_historical_timeline(self, temp_db_path):
        """Test getting historical timeline with grouped statistics."""
        manager = SignalHistoryManager(db_path=temp_db_path)

        # Add signals spread over time
        for i in range(10):
            manager.add_signal(
                symbol="EUR/USD",
                direction="LONG",
                score=90,
                current_price=1.1000,
                entry_price=1.1000,
                stop_loss=1.0950,
                take_profit=1.1100,
                leverage=10,
                score_breakdown={},
                indicators={},
                timeframe="1h"
            )

        # Get timeline
        timeline = manager.get_historical_timeline(days=7, group_by='day')

        # Should have timeline data
        assert isinstance(timeline, list)
        assert len(timeline) > 0

    def test_pnl_calculation_long_trade(self, temp_db_path):
        """Test PnL calculation for long trades."""
        manager = SignalHistoryManager(db_path=temp_db_path)

        # Long trade: Entry 1.1000, Exit 1.1100, Leverage 10x
        signal_id = manager.add_signal(
            symbol="EUR/USD",
            direction="LONG",
            score=95,
            current_price=1.1000,
            entry_price=1.1000,
            stop_loss=1.0950,
            take_profit=1.1100,
            leverage=10,
            score_breakdown={},
            indicators={},
            timeframe="1h"
        )

        manager.update_signal_outcome(
            signal_id=signal_id,
            outcome="closed_win",
            actual_exit_price=1.1100
        )

        # Get signal
        signals = manager.get_signals(signal_id=signal_id)
        signal = signals[0]

        # PnL should be positive
        # (1.1100 - 1.1000) / 1.1000 * 100 * 10 = 9.09%
        assert signal['pnl_percentage'] > 0
        assert signal['pnl_percentage'] == pytest.approx(9.09, abs=0.1)

    def test_pnl_calculation_short_trade(self, temp_db_path):
        """Test PnL calculation for short trades."""
        manager = SignalHistoryManager(db_path=temp_db_path)

        # Short trade: Entry 1.2500, Exit 1.2400, Leverage 5x
        signal_id = manager.add_signal(
            symbol="GBP/USD",
            direction="SHORT",
            score=88,
            current_price=1.2500,
            entry_price=1.2500,
            stop_loss=1.2550,
            take_profit=1.2400,
            leverage=5,
            score_breakdown={},
            indicators={},
            timeframe="4h"
        )

        manager.update_signal_outcome(
            signal_id=signal_id,
            outcome="closed_win",
            actual_exit_price=1.2400
        )

        # Get signal
        signals = manager.get_signals(signal_id=signal_id)
        signal = signals[0]

        # PnL should be positive for short winning trade
        # (1.2500 - 1.2400) / 1.2500 * 100 * 5 = 4.0%
        assert signal['pnl_percentage'] > 0
        assert signal['pnl_percentage'] == pytest.approx(4.0, abs=0.1)

    def test_signal_status_transitions(self, temp_db_path):
        """Test signal status transitions from pending to closed."""
        manager = SignalHistoryManager(db_path=temp_db_path)

        # Add signal (starts as pending)
        signal_id = manager.add_signal(
            symbol="EUR/USD",
            direction="LONG",
            score=95,
            current_price=1.1000,
            entry_price=1.1000,
            stop_loss=1.0950,
            take_profit=1.1100,
            leverage=10,
            score_breakdown={},
            indicators={},
            timeframe="1h"
        )

        # Check initial status
        signals = manager.get_signals(signal_id=signal_id)
        assert signals[0]['status'] == "pending"

        # Update to closed_win
        manager.update_signal_outcome(
            signal_id=signal_id,
            outcome="closed_win",
            actual_exit_price=1.1100
        )

        # Check updated status
        signals = manager.get_signals(signal_id=signal_id)
        assert signals[0]['status'] == "closed_win"

    def test_invalid_signal_update(self, temp_db_path):
        """Test updating non-existent signal returns False."""
        manager = SignalHistoryManager(db_path=temp_db_path)

        # Try to update signal that doesn't exist
        updated = manager.update_signal_outcome(
            signal_id="nonexistent_id",
            outcome="closed_win",
            actual_exit_price=1.1100
        )

        assert updated is False

    def test_ab_testing_comparison(self, temp_db_path):
        """Test A/B testing comparison between Claude and screener-only signals."""
        manager = SignalHistoryManager(db_path=temp_db_path)

        # Add Claude-validated winning trades
        for i in range(3):
            signal_id = manager.add_signal(
                symbol="EUR/USD",
                direction="LONG",
                score=90,
                current_price=1.1000,
                entry_price=1.1000,
                stop_loss=1.0950,
                take_profit=1.1100,
                leverage=10,
                score_breakdown={},
                indicators={},
                timeframe="1h",
                enhanced_score=100,
                claude_confidence=85
            )
            manager.update_signal_outcome(signal_id, "closed_win", 1.1100)

        # Add screener-only mixed results
        for i in range(4):
            signal_id = manager.add_signal(
                symbol="EUR/USD",
                direction="LONG",
                score=85,
                current_price=1.1000,
                entry_price=1.1000,
                stop_loss=1.0950,
                take_profit=1.1100,
                leverage=10,
                score_breakdown={},
                indicators={},
                timeframe="1h"
            )
            outcome = "closed_win" if i < 2 else "stopped_out"
            exit_price = 1.1100 if i < 2 else 1.0950
            manager.update_signal_outcome(signal_id, outcome, exit_price)

        # Get performance stats
        stats = manager.get_performance_stats()
        ab_testing = stats['ab_testing']

        # Claude should have 100% win rate (3/3)
        assert ab_testing['claude_validated']['win_rate'] == 100.0

        # Screener should have 50% win rate (2/4)
        assert ab_testing['screener_only']['win_rate'] == 50.0

        # Improvement should be positive
        assert ab_testing['improvement']['win_rate'] > 0
