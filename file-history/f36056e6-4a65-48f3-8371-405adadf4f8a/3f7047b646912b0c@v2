"""
Claude Validation Queue System for Elliott Wave Trading Bot.

Manages Claude API validation requests with:
- Rate limiting (max validations per day)
- Priority queue (highest scores first)
- Result caching (avoid duplicate validations)
- Async validation support
- Performance tracking

Features:
- Smart validation triggering (only high-score signals)
- Daily quota management
- Result persistence
- Performance metrics (win rate, confidence, etc.)
"""

import json
import logging
from datetime import datetime, timezone, timedelta
from typing import Dict, List, Optional, Tuple
from pathlib import Path
from dataclasses import dataclass, asdict
from collections import deque
import hashlib

logger = logging.getLogger(__name__)


@dataclass
class ValidationResult:
    """Result from Claude validation."""
    symbol: str
    timestamp: str
    base_score: int
    enhanced_score: int
    signal: str  # buy/sell/hold
    confidence: float
    justification: str
    concerns: str
    decision_time_seconds: float
    prompts_used: Dict[str, str]


@dataclass
class ValidationRequest:
    """Request for Claude validation."""
    symbol: str
    screening_result: Dict
    priority: int  # Higher = more urgent (based on score)
    timestamp: str
    request_hash: str  # To detect duplicates


class ClaudeValidationQueue:
    """
    Manages Claude validation requests with rate limiting and prioritization.

    Features:
    - Priority queue (highest scores first)
    - Daily quota management (max validations per day)
    - Result caching (1 hour TTL per symbol)
    - Performance tracking
    - Async validation support
    """

    def __init__(
        self,
        max_validations_per_day: int = 20,
        min_score_for_validation: int = 85,
        cache_dir: str = "data/claude_cache"
    ):
        """
        Initialize validation queue.

        Args:
            max_validations_per_day: Maximum Claude validations per day
            min_score_for_validation: Minimum signal score to trigger validation
            cache_dir: Directory for caching validation results
        """
        self.max_validations = max_validations_per_day
        self.min_score = min_score_for_validation
        self.cache_dir = Path(cache_dir)
        self.cache_dir.mkdir(parents=True, exist_ok=True)

        # Queue of pending validation requests
        self.queue: deque[ValidationRequest] = deque()

        # Cache: {symbol_hash: (result, timestamp)}
        self.cache: Dict[str, Tuple[ValidationResult, datetime]] = {}
        self.cache_ttl = timedelta(hours=1)

        # Daily tracking
        self.validations_today = 0
        self.last_reset = datetime.now(timezone.utc).date()

        # Performance tracking
        self.performance_history: List[Dict] = []

        # Load persisted state
        self._load_state()

    def should_validate(
        self,
        symbol: str,
        score: int,
        data_quality: Optional[int] = None
    ) -> Tuple[bool, str]:
        """
        Determine if a signal should be validated by Claude.

        Args:
            symbol: Asset symbol
            score: Signal score
            data_quality: Optional data quality score (0-100)

        Returns:
            (should_validate, reason) tuple
        """
        # Reset daily counter if new day
        self._check_daily_reset()

        # Check if daily limit reached
        if self.validations_today >= self.max_validations:
            return False, f"Daily limit reached ({self.max_validations})"

        # Check minimum score threshold
        if score < self.min_score:
            return False, f"Score {score} < {self.min_score} (minimum)"

        # Check data quality if provided
        if data_quality is not None and data_quality < 70:
            return False, f"Data quality {data_quality}% too low (need 70%+)"

        # Check cache (avoid duplicate validations within TTL)
        cache_key = self._get_cache_key(symbol, score)
        if cache_key in self.cache:
            cached_result, cached_time = self.cache[cache_key]
            age = datetime.now(timezone.utc) - cached_time
            if age < self.cache_ttl:
                return False, f"Recently validated ({int(age.total_seconds() / 60)}m ago)"

        return True, "Validation approved"

    def enqueue_validation(
        self,
        symbol: str,
        screening_result: Dict
    ) -> Tuple[bool, str]:
        """
        Add a validation request to the queue.

        Args:
            symbol: Asset symbol
            screening_result: Screening result dict

        Returns:
            (success, message) tuple
        """
        score = screening_result.get('score', 0)

        # Check if should validate
        should, reason = self.should_validate(symbol, score)
        if not should:
            return False, reason

        # Create request
        request = ValidationRequest(
            symbol=symbol,
            screening_result=screening_result,
            priority=score,  # Higher score = higher priority
            timestamp=datetime.now(timezone.utc).isoformat(),
            request_hash=self._get_request_hash(symbol, screening_result)
        )

        # Check for duplicate in queue
        if any(r.request_hash == request.request_hash for r in self.queue):
            return False, "Already in queue"

        # Add to queue (will be sorted by priority)
        self.queue.append(request)
        self._sort_queue()

        logger.info(f"Enqueued validation for {symbol} (score: {score}, position: {len(self.queue)})")

        return True, f"Enqueued (position {len(self.queue)})"

    def get_next_request(self) -> Optional[ValidationRequest]:
        """
        Get the next highest-priority validation request.

        Returns:
            ValidationRequest or None if queue is empty
        """
        if not self.queue:
            return None

        # Queue is sorted by priority (highest first)
        return self.queue.popleft()

    def cache_validation_result(
        self,
        symbol: str,
        base_score: int,
        validation_result: Dict,
        decision_time: float
    ) -> ValidationResult:
        """
        Cache a validation result.

        Args:
            symbol: Asset symbol
            base_score: Original screening score
            validation_result: Claude's decision dict
            decision_time: Time taken for validation (seconds)

        Returns:
            ValidationResult object
        """
        # Calculate enhanced score
        enhanced_score = self._calculate_enhanced_score(base_score, validation_result)

        # Create result object
        result = ValidationResult(
            symbol=symbol,
            timestamp=datetime.now(timezone.utc).isoformat(),
            base_score=base_score,
            enhanced_score=enhanced_score,
            signal=validation_result.get('signal', 'hold'),
            confidence=validation_result.get('confidence', 0),
            justification=validation_result.get('justification', ''),
            concerns=validation_result.get('concerns', ''),
            decision_time_seconds=decision_time,
            prompts_used=validation_result.get('_prompts', {})
        )

        # Cache it
        cache_key = self._get_cache_key(symbol, base_score)
        self.cache[cache_key] = (result, datetime.now(timezone.utc))

        # Update daily counter
        self.validations_today += 1

        # Track performance
        self._track_performance(result)

        # Persist state
        self._save_state()

        logger.info(
            f"Cached validation for {symbol}: {base_score} → {enhanced_score} "
            f"({validation_result.get('signal')} @ {validation_result.get('confidence', 0):.0%})"
        )

        return result

    def get_cached_result(
        self,
        symbol: str,
        score: int
    ) -> Optional[ValidationResult]:
        """
        Get cached validation result if available and not expired.

        Args:
            symbol: Asset symbol
            score: Signal score

        Returns:
            ValidationResult or None if not cached/expired
        """
        cache_key = self._get_cache_key(symbol, score)
        if cache_key not in self.cache:
            return None

        result, cached_time = self.cache[cache_key]
        age = datetime.now(timezone.utc) - cached_time

        if age >= self.cache_ttl:
            # Expired
            del self.cache[cache_key]
            return None

        return result

    def get_queue_status(self) -> Dict:
        """
        Get current queue status.

        Returns:
            Status dict with queue info
        """
        self._check_daily_reset()

        return {
            'queue_length': len(self.queue),
            'validations_today': self.validations_today,
            'validations_remaining': self.max_validations - self.validations_today,
            'daily_limit': self.max_validations,
            'cache_size': len(self.cache),
            'next_reset': (datetime.now(timezone.utc).date() + timedelta(days=1)).isoformat(),
            'pending_requests': [
                {
                    'symbol': req.symbol,
                    'score': req.screening_result.get('score'),
                    'priority': req.priority,
                    'timestamp': req.timestamp
                }
                for req in list(self.queue)[:5]  # Show top 5
            ]
        }

    def get_performance_stats(self) -> Dict:
        """
        Get performance statistics.

        Returns:
            Performance stats dict
        """
        if not self.performance_history:
            return {
                'total_validations': 0,
                'avg_confidence': 0,
                'avg_enhancement': 0,
                'signal_distribution': {},
                'avg_decision_time': 0
            }

        total = len(self.performance_history)

        # Calculate stats
        avg_confidence = sum(p['confidence'] for p in self.performance_history) / total
        avg_enhancement = sum(p['enhancement'] for p in self.performance_history) / total
        avg_decision_time = sum(p['decision_time'] for p in self.performance_history) / total

        # Signal distribution
        signals = [p['signal'] for p in self.performance_history]
        signal_dist = {
            'buy': signals.count('buy'),
            'sell': signals.count('sell'),
            'hold': signals.count('hold')
        }

        return {
            'total_validations': total,
            'avg_confidence': round(avg_confidence, 3),
            'avg_enhancement': round(avg_enhancement, 1),
            'signal_distribution': signal_dist,
            'avg_decision_time': round(avg_decision_time, 2),
            'recent_validations': self.performance_history[-10:]  # Last 10
        }

    def clear_cache(self):
        """Clear the validation cache."""
        self.cache.clear()
        logger.info("Validation cache cleared")

    def clear_queue(self):
        """Clear the validation queue."""
        self.queue.clear()
        logger.info("Validation queue cleared")

    def reset_daily_counter(self):
        """Manually reset the daily validation counter."""
        self.validations_today = 0
        self.last_reset = datetime.now(timezone.utc).date()
        logger.info("Daily validation counter reset")

    def update_settings(
        self,
        max_validations: Optional[int] = None,
        min_score: Optional[int] = None
    ):
        """
        Update queue settings.

        Args:
            max_validations: New max validations per day
            min_score: New minimum score threshold
        """
        if max_validations is not None:
            self.max_validations = max_validations
            logger.info(f"Max validations updated: {max_validations}")

        if min_score is not None:
            self.min_score = min_score
            logger.info(f"Min score updated: {min_score}")

        self._save_state()

    # ========================================================================
    # PRIVATE METHODS
    # ========================================================================

    def _check_daily_reset(self):
        """Check if daily counter should be reset."""
        today = datetime.now(timezone.utc).date()
        if today > self.last_reset:
            self.validations_today = 0
            self.last_reset = today
            logger.info("Daily validation counter auto-reset")

    def _sort_queue(self):
        """Sort queue by priority (highest first)."""
        self.queue = deque(sorted(self.queue, key=lambda r: r.priority, reverse=True))

    def _get_cache_key(self, symbol: str, score: int) -> str:
        """Generate cache key for a symbol/score combo."""
        # Round score to nearest 5 to group similar scores
        rounded_score = (score // 5) * 5
        return f"{symbol}:{rounded_score}"

    def _get_request_hash(self, symbol: str, screening_result: Dict) -> str:
        """Generate unique hash for a validation request."""
        # Use symbol + score + direction + timestamp (hour precision)
        data = f"{symbol}:{screening_result.get('score')}:{screening_result.get('direction')}"
        data += f":{datetime.now(timezone.utc).strftime('%Y%m%d%H')}"
        return hashlib.md5(data.encode()).hexdigest()

    def _calculate_enhanced_score(self, base_score: int, validation_result: Dict) -> int:
        """Calculate enhanced score with Claude bonus."""
        enhanced = base_score

        signal = validation_result.get('signal', 'hold')
        confidence = validation_result.get('confidence', 0)
        concerns = validation_result.get('concerns', '')

        # Bonus for actionable signals with confidence
        if signal in ['buy', 'sell']:
            if confidence >= 0.8:
                enhanced += 10
            elif confidence >= 0.6:
                enhanced += 5

        # Penalty for concerns
        if concerns and len(concerns) > 20:
            enhanced -= 5

        # Cap at 194
        return min(enhanced, 194)

    def _track_performance(self, result: ValidationResult):
        """Track performance metrics."""
        enhancement = result.enhanced_score - result.base_score

        perf_entry = {
            'timestamp': result.timestamp,
            'symbol': result.symbol,
            'base_score': result.base_score,
            'enhanced_score': result.enhanced_score,
            'enhancement': enhancement,
            'signal': result.signal,
            'confidence': result.confidence,
            'decision_time': result.decision_time_seconds
        }

        self.performance_history.append(perf_entry)

        # Keep only last 100 entries
        if len(self.performance_history) > 100:
            self.performance_history = self.performance_history[-100:]

    def _save_state(self):
        """Persist queue state to disk."""
        try:
            state_file = self.cache_dir / 'queue_state.json'

            state = {
                'validations_today': self.validations_today,
                'last_reset': self.last_reset.isoformat(),
                'max_validations': self.max_validations,
                'min_score': self.min_score,
                'performance_history': self.performance_history[-100:]  # Last 100
            }

            with open(state_file, 'w') as f:
                json.dump(state, f, indent=2)

        except Exception as e:
            logger.error(f"Error saving queue state: {e}")

    def _load_state(self):
        """Load persisted queue state from disk."""
        try:
            state_file = self.cache_dir / 'queue_state.json'

            if not state_file.exists():
                return

            with open(state_file, 'r') as f:
                state = json.load(f)

            # Load state
            self.validations_today = state.get('validations_today', 0)

            last_reset_str = state.get('last_reset')
            if last_reset_str:
                self.last_reset = datetime.fromisoformat(last_reset_str).date()

            self.max_validations = state.get('max_validations', self.max_validations)
            self.min_score = state.get('min_score', self.min_score)
            self.performance_history = state.get('performance_history', [])

            # Check if should reset (new day)
            self._check_daily_reset()

            logger.info(
                f"Loaded queue state: {self.validations_today}/{self.max_validations} "
                f"validations used today"
            )

        except Exception as e:
            logger.error(f"Error loading queue state: {e}")


def test_validation_queue():
    """Test the validation queue system."""
    import sys

    logging.basicConfig(level=logging.INFO)
    logger.setLevel(logging.DEBUG)
    handler = logging.StreamHandler(sys.stdout)
    handler.setFormatter(logging.Formatter('%(levelname)s - %(message)s'))
    logger.addHandler(handler)

    print("=" * 60)
    print("TESTING CLAUDE VALIDATION QUEUE")
    print("=" * 60)

    # Create queue
    queue = ClaudeValidationQueue(
        max_validations_per_day=20,
        min_score_for_validation=85
    )

    # Test 1: Check validation criteria
    print("\n" + "=" * 60)
    print("TEST 1: Validation Criteria")
    print("=" * 60)

    test_cases = [
        ("EUR/USD", 95, None, True, "High score"),
        ("GBP/USD", 70, None, False, "Score too low"),
        ("XAU/USD", 90, 60, False, "Data quality too low"),
        ("USOIL", 85, 95, True, "Meets all criteria"),
    ]

    for symbol, score, quality, expected, desc in test_cases:
        should, reason = queue.should_validate(symbol, score, quality)
        status = "✓" if should == expected else "✗"
        print(f"{status} {symbol} (score={score}, quality={quality}): {reason} ({desc})")

    # Test 2: Enqueue validations
    print("\n" + "=" * 60)
    print("TEST 2: Enqueue Validations")
    print("=" * 60)

    signals = [
        {"symbol": "EUR/USD", "score": 95, "direction": "long"},
        {"symbol": "GBP/USD", "score": 142, "direction": "short"},
        {"symbol": "XAU/USD", "score": 87, "direction": "long"},
    ]

    for signal in signals:
        success, msg = queue.enqueue_validation(signal['symbol'], signal)
        print(f"{'✓' if success else '✗'} {signal['symbol']}: {msg}")

    # Test 3: Queue status
    print("\n" + "=" * 60)
    print("TEST 3: Queue Status")
    print("=" * 60)

    status = queue.get_queue_status()
    print(f"Queue length: {status['queue_length']}")
    print(f"Validations today: {status['validations_today']}/{status['daily_limit']}")
    print(f"Remaining: {status['validations_remaining']}")
    print(f"Cache size: {status['cache_size']}")

    if status['pending_requests']:
        print("\nPending requests (by priority):")
        for req in status['pending_requests']:
            print(f"  - {req['symbol']}: score {req['score']} (priority {req['priority']})")

    # Test 4: Process queue
    print("\n" + "=" * 60)
    print("TEST 4: Process Queue")
    print("=" * 60)

    while True:
        request = queue.get_next_request()
        if not request:
            break

        print(f"\nProcessing: {request.symbol} (score: {request.priority})")

        # Simulate Claude validation
        mock_result = {
            'signal': 'buy',
            'confidence': 0.85,
            'justification': 'Strong setup with multiple confirmations',
            'concerns': '',
            '_prompts': {'system': 'test', 'user': 'test'}
        }

        result = queue.cache_validation_result(
            request.symbol,
            request.screening_result['score'],
            mock_result,
            decision_time=2.5
        )

        print(f"  → Enhanced: {result.base_score} → {result.enhanced_score}")
        print(f"  → Signal: {result.signal} @ {result.confidence:.0%}")

    # Test 5: Performance stats
    print("\n" + "=" * 60)
    print("TEST 5: Performance Stats")
    print("=" * 60)

    stats = queue.get_performance_stats()
    print(f"Total validations: {stats['total_validations']}")
    print(f"Avg confidence: {stats['avg_confidence']:.1%}")
    print(f"Avg enhancement: +{stats['avg_enhancement']:.1f} points")
    print(f"Avg decision time: {stats['avg_decision_time']:.2f}s")
    print(f"Signal distribution: {stats['signal_distribution']}")

    # Test 6: Cache retrieval
    print("\n" + "=" * 60)
    print("TEST 6: Cache Retrieval")
    print("=" * 60)

    for signal in signals:
        cached = queue.get_cached_result(signal['symbol'], signal['score'])
        if cached:
            print(f"✓ {signal['symbol']}: Cached result found (enhanced: {cached.enhanced_score})")
        else:
            print(f"✗ {signal['symbol']}: No cached result")

    print("\n" + "=" * 60)
    print("✓ ALL TESTS PASSED")
    print("=" * 60)

    return True


if __name__ == "__main__":
    success = test_validation_queue()
    exit(0 if success else 1)
