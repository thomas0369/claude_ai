"""
Unit tests for timeframe_engine.py module.

Tests the TimeframeEngine class which handles dynamic resampling
of 5-minute base data to any target timeframe.
"""

import pytest
import pandas as pd
import numpy as np
from datetime import datetime, timezone, timedelta
from timeframe_engine import TimeframeEngine


class TestTimeframeEngine:
    """Test suite for TimeframeEngine class."""

    def test_initialization(self):
        """Test TimeframeEngine initialization."""
        engine = TimeframeEngine()
        assert engine is not None
        assert hasattr(engine, 'resample_to_timeframe')
        assert hasattr(engine, 'get_available_timeframes')
        assert hasattr(engine, 'validate_timeframe')

    def test_resample_5min_to_15min(self, sample_ohlcv_data):
        """Test resampling from 5min to 15min."""
        engine = TimeframeEngine()

        # Resample to 15min
        resampled = engine.resample_to_timeframe(
            df=sample_ohlcv_data,
            target_timeframe_minutes=15
        )

        # Should have 1/3 the candles (5min -> 15min = 3x aggregation)
        expected_candles = len(sample_ohlcv_data) // 3
        assert len(resampled) == pytest.approx(expected_candles, abs=2)

        # Should have same columns
        assert list(resampled.columns) == list(sample_ohlcv_data.columns)

        # Volume should be summed
        original_total_volume = sample_ohlcv_data['volume'].sum()
        resampled_total_volume = resampled['volume'].sum()
        assert resampled_total_volume == pytest.approx(original_total_volume, rel=0.01)

    def test_resample_5min_to_1hour(self, sample_ohlcv_data):
        """Test resampling from 5min to 1 hour (60min)."""
        engine = TimeframeEngine()

        # Resample to 1 hour
        resampled = engine.resample_to_timeframe(
            df=sample_ohlcv_data,
            target_timeframe_minutes=60
        )

        # Should have 1/12 the candles (5min -> 60min = 12x aggregation)
        expected_candles = len(sample_ohlcv_data) // 12
        assert len(resampled) == pytest.approx(expected_candles, abs=2)

        # Verify OHLC logic
        for i in range(min(5, len(resampled))):
            candle = resampled.iloc[i]
            # High should be >= low
            assert candle['high'] >= candle['low']
            # Open and close should be between low and high
            assert candle['low'] <= candle['open'] <= candle['high']
            assert candle['low'] <= candle['close'] <= candle['high']

    def test_resample_5min_to_4hour(self, sample_ohlcv_data):
        """Test resampling from 5min to 4 hour (240min)."""
        engine = TimeframeEngine()

        # Resample to 4 hours
        resampled = engine.resample_to_timeframe(
            df=sample_ohlcv_data,
            target_timeframe_minutes=240
        )

        # Should have 1/48 the candles (5min -> 240min = 48x aggregation)
        expected_candles = len(sample_ohlcv_data) // 48
        assert len(resampled) == pytest.approx(expected_candles, abs=2)

    def test_resample_custom_timeframe_45min(self, sample_ohlcv_data):
        """Test resampling to custom 45min timeframe."""
        engine = TimeframeEngine()

        # Resample to 45min (9x aggregation)
        resampled = engine.resample_to_timeframe(
            df=sample_ohlcv_data,
            target_timeframe_minutes=45
        )

        # Should have approximately 1/9 the candles
        expected_candles = len(sample_ohlcv_data) // 9
        assert len(resampled) == pytest.approx(expected_candles, abs=2)

    def test_get_available_timeframes(self):
        """Test getting available timeframes based on data."""
        engine = TimeframeEngine()

        # Test with 500 candles of 5min data
        available = engine.get_available_timeframes(
            base_candles=500,
            base_timeframe_minutes=5,
            min_required_candles=200
        )

        # Should return list of timeframes
        assert isinstance(available, list)
        assert len(available) > 0

        # Should include 15min (500 -> 166 candles)
        assert 15 in available

        # Should NOT include very large timeframes that would give <200 candles
        # 500 5min candles = 2500 minutes total
        # For 200 candles minimum: max timeframe = 2500/200 = 12.5 minutes
        # So anything > 12.5 minutes should give < 200 candles
        # Actually 15min gives 166 candles, so it might be included depending on logic

    def test_validate_timeframe_success(self):
        """Test timeframe validation for valid timeframes."""
        engine = TimeframeEngine()

        # Valid timeframes should pass
        valid_timeframes = [5, 10, 15, 30, 45, 60, 120, 240]

        for tf in valid_timeframes:
            is_valid, message = engine.validate_timeframe(
                target_timeframe_minutes=tf,
                available_candles=500,
                base_timeframe_minutes=5,
                min_required_candles=200
            )

            # Some might be valid, some might not (depending on candle count)
            assert isinstance(is_valid, bool)
            assert isinstance(message, str)

    def test_validate_timeframe_failure(self):
        """Test timeframe validation for invalid timeframes."""
        engine = TimeframeEngine()

        # Invalid: target timeframe not divisible by base timeframe
        is_valid, message = engine.validate_timeframe(
            target_timeframe_minutes=7,  # 7 is not divisible by 5
            available_candles=500,
            base_timeframe_minutes=5,
            min_required_candles=200
        )

        assert is_valid is False
        assert 'divisible' in message.lower() or 'multiple' in message.lower()

    def test_validate_timeframe_insufficient_candles(self):
        """Test timeframe validation with insufficient candles."""
        engine = TimeframeEngine()

        # Invalid: would result in too few candles
        is_valid, message = engine.validate_timeframe(
            target_timeframe_minutes=240,  # 4 hours
            available_candles=100,  # Only 100 5min candles
            base_timeframe_minutes=5,
            min_required_candles=200
        )

        # 100 5min candles -> 2 4hour candles (100/48 = 2.08)
        assert is_valid is False

    def test_resample_preserves_data_integrity(self, sample_ohlcv_data):
        """Test that resampling preserves data integrity."""
        engine = TimeframeEngine()

        original_df = sample_ohlcv_data.copy()

        # Resample to 15min
        resampled = engine.resample_to_timeframe(
            df=original_df,
            target_timeframe_minutes=15
        )

        # Original data should not be modified
        pd.testing.assert_frame_equal(original_df, sample_ohlcv_data)

        # Resampled data should have datetime index
        assert isinstance(resampled.index, pd.DatetimeIndex)

        # All values should be numeric
        for col in ['open', 'high', 'low', 'close', 'volume']:
            assert pd.api.types.is_numeric_dtype(resampled[col])

        # No NaN values
        assert not resampled.isnull().any().any()

    def test_resample_empty_dataframe(self):
        """Test resampling handles empty DataFrame gracefully."""
        engine = TimeframeEngine()

        empty_df = pd.DataFrame(columns=['open', 'high', 'low', 'close', 'volume'])
        empty_df.index = pd.DatetimeIndex([])

        # Should handle empty data
        with pytest.raises(Exception) or empty_df.empty:
            result = engine.resample_to_timeframe(
                df=empty_df,
                target_timeframe_minutes=15
            )

            if not isinstance(result, type(None)):
                assert len(result) == 0

    def test_get_strategy_recommendations(self):
        """Test getting strategy-based timeframe recommendations."""
        engine = TimeframeEngine()

        # Test if method exists
        if hasattr(engine, 'get_strategy_recommendations'):
            recommendations = engine.get_strategy_recommendations(
                available_candles=500,
                base_timeframe_minutes=5
            )

            # Should return dict with different strategies
            assert isinstance(recommendations, dict)

            # Should have multiple strategy types
            possible_keys = ['aggressive', 'balanced', 'conservative', 'scalping', 'swing']
            has_strategy = any(key in recommendations for key in possible_keys)
            assert has_strategy

    def test_resample_multiple_timeframes(self, sample_ohlcv_data):
        """Test resampling to multiple timeframes in sequence."""
        engine = TimeframeEngine()

        timeframes = [15, 30, 60]
        results = {}

        for tf in timeframes:
            resampled = engine.resample_to_timeframe(
                df=sample_ohlcv_data,
                target_timeframe_minutes=tf
            )
            results[tf] = resampled

        # Each timeframe should have different number of candles
        assert len(results[15]) > len(results[30]) > len(results[60])

        # All should have same total volume (approximately)
        original_volume = sample_ohlcv_data['volume'].sum()
        for tf, df in results.items():
            assert df['volume'].sum() == pytest.approx(original_volume, rel=0.01)

    def test_resample_quality_validation(self, sample_ohlcv_data):
        """Test that resampled data meets quality standards."""
        engine = TimeframeEngine()

        # Resample to 1 hour
        resampled = engine.resample_to_timeframe(
            df=sample_ohlcv_data,
            target_timeframe_minutes=60
        )

        # Verify quality checks
        for i in range(len(resampled)):
            candle = resampled.iloc[i]

            # High >= all others
            assert candle['high'] >= candle['open']
            assert candle['high'] >= candle['close']
            assert candle['high'] >= candle['low']

            # Low <= all others
            assert candle['low'] <= candle['open']
            assert candle['low'] <= candle['close']
            assert candle['low'] <= candle['high']

            # Volume >= 0
            assert candle['volume'] >= 0

    def test_calculate_required_candles(self):
        """Test calculation of required base candles for target timeframe."""
        engine = TimeframeEngine()

        if hasattr(engine, 'calculate_required_candles'):
            # For 200 candles of 15min data from 5min base
            required = engine.calculate_required_candles(
                target_timeframe_minutes=15,
                target_candle_count=200,
                base_timeframe_minutes=5
            )

            # 15min / 5min = 3x aggregation
            # So need 200 * 3 = 600 base candles
            assert required == 600
