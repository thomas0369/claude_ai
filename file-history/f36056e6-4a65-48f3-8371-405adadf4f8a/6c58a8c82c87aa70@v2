"""
Export and Reporting Manager for Elliott Wave Trading Bot.

Provides comprehensive export functionality including:
- PDF report generation
- CSV data export
- Email notifications
- Scheduled report delivery
"""

import os
import csv
import json
import smtplib
from datetime import datetime, timezone, timedelta
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.application import MIMEApplication
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import logging

# PDF generation
from reportlab.lib.pagesizes import letter, A4
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
from reportlab.platypus import (
    SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle,
    PageBreak, Image
)
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT

logger = logging.getLogger(__name__)


class ExportManager:
    """
    Handles all export and reporting functionality.

    Features:
    - Generate PDF reports for trading signals
    - Export signal history to CSV
    - Send email notifications for high-score signals
    - Schedule automated performance reports
    """

    def __init__(
        self,
        output_dir: str = "exports",
        smtp_host: Optional[str] = None,
        smtp_port: int = 587,
        smtp_user: Optional[str] = None,
        smtp_password: Optional[str] = None,
        from_email: Optional[str] = None
    ):
        """
        Initialize Export Manager.

        Args:
            output_dir: Directory for export files
            smtp_host: SMTP server hostname
            smtp_port: SMTP server port
            smtp_user: SMTP username
            smtp_password: SMTP password
            from_email: Sender email address
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Email configuration
        self.smtp_host = smtp_host
        self.smtp_port = smtp_port
        self.smtp_user = smtp_user
        self.smtp_password = smtp_password
        self.from_email = from_email or smtp_user

        logger.info(f"Export Manager initialized (output_dir: {output_dir})")

    # ========================================================================
    # PDF REPORT GENERATION
    # ========================================================================

    def generate_signal_report_pdf(
        self,
        signal_data: Dict,
        filename: Optional[str] = None,
        include_charts: bool = False
    ) -> str:
        """
        Generate PDF report for a trading signal.

        Args:
            signal_data: Signal information dictionary
            filename: Output filename (optional, auto-generated if None)
            include_charts: Include technical analysis charts

        Returns:
            Path to generated PDF file
        """
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            symbol = signal_data.get('symbol', 'UNKNOWN').replace('/', '_')
            filename = f"signal_report_{symbol}_{timestamp}.pdf"

        filepath = self.output_dir / filename

        # Create PDF document
        doc = SimpleDocTemplate(
            str(filepath),
            pagesize=letter,
            rightMargin=72,
            leftMargin=72,
            topMargin=72,
            bottomMargin=18
        )

        # Build story (content)
        story = []
        styles = getSampleStyleSheet()

        # Title
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            fontSize=24,
            textColor=colors.HexColor('#1a1a1a'),
            spaceAfter=30,
            alignment=TA_CENTER
        )

        story.append(Paragraph("Elliott Wave Trading Signal Report", title_style))
        story.append(Spacer(1, 0.2 * inch))

        # Signal Summary
        story.append(Paragraph("Signal Summary", styles['Heading2']))
        story.append(Spacer(1, 0.1 * inch))

        summary_data = [
            ['Symbol', signal_data.get('symbol', 'N/A')],
            ['Direction', signal_data.get('direction', 'N/A')],
            ['Score', f"{signal_data.get('score', 0)}/194"],
            ['Timeframe', signal_data.get('timeframe', 'N/A')],
            ['Generated', datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')],
        ]

        summary_table = Table(summary_data, colWidths=[2 * inch, 4 * inch])
        summary_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#f0f0f0')),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
            ('GRID', (0, 0), (-1, -1), 1, colors.grey)
        ]))

        story.append(summary_table)
        story.append(Spacer(1, 0.3 * inch))

        # Trading Parameters
        story.append(Paragraph("Trading Parameters", styles['Heading2']))
        story.append(Spacer(1, 0.1 * inch))

        params_data = [
            ['Current Price', f"{signal_data.get('current_price', 0):.5f}"],
            ['Entry Price', f"{signal_data.get('entry_price', 0):.5f}"],
            ['Stop Loss', f"{signal_data.get('stop_loss', 0):.5f}"],
            ['Take Profit', f"{signal_data.get('take_profit', 0):.5f}"],
            ['Recommended Leverage', f"{signal_data.get('leverage', 1)}x"],
        ]

        params_table = Table(params_data, colWidths=[2 * inch, 4 * inch])
        params_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.HexColor('#f0f0f0')),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (0, -1), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
            ('GRID', (0, 0), (-1, -1), 1, colors.grey)
        ]))

        story.append(params_table)
        story.append(Spacer(1, 0.3 * inch))

        # Score Breakdown
        if 'score_breakdown' in signal_data:
            story.append(Paragraph("Score Breakdown", styles['Heading2']))
            story.append(Spacer(1, 0.1 * inch))

            breakdown = signal_data['score_breakdown']
            breakdown_data = [['Component', 'Score']]
            for component, score in breakdown.items():
                breakdown_data.append([component.replace('_', ' ').title(), str(score)])

            breakdown_table = Table(breakdown_data, colWidths=[3 * inch, 3 * inch])
            breakdown_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#4a90e2')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 12),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))

            story.append(breakdown_table)
            story.append(Spacer(1, 0.3 * inch))

        # Claude Validation (if available)
        if signal_data.get('claude_validated'):
            story.append(Paragraph("AI Validation Results", styles['Heading2']))
            story.append(Spacer(1, 0.1 * inch))

            validation_text = f"""
            <b>Enhanced Score:</b> {signal_data.get('enhanced_score', 'N/A')}/194<br/>
            <b>Confidence:</b> {signal_data.get('claude_confidence', 'N/A')}%<br/>
            <b>Justification:</b> {signal_data.get('claude_justification', 'N/A')}
            """

            story.append(Paragraph(validation_text, styles['Normal']))
            story.append(Spacer(1, 0.3 * inch))

        # Disclaimer
        story.append(PageBreak())
        story.append(Paragraph("Disclaimer", styles['Heading2']))
        disclaimer_text = """
        This report is generated automatically by the Elliott Wave Trading Bot v3.0.
        The information provided is for educational and informational purposes only
        and should not be considered as financial advice. Trading involves substantial
        risk of loss. Past performance is not indicative of future results.
        Always conduct your own research and consult with a qualified financial advisor
        before making any trading decisions.
        """
        story.append(Paragraph(disclaimer_text, styles['Normal']))

        # Build PDF
        doc.build(story)

        logger.info(f"PDF report generated: {filepath}")
        return str(filepath)

    def generate_performance_report_pdf(
        self,
        performance_data: Dict,
        signals: List[Dict],
        filename: Optional[str] = None
    ) -> str:
        """
        Generate PDF performance report.

        Args:
            performance_data: Performance statistics dictionary
            signals: List of recent signals
            filename: Output filename (optional)

        Returns:
            Path to generated PDF file
        """
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"performance_report_{timestamp}.pdf"

        filepath = self.output_dir / filename

        # Create PDF document
        doc = SimpleDocTemplate(str(filepath), pagesize=letter)
        story = []
        styles = getSampleStyleSheet()

        # Title
        story.append(Paragraph("Trading Performance Report", styles['Title']))
        story.append(Spacer(1, 0.3 * inch))

        # Performance Summary
        story.append(Paragraph("Performance Summary", styles['Heading2']))
        story.append(Spacer(1, 0.1 * inch))

        perf_data = [
            ['Metric', 'Value'],
            ['Total Signals', str(performance_data.get('total_signals', 0))],
            ['Win Rate', f"{performance_data.get('win_rate', 0):.1f}%"],
            ['Average PnL', f"{performance_data.get('avg_pnl_percentage', 0):+.2f}%"],
            ['Total Wins', str(performance_data.get('total_wins', 0))],
            ['Total Losses', str(performance_data.get('total_losses', 0))],
        ]

        perf_table = Table(perf_data, colWidths=[3 * inch, 3 * inch])
        perf_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#4a90e2')),
            ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
            ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
            ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))

        story.append(perf_table)
        story.append(Spacer(1, 0.3 * inch))

        # A/B Testing Results
        if 'ab_testing' in performance_data:
            story.append(Paragraph("A/B Testing: Claude vs Screener", styles['Heading2']))
            story.append(Spacer(1, 0.1 * inch))

            ab_data = [
                ['', 'Claude Validated', 'Screener Only'],
                ['Win Rate',
                 f"{performance_data['ab_testing']['claude_validated'].get('win_rate', 0):.1f}%",
                 f"{performance_data['ab_testing']['screener_only'].get('win_rate', 0):.1f}%"],
                ['Count',
                 str(performance_data['ab_testing']['claude_validated'].get('count', 0)),
                 str(performance_data['ab_testing']['screener_only'].get('count', 0))],
            ]

            ab_table = Table(ab_data, colWidths=[2 * inch, 2 * inch, 2 * inch])
            ab_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#4a90e2')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))

            story.append(ab_table)
            story.append(Spacer(1, 0.3 * inch))

        # Recent Signals
        story.append(Paragraph("Recent Signals", styles['Heading2']))
        story.append(Spacer(1, 0.1 * inch))

        if signals:
            signal_data = [['Symbol', 'Score', 'Direction', 'Status', 'PnL']]
            for signal in signals[:10]:  # Limit to 10 most recent
                pnl = signal.get('pnl_percentage')
                pnl_str = f"{pnl:+.2f}%" if pnl is not None else "Pending"

                signal_data.append([
                    signal.get('symbol', 'N/A'),
                    str(signal.get('score', 0)),
                    signal.get('direction', 'N/A'),
                    signal.get('status', 'N/A'),
                    pnl_str
                ])

            signal_table = Table(signal_data)
            signal_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.lightgrey]),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))

            story.append(signal_table)

        # Build PDF
        doc.build(story)

        logger.info(f"Performance report generated: {filepath}")
        return str(filepath)

    # ========================================================================
    # CSV EXPORT
    # ========================================================================

    def export_signals_to_csv(
        self,
        signals: List[Dict],
        filename: Optional[str] = None
    ) -> str:
        """
        Export signals to CSV file.

        Args:
            signals: List of signal dictionaries
            filename: Output filename (optional)

        Returns:
            Path to generated CSV file
        """
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"signals_export_{timestamp}.csv"

        filepath = self.output_dir / filename

        if not signals:
            logger.warning("No signals to export")
            return str(filepath)

        # Define CSV headers
        headers = [
            'signal_id', 'timestamp', 'symbol', 'direction', 'timeframe',
            'score', 'enhanced_score', 'current_price', 'entry_price',
            'stop_loss', 'take_profit', 'leverage', 'status',
            'actual_exit_price', 'pnl_percentage', 'claude_validated',
            'claude_confidence', 'data_quality_score'
        ]

        # Write CSV
        with open(filepath, 'w', newline='') as csvfile:
            writer = csv.DictWriter(csvfile, fieldnames=headers, extrasaction='ignore')
            writer.writeheader()

            for signal in signals:
                writer.writerow(signal)

        logger.info(f"Exported {len(signals)} signals to CSV: {filepath}")
        return str(filepath)

    def export_performance_to_csv(
        self,
        performance_data: Dict,
        filename: Optional[str] = None
    ) -> str:
        """
        Export performance statistics to CSV.

        Args:
            performance_data: Performance dictionary
            filename: Output filename (optional)

        Returns:
            Path to generated CSV file
        """
        if filename is None:
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            filename = f"performance_export_{timestamp}.csv"

        filepath = self.output_dir / filename

        # Write performance metrics
        with open(filepath, 'w', newline='') as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(['Metric', 'Value'])

            for key, value in performance_data.items():
                if not isinstance(value, dict):
                    writer.writerow([key, value])

        logger.info(f"Performance data exported to CSV: {filepath}")
        return str(filepath)

    # ========================================================================
    # EMAIL NOTIFICATIONS
    # ========================================================================

    def send_signal_notification(
        self,
        to_email: str,
        signal_data: Dict,
        attach_pdf: bool = True
    ) -> bool:
        """
        Send email notification for new trading signal.

        Args:
            to_email: Recipient email address
            signal_data: Signal information
            attach_pdf: Attach PDF report

        Returns:
            True if sent successfully, False otherwise
        """
        if not self._email_configured():
            logger.warning("Email not configured, skipping notification")
            return False

        try:
            # Create message
            msg = MIMEMultipart()
            msg['From'] = self.from_email
            msg['To'] = to_email
            msg['Subject'] = f"ðŸ”” New Trading Signal: {signal_data.get('symbol', 'Unknown')} ({signal_data.get('score', 0)}/194)"

            # Email body
            body = f"""
New Elliott Wave Trading Signal Detected!

Symbol: {signal_data.get('symbol', 'N/A')}
Direction: {signal_data.get('direction', 'N/A')}
Score: {signal_data.get('score', 0)}/194
Timeframe: {signal_data.get('timeframe', 'N/A')}

Entry Price: {signal_data.get('entry_price', 0):.5f}
Stop Loss: {signal_data.get('stop_loss', 0):.5f}
Take Profit: {signal_data.get('take_profit', 0):.5f}
Recommended Leverage: {signal_data.get('leverage', 1)}x

Generated: {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')}

---
This is an automated message from Elliott Wave Trading Bot v3.0.
Do not reply to this email.
"""

            msg.attach(MIMEText(body, 'plain'))

            # Attach PDF report
            if attach_pdf:
                try:
                    pdf_path = self.generate_signal_report_pdf(signal_data)
                    with open(pdf_path, 'rb') as f:
                        attach = MIMEApplication(f.read(), _subtype="pdf")
                        attach.add_header('Content-Disposition', 'attachment',
                                        filename=os.path.basename(pdf_path))
                        msg.attach(attach)
                except Exception as e:
                    logger.error(f"Failed to attach PDF: {e}")

            # Send email
            with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:
                server.starttls()
                server.login(self.smtp_user, self.smtp_password)
                server.send_message(msg)

            logger.info(f"Signal notification sent to {to_email}")
            return True

        except Exception as e:
            logger.error(f"Failed to send email notification: {e}")
            return False

    def send_performance_report(
        self,
        to_email: str,
        performance_data: Dict,
        signals: List[Dict],
        period_days: int = 30
    ) -> bool:
        """
        Send automated performance report via email.

        Args:
            to_email: Recipient email address
            performance_data: Performance statistics
            signals: Recent signals
            period_days: Reporting period in days

        Returns:
            True if sent successfully, False otherwise
        """
        if not self._email_configured():
            logger.warning("Email not configured, skipping report")
            return False

        try:
            # Generate PDF report
            pdf_path = self.generate_performance_report_pdf(performance_data, signals)

            # Create message
            msg = MIMEMultipart()
            msg['From'] = self.from_email
            msg['To'] = to_email
            msg['Subject'] = f"ðŸ“Š Trading Performance Report - Last {period_days} Days"

            # Email body
            body = f"""
Elliott Wave Trading Bot - Performance Report

Period: Last {period_days} days
Generated: {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')}

Summary:
--------
Total Signals: {performance_data.get('total_signals', 0)}
Win Rate: {performance_data.get('win_rate', 0):.1f}%
Average PnL: {performance_data.get('avg_pnl_percentage', 0):+.2f}%

Please see attached PDF report for detailed analysis.

---
This is an automated report from Elliott Wave Trading Bot v3.0.
"""

            msg.attach(MIMEText(body, 'plain'))

            # Attach PDF
            with open(pdf_path, 'rb') as f:
                attach = MIMEApplication(f.read(), _subtype="pdf")
                attach.add_header('Content-Disposition', 'attachment',
                                filename=os.path.basename(pdf_path))
                msg.attach(attach)

            # Send email
            with smtplib.SMTP(self.smtp_host, self.smtp_port) as server:
                server.starttls()
                server.login(self.smtp_user, self.smtp_password)
                server.send_message(msg)

            logger.info(f"Performance report sent to {to_email}")
            return True

        except Exception as e:
            logger.error(f"Failed to send performance report: {e}")
            return False

    def _email_configured(self) -> bool:
        """Check if email is properly configured."""
        return all([
            self.smtp_host,
            self.smtp_user,
            self.smtp_password,
            self.from_email
        ])

    # ========================================================================
    # UTILITY METHODS
    # ========================================================================

    def list_exports(self, file_type: Optional[str] = None) -> List[Dict]:
        """
        List all export files in output directory.

        Args:
            file_type: Filter by file type ('pdf', 'csv', or None for all)

        Returns:
            List of export file metadata
        """
        exports = []

        for file_path in self.output_dir.iterdir():
            if file_path.is_file():
                # Filter by type if specified
                if file_type and not file_path.suffix.endswith(file_type):
                    continue

                exports.append({
                    'filename': file_path.name,
                    'path': str(file_path),
                    'size_bytes': file_path.stat().st_size,
                    'created': datetime.fromtimestamp(file_path.stat().st_ctime).isoformat(),
                    'type': file_path.suffix[1:]  # Remove dot
                })

        # Sort by creation time (newest first)
        exports.sort(key=lambda x: x['created'], reverse=True)

        return exports

    def delete_export(self, filename: str) -> bool:
        """
        Delete an export file.

        Args:
            filename: Name of file to delete

        Returns:
            True if deleted successfully, False otherwise
        """
        filepath = self.output_dir / filename

        if filepath.exists() and filepath.is_file():
            filepath.unlink()
            logger.info(f"Deleted export file: {filename}")
            return True
        else:
            logger.warning(f"Export file not found: {filename}")
            return False

    def cleanup_old_exports(self, days: int = 30) -> int:
        """
        Delete export files older than specified days.

        Args:
            days: Delete files older than this many days

        Returns:
            Number of files deleted
        """
        cutoff_date = datetime.now() - timedelta(days=days)
        deleted_count = 0

        for file_path in self.output_dir.iterdir():
            if file_path.is_file():
                file_age = datetime.fromtimestamp(file_path.stat().st_ctime)

                if file_age < cutoff_date:
                    file_path.unlink()
                    deleted_count += 1

        logger.info(f"Cleaned up {deleted_count} export files older than {days} days")
        return deleted_count


# ============================================================================
# TESTING
# ============================================================================

if __name__ == "__main__":
    # Test export manager
    import sys

    logging.basicConfig(level=logging.INFO)

    print("=" * 60)
    print("EXPORT MANAGER TEST")
    print("=" * 60)

    # Initialize
    manager = ExportManager(output_dir="exports_test")

    # Test data
    test_signal = {
        'symbol': 'EUR/USD',
        'direction': 'LONG',
        'score': 95,
        'timeframe': '1h',
        'current_price': 1.1000,
        'entry_price': 1.1000,
        'stop_loss': 1.0950,
        'take_profit': 1.1100,
        'leverage': 10,
        'score_breakdown': {
            'elliott_wave': 50,
            'ict_components': 45
        },
        'claude_validated': True,
        'enhanced_score': 105,
        'claude_confidence': 85,
        'claude_justification': 'Strong impulse wave structure with clear targets'
    }

    # Test PDF generation
    print("\n1. Testing PDF generation...")
    pdf_path = manager.generate_signal_report_pdf(test_signal)
    print(f"âœ“ PDF generated: {pdf_path}")

    # Test CSV export
    print("\n2. Testing CSV export...")
    test_signals = [test_signal] * 5  # Create 5 test signals
    csv_path = manager.export_signals_to_csv(test_signals)
    print(f"âœ“ CSV generated: {csv_path}")

    # List exports
    print("\n3. Listing exports...")
    exports = manager.list_exports()
    for export in exports:
        print(f"  - {export['filename']} ({export['size_bytes']} bytes)")

    print("\n" + "=" * 60)
    print("âœ… ALL TESTS PASSED!")
    print("=" * 60)

    sys.exit(0)
