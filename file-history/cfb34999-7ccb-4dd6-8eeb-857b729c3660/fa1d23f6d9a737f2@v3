/**
 * Respawn Debug Test - Verify Fix Works
 */

import { test, expect } from '@playwright/test';

test('Debug respawn with console logs', async ({ page }) => {
  console.log('\nüîç RESPAWN DEBUG TEST\n');

  // Capture ALL console logs
  const logs: string[] = [];
  page.on('console', msg => {
    const text = msg.text();
    logs.push(text);
    // Print ERROR logs immediately
    if (msg.type() === 'error' || text.includes('setupInteraction') || text.includes('setInteractive')) {
      console.log(`[BROWSER] ${text}`);
    }
  });

  test.setTimeout(120000);

  // Force hard reload to bypass cache
  await page.goto('/play/1', { waitUntil: 'networkidle', timeout: 60000 });
  await page.reload({ waitUntil: 'networkidle' });
  await page.locator('canvas').waitFor({ state: 'visible', timeout: 30000 });
  await page.waitForFunction(() => typeof (window as any).game !== 'undefined', { timeout: 40000 });
  await page.waitForTimeout(8000);

  console.log('\n‚úÖ Game loaded');
  console.log('üì∏ Initial block setup logs should appear above\n');

  // Place 3 blocks to trigger respawn
  console.log('Placing block 1 at (0, 0)...');
  await page.evaluate(() => (window as any).gameDebug.simulateDrag(0, 0, 0));
  await page.waitForTimeout(500);

  console.log('Placing block 2 at (0, 4)...');
  await page.evaluate(() => (window as any).gameDebug.simulateDrag(0, 0, 4));
  await page.waitForTimeout(500);

  console.log('Placing block 3 at (2, 0) - should trigger respawn...');
  await page.evaluate(() => (window as any).gameDebug.simulateDrag(0, 2, 0));
  await page.waitForTimeout(2000);

  console.log('\nüì∏ Respawn logs should appear above\n');

  // Get block state
  const blockState = await page.evaluate(() => {
    const scene = (window as any).game.scene.scenes[0];
    const blocks = Array.from(scene.blockPool.activeBlocks);
    return blocks.map((b: any) => ({
      id: b.blockData?.id,
      hasInput: !!b.input,
      isDraggable: b.input?.draggable,
      active: b.active,
      visible: b.visible
    }));
  });

  console.log('\nüìä Final Block State:');
  console.log(JSON.stringify(blockState, null, 2));

  console.log('\nüìã Summary of setupInteraction calls:');
  const setupCalls = logs.filter(log => log.includes('setupInteraction() CALLED'));
  console.log(`Total: ${setupCalls.length} calls`);
  setupCalls.forEach(log => console.log(`  - ${log}`));

  console.log('\nüìã Summary of setInteractive completions:');
  const interactiveCalls = logs.filter(log => log.includes('setInteractive() COMPLETED'));
  console.log(`Total: ${interactiveCalls.length} calls`);
  interactiveCalls.forEach(log => console.log(`  - ${log}`));

  // CRITICAL ASSERTIONS - Test will FAIL if fix doesn't work
  console.log('\nüî¨ VERIFYING FIX...');

  const allHaveInput = blockState.every(b => b.hasInput === true);
  const allDraggable = blockState.every(b => b.isDraggable === true);

  if (allHaveInput && allDraggable) {
    console.log('‚úÖ FIX CONFIRMED: All respawned blocks have hasInput=true and isDraggable=true!');
  } else {
    console.log('‚ùå BUG STILL EXISTS: Some blocks missing input');
    blockState.forEach((b, i) => {
      if (!b.hasInput) {
        console.log(`   Block ${i} (${b.id}): hasInput=false ‚ùå`);
      }
    });
  }

  expect(blockState.length).toBe(3);
  expect(allHaveInput).toBe(true);
  expect(allDraggable).toBe(true);

  console.log('‚úÖ ALL ASSERTIONS PASSED!\n');
});
