import * as Phaser from 'phaser';
import { GAME_CONFIG } from '../config';
import { phaserLogger } from '@/lib/utils/logger';

// Force recompile - visual hit area debugging
console.log('[Block.ts] Module loaded - v8 - Fix drag debug graphics to use local coords');

export interface BlockData {
  id: string;
  shape: number[][];
  color: string;
}

export class Block extends Phaser.GameObjects.Container {
  private blockData: BlockData;
  private graphics: Phaser.GameObjects.Graphics;
  private hitAreaDebugGraphics?: Phaser.GameObjects.Graphics; // Visual debug overlay
  public isDragging: boolean;
  private originalX: number;
  private originalY: number;
  private wasPlacedSuccessfully: boolean = false; // Track if last placement succeeded
  private isSimulatingDrag: boolean = false; // Track if currently in a simulated drag
  private poolCleanupCallback?: () => void; // Callback to notify pool of destruction
  private gridStateCallback?: () => number[][]; // Callback to get current grid state
  public onPlacedCallback?: (block: {
    shape: number[][];
    color: string;
    row: number;
    col: number;
  }) => void;

  constructor(scene: Phaser.Scene, x: number, y: number, blockData: BlockData) {
    super(scene, x, y);

    // CRITICAL: Validate and fix invalid shape data
    this.blockData = this.validateBlockData(blockData);

    this.graphics = scene.add.graphics();
    this.add(this.graphics);
    this.isDragging = false;
    this.originalX = x;
    this.originalY = y;

    this.drawBlock();

    // Only setup interaction if we have valid shape data
    // Pool initialization creates blocks with empty shapes [[]] which shouldn't be interactive
    if (this.blockData.shape.length > 0 && this.blockData.shape[0].length > 0) {
      this.setupInteraction();
    }

    scene.add.existing(this);
  }

  reset(blockData: BlockData, x: number, y: number) {
    phaserLogger.debug("Block RESET called with", {
      id: blockData.id,
      shape: blockData.shape,
      shapeWidth: blockData.shape[0]?.length,
      color: blockData.color,
      position: { x, y },
      isSimulatingDrag: this.isSimulatingDrag,
      wasPlacedSuccessfully: this.wasPlacedSuccessfully
    });

    // CRITICAL: Validate and fix invalid shape data
    this.blockData = this.validateBlockData(blockData);
    this.x = x;
    this.y = y;
    this.originalX = x;
    this.originalY = y;
    this.isDragging = false;

    // CRITICAL: Don't reset wasPlacedSuccessfully if we're currently simulating a drag
    // The reset() might be called by pool respawning DURING the dragend event handler
    if (!this.isSimulatingDrag) {
      this.wasPlacedSuccessfully = false;
    } else {
      phaserLogger.warn("Skipping wasPlacedSuccessfully reset because drag simulation is active");
    }

    this.drawBlock();

    // Only setup interaction if we have valid shape data
    if (blockData.shape.length > 0 && blockData.shape[0].length > 0) {
      this.setupInteraction(); // Re-setup interaction with new block data
    }
  }

  setPlacedCallback(
    callback: (block: { shape: number[][]; color: string; row: number; col: number }) => void
  ) {
    this.onPlacedCallback = callback;
  }

  setPoolCleanupCallback(callback: () => void) {
    this.poolCleanupCallback = callback;
  }

  setGridStateCallback(callback: () => number[][]) {
    this.gridStateCallback = callback;
  }

  /**
   * Validate and fix invalid block shape data
   * CRITICAL: Allows empty shapes for pooled blocks, prevents premature hit area setup
   */
  private validateBlockData(blockData: BlockData): BlockData {
    // Allow empty shape for pool blocks - they won't have interaction set up yet
    if (!blockData.shape || blockData.shape.length === 0) {
      if (blockData.id.startsWith('pool-')) {
        phaserLogger.debug(`Block ${blockData.id} is a pool block with empty shape - OK (no interaction yet)`);
        return blockData; // Keep empty shape - no interaction will be set up
      } else {
        phaserLogger.error(`Block ${blockData.id} has INVALID shape (empty array)! Fixing to [[1]]`, blockData);
        return {
          ...blockData,
          shape: [[1]] // Minimal valid 1x1 shape for non-pool blocks
        };
      }
    }

    // Check if first row is empty
    if (!blockData.shape[0] || blockData.shape[0].length === 0) {
      if (blockData.id.startsWith('pool-')) {
        phaserLogger.debug(`Block ${blockData.id} is a pool block with empty first row - OK (no interaction yet)`);
        return blockData; // Keep empty shape - no interaction will be set up
      } else {
        phaserLogger.error(`Block ${blockData.id} has INVALID shape (empty first row)! Fixing to [[1]]`, blockData);
        return {
          ...blockData,
          shape: [[1]] // Minimal valid 1x1 shape for non-pool blocks
        };
      }
    }

    // Shape is valid
    phaserLogger.debug(`Block ${blockData.id} shape VALIDATED:`, {
      id: blockData.id,
      shape: blockData.shape,
      rows: blockData.shape.length,
      cols: blockData.shape[0].length,
      expectedWidth: blockData.shape[0].length * 30,
      expectedHeight: blockData.shape.length * 30
    });

    return blockData;
  }

  private drawBlock() {
    this.graphics.clear();

    const cellSize = 30; // Smaller than grid cells for preview
    const color = parseInt(this.blockData.color.replace('#', '0x'));

    this.blockData.shape.forEach((row, r) => {
      row.forEach((cell, c) => {
        if (cell === 1) {
          // Fill the cell with the block color
          // Add 0.5px overlap to prevent anti-aliasing gaps between cells
          this.graphics.fillStyle(color, 1);
          this.graphics.fillRect(
            c * cellSize,
            r * cellSize,
            cellSize + 0.5,
            cellSize + 0.5
          );
        }
      });
    });

    // Note: DO NOT call setSize() here - it interferes with the hit area
    // The hit area will be set in setupInteraction()
  }

  private setupInteraction() {
    phaserLogger.error(`ðŸ”§ [Block ${this.blockData.id}] setupInteraction() CALLED - active=${this.active}, visible=${this.visible}`);

    // Use Phaser's built-in drag system on the Container itself
    const cellSize = 30;

    // Safety check: ensure shape has data
    if (!this.blockData.shape || this.blockData.shape.length === 0 || !this.blockData.shape[0]) {
      phaserLogger.error(`Block ${this.blockData.id} ERROR: Invalid shape data`, this.blockData);
      return;
    }

    // CRITICAL FIX: Don't call removeInteractive() - it breaks Phaser's input system on Containers
    // Instead, just remove event listeners and recreate them
    if (this.input) {
      phaserLogger.error(`ðŸ”§ [Block ${this.blockData.id}] Clearing existing event listeners (NOT removing input)`);
      this.off('dragstart');
      this.off('drag');
      this.off('dragend');
      this.off('pointerover');
      this.off('pointerout');
      this.off('pointerdown');
    } else {
      phaserLogger.error(`ðŸ”§ [Block ${this.blockData.id}] No existing input - first time setup`);
    }

    // Remove old debug graphics if it exists
    if (this.hitAreaDebugGraphics) {
      this.hitAreaDebugGraphics.destroy();
      this.hitAreaDebugGraphics = undefined;
    }

    const width = this.blockData.shape[0].length * cellSize;
    const height = this.blockData.shape.length * cellSize;

    phaserLogger.warn(`[Block ${this.blockData.id}] ðŸ”§ HIT AREA CALCULATION:`, {
      shapeRows: this.blockData.shape.length,
      shapeCols: this.blockData.shape[0].length,
      cellSize,
      calculatedWidth: width,
      calculatedHeight: height,
      shape: this.blockData.shape
    });

    // CRITICAL FIX: Phaser Containers need explicit size AND bounds set
    // Without setBounds(), the hit area won't work correctly
    this.setSize(width, height);

    // Create hit area as a simple rectangle covering the full block
    const hitArea = new Phaser.Geom.Rectangle(0, 0, width, height);

    // CRITICAL FIX: If input already exists, we must update the hitArea properties
    // because setInteractive() doesn't update an existing hitArea
    if (this.input && this.input.hitArea) {
      phaserLogger.error(`ðŸ”§ [Block ${this.blockData.id}] Updating existing hitArea from ${this.input.hitArea.width}x${this.input.hitArea.height} to ${width}x${height}`);
      // Update the properties of the existing hit area instead of replacing it
      this.input.hitArea.x = 0;
      this.input.hitArea.y = 0;
      this.input.hitArea.width = width;
      this.input.hitArea.height = height;
      this.input.hitAreaCallback = Phaser.Geom.Rectangle.Contains;
      this.input.draggable = true;
      this.input.cursor = 'pointer';
    } else {
      // First time setup - use setInteractive
      this.setInteractive({
        hitArea: hitArea,
        hitAreaCallback: Phaser.Geom.Rectangle.Contains,
        draggable: true,
        useHandCursor: true,
        pixelPerfect: false  // Don't use pixel-perfect detection, use rectangle
      });
    }

    phaserLogger.error(`ðŸ”§ [Block ${this.blockData.id}] setInteractive() COMPLETED - hasInput=${!!this.input}, isDraggable=${this.input?.draggable}`);

    phaserLogger.warn(`[Block ${this.blockData.id}] ðŸ“ POSITION INFO:`, {
      x: this.x,
      y: this.y,
      width,
      height,
      clickableArea: {
        left: this.x,
        right: this.x + width,
        top: this.y,
        bottom: this.y + height
      }
    });

    // VISUAL DEBUG: Draw a bright border around the hit area so we can SEE it
    // CRITICAL: Add as a CHILD of the Container so it uses LOCAL coordinates like the hit area!
    this.hitAreaDebugGraphics = this.scene.add.graphics();
    this.hitAreaDebugGraphics.lineStyle(3, 0xFF0000, 1); // BRIGHT RED, 100% opacity for visibility
    this.hitAreaDebugGraphics.strokeRect(0, 0, width, height); // LOCAL coordinates (0, 0) to match hit area!
    this.add(this.hitAreaDebugGraphics); // Add as CHILD so it moves with the Container
    this.hitAreaDebugGraphics.setDepth(999); // Above everything except dragging blocks

    phaserLogger.error(`[Block ${this.blockData.id}] ðŸ”´ RED BORDER DRAWN (local 0,0) size ${width}x${height} at world (${this.x}, ${this.y})`);

    // Add pointer event logging
    this.on('pointerdown', (pointer: Phaser.Input.Pointer) => {
      phaserLogger.warn(`[Block ${this.blockData.id}] ðŸ–±ï¸ POINTER DOWN at (${Math.round(pointer.x)}, ${Math.round(pointer.y)})`);
      phaserLogger.warn(`[Block ${this.blockData.id}] Block is at (${this.x}, ${this.y}) with size ${width}x${height}`);
    });

    this.on('pointerover', (pointer: Phaser.Input.Pointer) => {
      phaserLogger.info(`[Block ${this.blockData.id}] âœ… MOUSE OVER at (${Math.round(pointer.x)}, ${Math.round(pointer.y)})`);
    });

    // Use Phaser's drag events
    this.on('dragstart', (pointer: Phaser.Input.Pointer) => {
      this.isDragging = true;
      this.setScale(1.2);
      this.setDepth(1000);
      phaserLogger.warn(`[Block ${this.blockData.id}] ðŸŽ¯ DRAG START at (${Math.round(pointer.x)}, ${Math.round(pointer.y)})`);
    });

    this.on('drag', (_pointer: Phaser.Input.Pointer, dragX: number, dragY: number) => {
      this.x = dragX;
      this.y = dragY;

      // Debug graphics automatically moves with Container as it's a child
      // No need to manually update its position - it uses local (0,0) coordinates

      // Visualize placement validity during drag
      const mainScene = this.scene as any;
      if (mainScene.visualizePlacement) {
        mainScene.visualizePlacement(this.blockData.shape, this.x, this.y);
      }
    });

    this.on('dragend', () => {
      this.isDragging = false;
      this.setScale(1);
      this.setDepth(0);

      // Clear debug visualization when drag ends
      const mainScene = this.scene as any;
      if (mainScene.clearDebugOverlay) {
        mainScene.clearDebugOverlay();
      }

      // Check if block was dropped on grid
      const gridPos = this.getGridPosition(this.x, this.y);

      if (gridPos && this.canPlaceAt(gridPos.row, gridPos.col)) {
        if (this.onPlacedCallback) {
          this.onPlacedCallback({
            shape: this.blockData.shape,
            color: this.blockData.color,
            row: gridPos.row,
            col: gridPos.col,
          });
        }

        // CRITICAL: Mark as successfully placed AFTER callbacks but BEFORE pool cleanup
        // Pool cleanup may immediately reuse this block and call reset(), which would clear the flag
        this.wasPlacedSuccessfully = true;

        // Clear debug graphics when block is placed successfully
        if (this.hitAreaDebugGraphics) {
          this.hitAreaDebugGraphics.destroy();
          this.hitAreaDebugGraphics = undefined;
        }

        // Notify pool to despawn this block (hide and return to pool)
        // WARNING: This may immediately reset this block if pool decides to reuse it!
        if (this.poolCleanupCallback) {
          this.poolCleanupCallback();
        }

        // Don't call this.destroy() - the pool will handle deactivation
        // The block returns to the pool for reuse
      } else {
        // Mark as NOT successfully placed
        this.wasPlacedSuccessfully = false;

        this.x = this.originalX;
        this.y = this.originalY;

        // Debug graphics automatically returns to original position with the Container
        // No manual update needed since it's a child using local (0,0) coordinates
      }
    });
  }


  private getGridPosition(x: number, y: number): { row: number; col: number } | null {
    const { gridOffsetX, gridOffsetY, cellSize } = GAME_CONFIG;

    // The Container position (x, y) is the top-left corner of the block
    // Add a small offset (quarter of a grid cell) to snap to the cell the block is mostly over
    // This prevents edge-case rounding issues when blocks are exactly on cell boundaries
    const snapOffset = cellSize / 4; // 10px offset for more intuitive snapping

    const col = Math.floor((x + snapOffset - gridOffsetX) / cellSize);
    const row = Math.floor((y + snapOffset - gridOffsetY) / cellSize);

    if (
      row >= 0 &&
      row < GAME_CONFIG.gridRows &&
      col >= 0 &&
      col < GAME_CONFIG.gridCols
    ) {
      return { row, col };
    }

    return null;
  }

  private canPlaceAt(row: number, col: number): boolean {
    // Get the current grid state from MainScene
    if (!this.gridStateCallback) {
      phaserLogger.warn(`Block ${this.blockData.id} No grid state callback - cannot check collision`);
      return true; // Fallback to allow placement if no callback
    }

    const grid = this.gridStateCallback();

    // Check if the block fits within grid bounds and doesn't overlap
    for (let r = 0; r < this.blockData.shape.length; r++) {
      for (let c = 0; c < this.blockData.shape[r].length; c++) {
        if (this.blockData.shape[r][c] === 1) {
          const gridRow = row + r;
          const gridCol = col + c;

          // Check bounds
          if (gridRow < 0 || gridRow >= GAME_CONFIG.gridRows ||
              gridCol < 0 || gridCol >= GAME_CONFIG.gridCols) {
            return false;
          }

          // Check if cell is already occupied
          if (grid[gridRow][gridCol] !== 0) {
            return false;
          }
        }
      }
    }

    return true;
  }

  /**
   * Programmatically simulate a drag and drop operation for autonomous testing
   * This method allows the autonomous control system to simulate user interaction
   */
  public simulateDragAndDrop(targetX: number, targetY: number): boolean {
    phaserLogger.debug(`Block ${this.blockData.id} AUTONOMOUS: Simulating drag to (${targetX}, ${targetY})`);

    // Mark that we're simulating a drag to prevent reset() from clearing wasPlacedSuccessfully
    this.isSimulatingDrag = true;

    // Reset placement flag before drag
    this.wasPlacedSuccessfully = false;

    // Emit dragstart event
    const pointer = { x: this.x, y: this.y } as Phaser.Input.Pointer;
    this.emit('dragstart', pointer);

    // Simulate drag movement
    this.emit('drag', pointer, targetX, targetY);

    // Update position
    this.x = targetX;
    this.y = targetY;

    // Emit dragend event - this will set wasPlacedSuccessfully flag
    // During this event, pool respawning might call reset() on this block,
    // but reset() will skip clearing wasPlacedSuccessfully because isSimulatingDrag is true
    const endPointer = { x: targetX, y: targetY } as Phaser.Input.Pointer;
    this.emit('dragend', endPointer);

    // Capture the flag value (it's now safe from reset() interference)
    const wasPlaced = this.wasPlacedSuccessfully;

    // Clear the simulation flag
    this.isSimulatingDrag = false;

    phaserLogger.debug(`Block ${this.blockData.id} AUTONOMOUS: Drag simulation complete. Placed: ${wasPlaced}`);

    return wasPlaced;
  }

  /**
   * Get the current block data for autonomous testing
   */
  public getBlockData(): BlockData {
    return this.blockData;
  }

  /**
   * Get the current position for autonomous testing
   */
  public getPosition(): { x: number; y: number } {
    return { x: this.x, y: this.y };
  }
}
