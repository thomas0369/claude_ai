/**
 * Verification Test - Confirm Respawned Blocks Are Draggable
 */

import { test, expect } from '@playwright/test';

test.describe('Verify Fix: Respawned Blocks Are Draggable', () => {

  test('Respawned blocks should have hasInput=true', async ({ page }) => {
    console.log('\nüî¨ VERIFICATION TEST - FIX ITERATION 1\n');
    console.log('='.repeat(80));

    test.setTimeout(120000);

    await page.goto('/play/1', { waitUntil: 'networkidle', timeout: 60000 });
    await page.locator('canvas').waitFor({ state: 'visible', timeout: 30000 });
    await page.waitForFunction(() => typeof (window as any).game !== 'undefined', { timeout: 40000 });
    await page.waitForTimeout(8000);

    console.log('‚úÖ Game loaded\n');

    // Check initial blocks
    console.log('üìã STEP 1: Checking initial blocks...');

    const initialState = await page.evaluate(() => {
      const scene = (window as any).game.scene.scenes[0];
      const blocks = Array.from(scene.blockPool.activeBlocks);
      return {
        count: blocks.length,
        blocks: blocks.map((b: any) => ({
          id: b.blockData?.id,
          hasInput: !!b.input,
          isDraggable: b.input?.draggable
        }))
      };
    });

    console.log(\`  Block count: \${initialState.count}\`);
    initialState.blocks.forEach((b: any, i: number) => {
      console.log(\`  Block \${i} (\${b.id}): hasInput=\${b.hasInput}, draggable=\${b.isDraggable}\`);
    });

    expect(initialState.count).toBe(3);
    expect(initialState.blocks.every((b: any) => b.hasInput)).toBe(true);
    console.log('  ‚úÖ Initial blocks are interactive\n');

    // Place 3 blocks
    console.log('üìã STEP 2: Placing 3 blocks...');

    await page.evaluate(() => (window as any).gameDebug.simulateDrag(0, 0, 0));
    await page.waitForTimeout(500);
    await page.evaluate(() => (window as any).gameDebug.simulateDrag(0, 0, 4));
    await page.waitForTimeout(500);
    await page.evaluate(() => (window as any).gameDebug.simulateDrag(0, 2, 0));
    await page.waitForTimeout(2000);

    console.log('  ‚è≥ Waiting for respawn...\n');

    // Check respawned blocks - CRITICAL TEST
    console.log('üìã STEP 3: Checking respawned blocks (CRITICAL)...');

    const respawnedState = await page.evaluate(() => {
      const scene = (window as any).game.scene.scenes[0];
      const blocks = Array.from(scene.blockPool.activeBlocks);
      return {
        count: blocks.length,
        blocks: blocks.map((b: any) => ({
          id: b.blockData?.id,
          hasInput: !!b.input,
          isDraggable: b.input?.draggable
        }))
      };
    });

    console.log(\`  Block count: \${respawnedState.count}\`);
    respawnedState.blocks.forEach((b: any, i: number) => {
      const status = b.hasInput ? '‚úÖ' : '‚ùå';
      console.log(\`  \${status} Block \${i} (\${b.id}): hasInput=\${b.hasInput}\`);
    });

    const allHaveInput = respawnedState.blocks.every((b: any) => b.hasInput === true);
    if (!allHaveInput) {
      console.log('\n‚ùå BUG STILL EXISTS: Respawned blocks have hasInput=false\n');
    } else {
      console.log('\n‚úÖ FIX CONFIRMED: All respawned blocks have hasInput=true!\n');
    }

    expect(respawnedState.count).toBe(3);
    expect(allHaveInput).toBe(true);

    console.log('='.repeat(80));
    console.log('‚úÖ TEST PASSED - FIX IS WORKING!');
    console.log('='.repeat(80) + '\n');
  });
});
