import * as Phaser from 'phaser';
import { GAME_CONFIG } from '../config';
import { BlockPool } from '../pools/BlockPool';
import { checkAndClearLines } from '../mechanics/line-clearing';
import { exposeDebugHelpers } from '../utils/gameDebugHelper';
import { createAutonomousController } from '../utils/autonomousControl';
import { phaserLogger } from '@/lib/utils/logger';

export interface BlockShape {
  id: string;
  shape: number[][];
  color: string;
}

export class MainScene extends Phaser.Scene {
  private grid: number[][];
  private gridGraphics!: Phaser.GameObjects.Graphics;
  private debugOverlay!: Phaser.GameObjects.Graphics;
  private blockPool!: BlockPool;
  private currentBlocks: BlockShape[];
  private score: number;
  private comboCount: number;
  private onScoreUpdate?: (score: number) => void;
  private onGameOver?: () => void;
  private onLevelComplete?: () => void;
  private debugMode: boolean = true; // Enable debug visualization by default

  constructor() {
    super({ key: 'MainScene' });
    this.grid = [];
    this.currentBlocks = [];
    this.score = 0;
    this.comboCount = 0;
  }

  init(data: {
    blocks: BlockShape[];
    onScoreUpdate?: (score: number) => void;
    onGameOver?: () => void;
    onLevelComplete?: () => void;
  }) {
    phaserLogger.debug('MainScene init called with data', data);
    // Only update if data is provided (don't override pre-initialized values with empty data)
    if (data && data.blocks && data.blocks.length > 0) {
      this.currentBlocks = data.blocks;
      this.onScoreUpdate = data.onScoreUpdate;
      this.onGameOver = data.onGameOver;
      this.onLevelComplete = data.onLevelComplete;
      phaserLogger.debug('currentBlocks set to', this.currentBlocks);
    } else {
      phaserLogger.debug('init called with empty data, keeping existing currentBlocks', this.currentBlocks);
    }
  }

  create() {
    phaserLogger.debug('MainScene create() started');

    // Add global pointer event listeners for debugging
    this.input.on('pointerdown', (pointer: Phaser.Input.Pointer) => {
      phaserLogger.debug('GLOBAL POINTER DOWN', {
        x: Math.round(pointer.x),
        y: Math.round(pointer.y),
        worldX: Math.round(pointer.worldX),
        worldY: Math.round(pointer.worldY)
      });
    });

    this.input.on('pointermove', (pointer: Phaser.Input.Pointer) => {
      if (pointer.isDown) {
        phaserLogger.debug('GLOBAL POINTER MOVE (down)', {
          x: Math.round(pointer.x),
          y: Math.round(pointer.y)
        });
      }
    });

    this.input.on('pointerup', (pointer: Phaser.Input.Pointer) => {
      phaserLogger.debug('GLOBAL POINTER UP', {
        x: Math.round(pointer.x),
        y: Math.round(pointer.y)
      });
    });

    // Initialize grid
    this.grid = Array(GAME_CONFIG.gridRows)
      .fill(0)
      .map(() => Array(GAME_CONFIG.gridCols).fill(0));

    // Create grid graphics
    this.gridGraphics = this.add.graphics();
    this.drawGrid();

    // Create debug overlay for collision visualization
    this.debugOverlay = this.add.graphics();
    this.debugOverlay.setDepth(500); // Above grid but below dragging blocks

    // Initialize block pool
    this.blockPool = new BlockPool(this);

    // Set callback to provide grid state for collision detection
    this.blockPool.setGridStateCallback(() => {
      return this.grid;
    });

    // Set callback for when all blocks are placed
    this.blockPool.setAllBlocksPlacedCallback(() => {
      phaserLogger.info('All blocks placed callback triggered, spawning new blocks');
      this.spawnBlocks();
    });

    // Spawn initial blocks
    this.spawnBlocks();

    // Expose debug helpers for autonomous testing
    exposeDebugHelpers();

    // Create autonomous controller for advanced testing
    createAutonomousController();

    phaserLogger.info('MainScene create() complete - input system ready');
  }

  private drawGrid() {
    const { gridOffsetX, gridOffsetY, cellSize, gridRows, gridCols } = GAME_CONFIG;

    this.gridGraphics.clear();

    // Draw grid lines
    this.gridGraphics.lineStyle(1, 0xcccccc, 1);

    for (let row = 0; row <= gridRows; row++) {
      this.gridGraphics.beginPath();
      this.gridGraphics.moveTo(gridOffsetX, gridOffsetY + row * cellSize);
      this.gridGraphics.lineTo(gridOffsetX + gridCols * cellSize, gridOffsetY + row * cellSize);
      this.gridGraphics.strokePath();
    }

    for (let col = 0; col <= gridCols; col++) {
      this.gridGraphics.beginPath();
      this.gridGraphics.moveTo(gridOffsetX + col * cellSize, gridOffsetY);
      this.gridGraphics.lineTo(gridOffsetX + col * cellSize, gridOffsetY + gridRows * cellSize);
      this.gridGraphics.strokePath();
    }

    // Draw filled cells
    for (let row = 0; row < gridRows; row++) {
      for (let col = 0; col < gridCols; col++) {
        if (this.grid[row][col] !== 0) {
          this.gridGraphics.fillStyle(this.grid[row][col], 1);
          this.gridGraphics.fillRect(
            gridOffsetX + col * cellSize + 1,
            gridOffsetY + row * cellSize + 1,
            cellSize - 2,
            cellSize - 2
          );
        }
      }
    }
  }

  /**
   * Visualize valid/invalid placement positions for a block shape
   * Called during drag operations to show where the block can be placed
   */
  public visualizePlacement(shape: number[][], blockX: number, blockY: number) {
    if (!this.debugMode) return;

    this.debugOverlay.clear();

    const { gridOffsetX, gridOffsetY, cellSize } = GAME_CONFIG;

    // Convert block screen position to grid coordinates
    const snapOffset = cellSize / 4;
    const col = Math.floor((blockX + snapOffset - gridOffsetX) / cellSize);
    const row = Math.floor((blockY + snapOffset - gridOffsetY) / cellSize);

    // Check if the block is over the grid
    if (
      row < -shape.length ||
      row >= GAME_CONFIG.gridRows ||
      col < -shape[0].length ||
      col >= GAME_CONFIG.gridCols
    ) {
      // Block is completely outside grid - show light gray overlay on entire grid
      this.debugOverlay.fillStyle(0x666666, 0.1);
      this.debugOverlay.fillRect(
        gridOffsetX,
        gridOffsetY,
        GAME_CONFIG.gridCols * cellSize,
        GAME_CONFIG.gridRows * cellSize
      );
      return;
    }

    // Analyze each cell of the block shape
    let hasValidPlacement = true;
    const cellStatus: { row: number; col: number; valid: boolean; reason?: string }[] = [];

    for (let r = 0; r < shape.length; r++) {
      for (let c = 0; c < shape[r].length; c++) {
        if (shape[r][c] === 1) {
          const gridRow = row + r;
          const gridCol = col + c;

          let valid = true;
          let reason = '';

          // Check bounds
          if (gridRow < 0 || gridRow >= GAME_CONFIG.gridRows) {
            valid = false;
            reason = 'out of bounds (row)';
          } else if (gridCol < 0 || gridCol >= GAME_CONFIG.gridCols) {
            valid = false;
            reason = 'out of bounds (col)';
          } else if (this.grid[gridRow][gridCol] !== 0) {
            valid = false;
            reason = 'occupied';
          }

          if (!valid) {
            hasValidPlacement = false;
          }

          cellStatus.push({ row: gridRow, col: gridCol, valid, reason });
        }
      }
    }

    // Draw visualization for each cell
    cellStatus.forEach(cell => {
      if (cell.row >= 0 && cell.row < GAME_CONFIG.gridRows &&
          cell.col >= 0 && cell.col < GAME_CONFIG.gridCols) {

        if (cell.valid) {
          // Valid placement - green with transparency
          this.debugOverlay.fillStyle(0x00ff00, 0.3);
        } else {
          // Invalid placement - red with transparency
          this.debugOverlay.fillStyle(0xff0000, 0.4);
        }

        this.debugOverlay.fillRect(
          gridOffsetX + cell.col * cellSize + 2,
          gridOffsetY + cell.row * cellSize + 2,
          cellSize - 4,
          cellSize - 4
        );

        // Add border for emphasis
        if (cell.valid) {
          this.debugOverlay.lineStyle(2, 0x00ff00, 0.6);
        } else {
          this.debugOverlay.lineStyle(2, 0xff0000, 0.8);
        }

        this.debugOverlay.strokeRect(
          gridOffsetX + cell.col * cellSize + 2,
          gridOffsetY + cell.row * cellSize + 2,
          cellSize - 4,
          cellSize - 4
        );
      }
    });

    // Log collision details for debugging
    if (!hasValidPlacement) {
      const invalidCells = cellStatus.filter(c => !c.valid);
      phaserLogger.debug('Invalid placement detected', {
        blockPos: { row, col },
        invalidCells: invalidCells.map(c => ({
          pos: `${c.row},${c.col}`,
          reason: c.reason
        }))
      });
    }
  }

  /**
   * Clear debug visualization overlay
   */
  public clearDebugOverlay() {
    if (this.debugOverlay) {
      this.debugOverlay.clear();
    }
  }

  /**
   * Get the scene's grid for collision detection
   */
  public getGrid(): number[][] {
    return this.grid;
  }

  private spawnBlocks() {
    // Check if currentBlocks is defined and has elements
    if (!this.currentBlocks || this.currentBlocks.length === 0) {
      phaserLogger.warn('No blocks available to spawn');
      return;
    }

    // Spawn 3 random blocks from available blocks
    const numBlocks = Math.min(3, this.currentBlocks.length);

    for (let i = 0; i < numBlocks; i++) {
      const blockData = Phaser.Utils.Array.GetRandom(this.currentBlocks);
      const x = 100 + i * 150;
      const y = GAME_CONFIG.blockPreviewY;

      this.blockPool.spawn(blockData, x, y, block => {
        this.onBlockPlaced(block);
      });
    }
  }

  private onBlockPlaced(block: { shape: number[][]; color: string; row: number; col: number }) {
    phaserLogger.debug('onBlockPlaced called', {
      shape: block.shape,
      color: block.color,
      position: { row: block.row, col: block.col }
    });

    // Place block on grid
    let cellsPlaced = 0;
    for (let r = 0; r < block.shape.length; r++) {
      for (let c = 0; c < block.shape[r].length; c++) {
        if (block.shape[r][c] === 1) {
          const gridRow = block.row + r;
          const gridCol = block.col + c;
          if (
            gridRow >= 0 &&
            gridRow < GAME_CONFIG.gridRows &&
            gridCol >= 0 &&
            gridCol < GAME_CONFIG.gridCols
          ) {
            this.grid[gridRow][gridCol] = parseInt(block.color.replace('#', '0x'));
            cellsPlaced++;
          }
        }
      }
    }

    phaserLogger.debug(`Placed ${cellsPlaced} cells on grid`);

    // Check for completed lines
    phaserLogger.debug('Checking for completed lines');
    const { linesCleared, clearedRows, clearedCols, newGrid } = checkAndClearLines(this.grid);
    this.grid = newGrid;

    phaserLogger.info('Line clearing result', {
      linesCleared,
      clearedRows,
      clearedCols
    });

    // Update score
    if (linesCleared > 0) {
      this.comboCount++;
      const lineScore = linesCleared * 100 * this.comboCount;
      this.score += lineScore;
      phaserLogger.info('SCORE UPDATE', {
        linesCleared,
        combo: this.comboCount,
        lineScore,
        totalScore: this.score
      });
      if (this.onScoreUpdate) {
        this.onScoreUpdate(this.score);
      }
    } else {
      phaserLogger.debug('No lines cleared, combo reset');
      this.comboCount = 0;
    }

    // Redraw grid
    phaserLogger.debug('Redrawing grid');
    this.drawGrid();

    // Note: Block respawning is now handled by BlockPool.despawn()
    // which triggers the onAllBlocksPlacedCallback when activeCount reaches 0
  }

  update() {
    // Update FPS counter if needed
  }

  shutdown() {
    this.blockPool.clear();
  }
}
