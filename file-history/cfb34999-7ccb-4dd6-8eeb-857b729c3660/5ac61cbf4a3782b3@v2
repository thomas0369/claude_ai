/**
 * PIXEL-BY-PIXEL HIT AREA TEST
 * Tests EVERY single pixel within block bounds to find dead zones
 */

import { test, expect } from '@playwright/test';

test.describe('Pixel-by-Pixel Hit Area Test', () => {
  test('Test every single pixel within each block', async ({ page }) => {
    console.log('\nüî¨ PIXEL-BY-PIXEL HIT AREA TEST\n');
    console.log('='.repeat(80));

    test.setTimeout(240000); // 4 minutes for thorough testing

    await page.goto('/play/1', { waitUntil: 'networkidle', timeout: 60000 });
    await page.locator('canvas').waitFor({ state: 'visible', timeout: 30000 });
    await page.waitForFunction(() => typeof (window as any).game !== 'undefined', { timeout: 40000 });
    await page.waitForTimeout(8000);

    const blockCount = await page.evaluate(() => {
      const game = (window as any).game;
      const scene = game.scene.scenes[0];
      return scene.blockPool?.activeBlocks?.size || 0;
    });

    console.log(`‚úÖ Game loaded\n`);
    console.log(`Found ${blockCount} blocks\n`);

    // Test each block
    for (let blockIndex = 0; blockIndex < blockCount; blockIndex++) {
      console.log('‚îÄ'.repeat(80));
      console.log(`\nüì¶ BLOCK ${blockIndex + 1}\n`);

      const blockInfo = await page.evaluate((idx) => {
        const game = (window as any).game;
        const scene = game.scene.scenes[0];
        const blocks = Array.from(scene.blockPool.activeBlocks);
        const block = blocks[idx];

        if (!block) return null;

        const worldTransform = block.getWorldTransformMatrix();
        const blockX = worldTransform.tx;
        const blockY = worldTransform.ty;

        // Calculate bounds from shape (30px per cell)
        const shape = block.blockData.shape;
        const rows = shape.length;
        const cols = shape[0]?.length || 0;
        const width = cols * 30;
        const height = rows * 30;

        return {
          id: block.blockData.id,
          x: blockX,
          y: blockY,
          bounds: {
            x: blockX,
            y: blockY,
            width: width,
            height: height,
            left: blockX,
            right: blockX + width,
            top: blockY,
            bottom: blockY + height
          },
          hitArea: block.input?.hitArea ? {
            x: block.input.hitArea.x,
            y: block.input.hitArea.y,
            width: block.input.hitArea.width,
            height: block.input.hitArea.height
          } : null,
          shape: block.blockData.shape
        };
      }, blockIndex);

      if (!blockInfo) {
        console.log(`‚ö†Ô∏è  Block ${blockIndex} not found\n`);
        continue;
      }

      console.log(`   ID: ${blockInfo.id}`);
      console.log(`   Position: (${blockInfo.x}, ${blockInfo.y})`);
      console.log(`   Bounds: ${blockInfo.bounds.width}x${blockInfo.bounds.height}px`);
      console.log(`   Hit Area: ${blockInfo.hitArea?.width}x${blockInfo.hitArea?.height}px\n`);

      // Test EVERY pixel within the bounds
      const gridSize = 5; // Test every 5 pixels for speed
      const failedPixels: { x: number; y: number }[] = [];
      const successPixels: { x: number; y: number }[] = [];

      const left = Math.round(blockInfo.bounds.left);
      const right = Math.round(blockInfo.bounds.right);
      const top = Math.round(blockInfo.bounds.top);
      const bottom = Math.round(blockInfo.bounds.bottom);

      console.log(`   Testing region: X[${left} ‚Üí ${right}], Y[${top} ‚Üí ${bottom}]\n`);
      console.log(`   Testing every ${gridSize}px...\n`);

      let totalPixelsTested = 0;

      for (let testY = top + 2; testY < bottom - 2; testY += gridSize) {
        for (let testX = left + 2; testX < right - 2; testX += gridSize) {
          totalPixelsTested++;

          const detected = await page.evaluate(({ x, y, idx }) => {
            const game = (window as any).game;
            const scene = game.scene.scenes[0];
            const blocks = Array.from(scene.blockPool.activeBlocks);
            const block = blocks[idx];

            if (!block) return false;

            // Convert to local coordinates
            const localPoint = new Phaser.Math.Vector2();
            block.getWorldTransformMatrix().applyInverse(x, y, localPoint);

            // Check if hit area contains this point
            if (block.input?.hitArea) {
              return Phaser.Geom.Rectangle.Contains(block.input.hitArea, localPoint.x, localPoint.y);
            }

            return false;
          }, { x: testX, y: testY, idx: blockIndex });

          if (detected) {
            successPixels.push({ x: testX, y: testY });
          } else {
            failedPixels.push({ x: testX, y: testY });
          }
        }
      }

      console.log(`   ‚úÖ Total pixels tested: ${totalPixelsTested}`);
      console.log(`   ‚úÖ Clickable pixels: ${successPixels.length} (${((successPixels.length / totalPixelsTested) * 100).toFixed(1)}%)`);
      console.log(`   ‚ùå Dead pixels: ${failedPixels.length} (${((failedPixels.length / totalPixelsTested) * 100).toFixed(1)}%)\n`);

      if (failedPixels.length > 0) {
        console.log(`   üî¥ DEAD ZONES FOUND!\n`);

        // Analyze where the dead zones are
        const leftDeadZone = failedPixels.filter(p => p.x < left + 10);
        const rightDeadZone = failedPixels.filter(p => p.x > right - 10);
        const topDeadZone = failedPixels.filter(p => p.y < top + 10);
        const bottomDeadZone = failedPixels.filter(p => p.y > bottom - 10);

        if (leftDeadZone.length > 0) console.log(`      ‚ùå Left edge: ${leftDeadZone.length} dead pixels`);
        if (rightDeadZone.length > 0) console.log(`      ‚ùå Right edge: ${rightDeadZone.length} dead pixels`);
        if (topDeadZone.length > 0) console.log(`      ‚ùå Top edge: ${topDeadZone.length} dead pixels`);
        if (bottomDeadZone.length > 0) console.log(`      ‚ùå Bottom edge: ${bottomDeadZone.length} dead pixels`);

        // Show first 10 failed pixels
        console.log(`\n      Dead pixel samples (first 10):`);
        failedPixels.slice(0, 10).forEach(p => {
          const relX = p.x - left;
          const relY = p.y - top;
          console.log(`         (${p.x}, ${p.y}) - offset from top-left: (${relX}, ${relY})`);
        });

        // Test the exact bottom-right corner that user mentioned
        const bottomRightTests = [
          { x: right - 5, y: bottom - 5, name: 'bottom-right -5px' },
          { x: right - 10, y: bottom - 10, name: 'bottom-right -10px' },
          { x: right - 15, y: bottom - 15, name: 'bottom-right -15px' },
          { x: right - 2, y: bottom - 2, name: 'bottom-right -2px' },
          { x: right - 1, y: bottom - 1, name: 'bottom-right -1px' }
        ];

        console.log(`\n      üéØ Bottom-Right Corner Specific Tests:`);
        for (const test of bottomRightTests) {
          const detected = await page.evaluate(({ x, y, idx }) => {
            const game = (window as any).game;
            const scene = game.scene.scenes[0];
            const blocks = Array.from(scene.blockPool.activeBlocks);
            const block = blocks[idx];

            if (!block) return false;

            const localPoint = new Phaser.Math.Vector2();
            block.getWorldTransformMatrix().applyInverse(x, y, localPoint);

            if (block.input?.hitArea) {
              return Phaser.Geom.Rectangle.Contains(block.input.hitArea, localPoint.x, localPoint.y);
            }

            return false;
          }, { x: test.x, y: test.y, idx: blockIndex });

          const status = detected ? '‚úÖ' : '‚ùå';
          console.log(`         ${status} ${test.name}: (${test.x}, ${test.y}) - ${detected ? 'WORKS' : 'FAILS'}`);
        }
      } else {
        console.log(`   ‚úÖ ALL PIXELS CLICKABLE - NO DEAD ZONES!\n`);
      }

      // FAIL the test if any pixels are dead
      if (failedPixels.length > 0) {
        const coverage = ((successPixels.length / totalPixelsTested) * 100).toFixed(1);
        throw new Error(`Block ${blockInfo.id} has ${failedPixels.length} dead pixels! Only ${coverage}% coverage.`);
      }
    }

    console.log('='.repeat(80));
    console.log('‚úÖ PIXEL-BY-PIXEL TEST COMPLETE - ALL BLOCKS 100% CLICKABLE\n');
  });
});
