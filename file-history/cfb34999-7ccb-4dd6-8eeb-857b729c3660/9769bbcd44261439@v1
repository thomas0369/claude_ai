import * as Phaser from 'phaser';
import { Block } from '../entities/Block';
import { phaserLogger } from '@/lib/utils/logger';

export interface BlockData {
  id: string;
  shape: number[][];
  color: string;
}

export class BlockPool {
  private scene: Phaser.Scene;
  private pool: Block[];
  private activeBlocks: Set<Block>;
  private onAllBlocksPlacedCallback?: () => void;
  private gridStateCallback?: () => number[][];

  constructor(scene: Phaser.Scene, initialSize: number = 10) {
    this.scene = scene;
    this.pool = [];
    this.activeBlocks = new Set();

    // Pre-create blocks with a minimal valid shape (1x1)
    // This prevents initialization issues while keeping blocks inactive
    for (let i = 0; i < initialSize; i++) {
      const block = new Block(scene, 0, 0, { id: `pool-${i}`, shape: [[1]], color: '#000000' });
      block.setActive(false);
      block.setVisible(false);
      this.pool.push(block);
    }
  }

  spawn(
    blockData: BlockData,
    x: number,
    y: number,
    onPlaced?: (block: { shape: number[][]; color: string; row: number; col: number }) => void
  ): Block {
    let block: Block;

    phaserLogger.debug('spawn() called', {
      poolSize: this.pool.length,
      blockData: {
        id: blockData.id,
        shape: blockData.shape,
        shapeWidth: blockData.shape[0]?.length,
        color: blockData.color
      },
      position: { x, y }
    });

    // Get from pool or create new
    if (this.pool.length > 0) {
      phaserLogger.debug('Reusing block from pool');
      block = this.pool.pop()!;
      block.reset(blockData, x, y);
    } else {
      phaserLogger.debug('Creating NEW block (pool empty)');
      block = new Block(this.scene, x, y, blockData);
    }

    block.setActive(true);
    block.setVisible(true);

    if (onPlaced) {
      block.setPlacedCallback(onPlaced);
    }

    // Set grid state callback so block can check for collisions
    if (this.gridStateCallback) {
      block.setGridStateCallback(this.gridStateCallback);
    }

    // Set cleanup callback so block can notify pool when placed
    block.setPoolCleanupCallback(() => {
      phaserLogger.debug(`Block ${blockData.id} placed - despawning`);
      this.despawn(block);
    });

    this.activeBlocks.add(block);

    return block;
  }

  despawn(block: Block) {
    block.setActive(false);
    block.setVisible(false);
    this.activeBlocks.delete(block);
    this.pool.push(block);

    phaserLogger.debug('After despawn', {
      activeBlocksSize: this.activeBlocks.size,
      hasCallback: !!this.onAllBlocksPlacedCallback
    });

    // Check if all blocks have been placed
    if (this.activeBlocks.size === 0 && this.onAllBlocksPlacedCallback) {
      phaserLogger.info('All blocks placed, triggering respawn callback');
      this.onAllBlocksPlacedCallback();
    }
  }

  setAllBlocksPlacedCallback(callback: () => void) {
    this.onAllBlocksPlacedCallback = callback;
  }

  setGridStateCallback(callback: () => number[][]) {
    this.gridStateCallback = callback;
  }

  getActiveCount(): number {
    return this.activeBlocks.size;
  }

  clear() {
    this.activeBlocks.forEach(block => {
      block.destroy();
    });
    this.activeBlocks.clear();
    this.pool.forEach(block => {
      block.destroy();
    });
    this.pool = [];
  }
}
