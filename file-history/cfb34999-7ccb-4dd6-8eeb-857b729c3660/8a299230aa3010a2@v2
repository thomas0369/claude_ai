/**
 * Simple Verification Test
 *
 * Basic test to verify the application works and capture detailed diagnostic info
 */

import { test, expect } from '@playwright/test';

test.describe('Simple Application Verification', () => {

  test('Verify application loads and functions correctly', async ({ page }) => {
    const consoleMessages: string[] = [];
    const consoleErrors: string[] = [];

    // Capture console output
    page.on('console', msg => {
      const text = msg.text();
      consoleMessages.push(`[${msg.type()}] ${text}`);
      if (msg.type() === 'error') {
        consoleErrors.push(text);
      }
    });

    // Capture page errors
    page.on('pageerror', err => {
      consoleErrors.push(`PAGE ERROR: ${err.message}`);
    });

    console.log('\n=== STEP 1: Load Homepage ===');
    await page.goto('/', { waitUntil: 'networkidle', timeout: 60000 });
    await expect(page).toHaveTitle(/Block Puzzle Hero/);
    console.log('✓ Homepage loaded');

    console.log('\n=== STEP 2: Navigate to Levels ===');
    await page.locator('a[href="/levels"]').first().click();
    await page.waitForURL('**/levels');
    await page.waitForLoadState('networkidle');
    console.log('✓ Levels page loaded');

    console.log('\n=== STEP 3: Navigate to Game ===');
    await page.locator('a[href="/play/1"]').first().click();
    await page.waitForURL('**/play/1');
    await page.waitForLoadState('networkidle');
    console.log('✓ Game page loaded');

    console.log('\n=== STEP 4: Wait for Canvas ===');
    await page.locator('canvas').waitFor({ state: 'visible', timeout: 30000 });
    console.log('✓ Canvas visible');

    // Take screenshot of loaded game
    await page.screenshot({ path: 'test-results/game-loaded.png', fullPage: true });
    console.log('✓ Screenshot saved');

    // Wait a bit for game initialization
    await page.waitForTimeout(10000);

    console.log('\n=== STEP 5: Check Window Objects ===');
    const windowObjects = await page.evaluate(() => {
      const win = window as any;
      return {
        hasGame: typeof win.game !== 'undefined',
        hasGameDebug: typeof win.gameDebug !== 'undefined',
        hasPhaser: typeof win.Phaser !== 'undefined',
        gameScenes: win.game?.scene?.scenes?.length || 0,
        sceneKeys: win.game?.scene?.scenes?.map((s: any) => s.scene.key) || [],
      };
    });

    console.log('Window Objects:', JSON.stringify(windowObjects, null, 2));

    console.log('\n=== STEP 6: Try to Get Game State ===');
    const gameStateResult = await page.evaluate(() => {
      try {
        const win = window as any;
        if (!win.gameDebug) {
          return { error: 'gameDebug not found' };
        }
        if (!win.gameDebug.getGameState) {
          return { error: 'getGameState not found' };
        }

        const state = win.gameDebug.getGameState();
        return { success: true, state };
      } catch (err) {
        return { error: String(err) };
      }
    });

    console.log('Game State Result:', JSON.stringify(gameStateResult, null, 2));

    console.log('\n=== STEP 7: Check Scene Directly ===');
    const sceneInfo = await page.evaluate(() => {
      try {
        const win = window as any;
        if (!win.game || !win.game.scene || !win.game.scene.scenes) {
          return { error: 'No game scenes found' };
        }

        const scene = win.game.scene.scenes[0];
        if (!scene) {
          return { error: 'Scene at index 0 not found' };
        }

        return {
          key: scene.scene.key,
          isActive: scene.scene.isActive(),
          hasGrid: !!scene.grid,
          gridLength: scene.grid?.length || 0,
          hasBlockPool: !!scene.blockPool,
          score: scene.score,
          combo: scene.comboCount,
          currentBlocksLength: scene.currentBlocks?.length || 0,
        };
      } catch (err) {
        return { error: String(err) };
      }
    });

    console.log('Scene Info:', JSON.stringify(sceneInfo, null, 2));

    // Print console logs if any errors
    if (consoleErrors.length > 0) {
      console.log('\n=== CONSOLE ERRORS ===');
      consoleErrors.forEach(err => console.log(err));
    }

    console.log('\n=== RECENT CONSOLE MESSAGES ===');
    consoleMessages.slice(-20).forEach(msg => console.log(msg));

    console.log('\n=== TEST COMPLETE ===');
    expect(windowObjects.hasGame).toBe(true);
  });
});
