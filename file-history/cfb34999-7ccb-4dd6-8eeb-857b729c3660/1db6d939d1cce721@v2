/**
 * Hit Area Measurement Test
 * Measures the actual clickable area vs visual red border for each block
 */

import { test, expect } from '@playwright/test';

test.describe('Hit Area Measurement', () => {

  test('Measure clickable area for each block type', async ({ page }) => {
    console.log('\nüéØ HIT AREA MEASUREMENT TEST\n');
    console.log('='.repeat(80));

    test.setTimeout(180000);

    await page.goto('/play/1', { waitUntil: 'networkidle', timeout: 60000 });
    await page.locator('canvas').waitFor({ state: 'visible', timeout: 30000 });
    await page.waitForFunction(() => typeof (window as any).game !== 'undefined', { timeout: 40000 });
    await page.waitForTimeout(8000);

    console.log('‚úÖ Game loaded\n');

    // Get all block information
    const blocks = await page.evaluate(() => {
      const scene = (window as any).game.scene.scenes[0];
      const activeBlocks = Array.from(scene.blockPool.activeBlocks);

      return activeBlocks.map((block: any, idx: number) => {
        const data = block.blockData;
        const pos = block.getPosition();

        // Get the actual hit area from Phaser
        const hitArea = block.input?.hitArea;

        return {
          index: idx,
          id: data.id,
          shape: data.shape,
          shapeWidth: data.shape[0]?.length || 0,
          shapeHeight: data.shape.length,
          position: pos,
          hasInput: !!block.input,
          isDraggable: block.input?.draggable,
          hitArea: hitArea ? {
            x: hitArea.x,
            y: hitArea.y,
            width: hitArea.width,
            height: hitArea.height
          } : null,
          // Visual dimensions (red border)
          visualWidth: data.shape[0]?.length * 30,  // cellSize = 30 for preview
          visualHeight: data.shape.length * 30
        };
      });
    });

    console.log(`Found ${blocks.length} blocks\n`);

    for (let i = 0; i < blocks.length; i++) {
      const block = blocks[i];
      console.log('‚îÄ'.repeat(80));
      console.log(`\nüì¶ BLOCK ${i + 1}: ${block.id}\n`);
      console.log(`   Position: (${block.position.x}, ${block.position.y})`);
      console.log(`   Shape: ${block.shapeWidth}x${block.shapeHeight} cells`);
      console.log(`   Visual Size: ${block.visualWidth}x${block.visualHeight}px (red border)`);

      if (block.hitArea) {
        console.log(`   Hit Area: x=${block.hitArea.x}, y=${block.hitArea.y}, w=${block.hitArea.width}, h=${block.hitArea.height}`);
      } else {
        console.log(`   ‚ùå No hit area found!`);
      }

      // Calculate actual clickable region in world coordinates
      const clickableRegion = {
        left: block.position.x + (block.hitArea?.x || 0),
        top: block.position.y + (block.hitArea?.y || 0),
        right: block.position.x + (block.hitArea?.x || 0) + (block.hitArea?.width || 0),
        bottom: block.position.y + (block.hitArea?.y || 0) + (block.hitArea?.height || 0)
      };

      const visualRegion = {
        left: block.position.x,
        top: block.position.y,
        right: block.position.x + block.visualWidth,
        bottom: block.position.y + block.visualHeight
      };

      console.log(`\n   üìç Clickable Region (world coords):`);
      console.log(`      Left: ${clickableRegion.left}, Right: ${clickableRegion.right}`);
      console.log(`      Top: ${clickableRegion.top}, Bottom: ${clickableRegion.bottom}`);
      console.log(`      Size: ${clickableRegion.right - clickableRegion.left}x${clickableRegion.bottom - clickableRegion.top}px`);

      console.log(`\n   üìç Visual Region (red border):`);
      console.log(`      Left: ${visualRegion.left}, Right: ${visualRegion.right}`);
      console.log(`      Top: ${visualRegion.top}, Bottom: ${visualRegion.bottom}`);
      console.log(`      Size: ${block.visualWidth}x${block.visualHeight}px`);

      // Check for mismatch
      const mismatch = {
        left: clickableRegion.left !== visualRegion.left,
        top: clickableRegion.top !== visualRegion.top,
        right: clickableRegion.right !== visualRegion.right,
        bottom: clickableRegion.bottom !== visualRegion.bottom
      };

      if (mismatch.left || mismatch.top || mismatch.right || mismatch.bottom) {
        console.log(`\n   ‚ùå MISMATCH DETECTED!`);
        if (mismatch.left) console.log(`      Left edge: visual=${visualRegion.left} vs clickable=${clickableRegion.left} (diff=${clickableRegion.left - visualRegion.left}px)`);
        if (mismatch.top) console.log(`      Top edge: visual=${visualRegion.top} vs clickable=${clickableRegion.top} (diff=${clickableRegion.top - visualRegion.top}px)`);
        if (mismatch.right) console.log(`      Right edge: visual=${visualRegion.right} vs clickable=${clickableRegion.right} (diff=${clickableRegion.right - visualRegion.right}px)`);
        if (mismatch.bottom) console.log(`      Bottom edge: visual=${visualRegion.bottom} vs clickable=${clickableRegion.bottom} (diff=${clickableRegion.bottom - visualRegion.bottom}px)`);
      } else {
        console.log(`\n   ‚úÖ Visual and clickable regions match perfectly`);
      }

      // Test click detection at key points
      console.log(`\n   üñ±Ô∏è  Testing click detection at key points:`);

      const testPoints = [
        { name: 'Center', x: block.position.x + block.visualWidth / 2, y: block.position.y + block.visualHeight / 2 },
        { name: 'Top-Left corner', x: block.position.x + 5, y: block.position.y + 5 },
        { name: 'Top-Right corner', x: block.position.x + block.visualWidth - 5, y: block.position.y + 5 },
        { name: 'Bottom-Left corner', x: block.position.x + 5, y: block.position.y + block.visualHeight - 5 },
        { name: 'Bottom-Right corner', x: block.position.x + block.visualWidth - 5, y: block.position.y + block.visualHeight - 5 },
        { name: 'Left edge', x: block.position.x + 2, y: block.position.y + block.visualHeight / 2 },
        { name: 'Right edge', x: block.position.x + block.visualWidth - 2, y: block.position.y + block.visualHeight / 2 },
        { name: 'Top edge', x: block.position.x + block.visualWidth / 2, y: block.position.y + 2 },
        { name: 'Bottom edge', x: block.position.x + block.visualWidth / 2, y: block.position.y + block.visualHeight - 2 }
      ];

      for (const point of testPoints) {
        // Move mouse to point and check if pointerover event fires
        const detected = await page.evaluate(async ({ x, y, blockIndex }) => {
          const scene = (window as any).game.scene.scenes[0];
          const activeBlocks = Array.from(scene.blockPool.activeBlocks);
          const targetBlock = activeBlocks[blockIndex] as any;

          // Check if point is within hit area
          const hitArea = targetBlock.input?.hitArea;
          if (!hitArea) return false;

          // Convert world point to local block coordinates
          const localX = x - targetBlock.x;
          const localY = y - targetBlock.y;

          // Check if point is within hit area rectangle
          return localX >= hitArea.x &&
                 localX <= hitArea.x + hitArea.width &&
                 localY >= hitArea.y &&
                 localY <= hitArea.y + hitArea.height;
        }, { x: point.x, y: point.y, blockIndex: i });

        const status = detected ? '‚úÖ' : '‚ùå';
        console.log(`      ${status} ${point.name}: (${Math.round(point.x)}, ${Math.round(point.y)}) - ${detected ? 'DETECTED' : 'NOT DETECTED'}`);
      }

      console.log('');
    }

    console.log('='.repeat(80));
    console.log('\nüìä SUMMARY\n');

    // Generate summary report
    const summary = blocks.map((block, i) => {
      const visualSize = block.visualWidth * block.visualHeight;
      const hitAreaSize = (block.hitArea?.width || 0) * (block.hitArea?.height || 0);
      const coverage = visualSize > 0 ? ((hitAreaSize / visualSize) * 100).toFixed(1) : 0;

      return {
        index: i,
        id: block.id,
        visualSize: `${block.visualWidth}x${block.visualHeight}`,
        hitAreaSize: block.hitArea ? `${block.hitArea.width}x${block.hitArea.height}` : 'NONE',
        coverage: `${coverage}%`,
        match: visualSize === hitAreaSize
      };
    });

    console.log('Block Comparison:');
    summary.forEach(s => {
      const status = s.match ? '‚úÖ' : '‚ùå';
      console.log(`  ${status} Block ${s.index} (${s.id}): Visual=${s.visualSize}, HitArea=${s.hitAreaSize}, Coverage=${s.coverage}`);
    });

    console.log('\n='.repeat(80));
    console.log('‚úÖ MEASUREMENT TEST COMPLETE\n');

    // Take screenshot for visual inspection
    await page.screenshot({
      path: 'test-results/hit-area-measurement.png',
      fullPage: true
    });
    console.log('üì∏ Screenshot saved to test-results/hit-area-measurement.png\n');
  });
});
