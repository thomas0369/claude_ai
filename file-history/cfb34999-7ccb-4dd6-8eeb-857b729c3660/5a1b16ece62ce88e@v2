/**
 * Real Drag-and-Drop Test
 *
 * This test uses actual mouse drag-and-drop interaction to test the game,
 * unlike the autonomous tests which use programmatic placement.
 */

import { test, expect } from '@playwright/test';

test.describe('Real Drag and Drop Interaction', () => {

  test('Should be able to drag and drop blocks multiple times', async ({ page }) => {
    console.log('\nüéÆ TESTING REAL DRAG-AND-DROP INTERACTION\n');
    console.log('=' .repeat(80));

    test.setTimeout(180000); // 3 minutes

    // Listen to console logs
    page.on('console', msg => {
      const type = msg.type();
      if (type === 'error' || type === 'warning' || msg.text().includes('Block') || msg.text().includes('drag')) {
        console.log(`[BROWSER ${type.toUpperCase()}]`, msg.text());
      }
    });

    // Navigate to game
    await page.goto('/play/1', { waitUntil: 'networkidle', timeout: 60000 });
    console.log('‚úì Navigated to Level 1');

    // Wait for canvas
    await page.locator('canvas').waitFor({ state: 'visible', timeout: 30000 });
    console.log('‚úì Canvas visible');

    // Wait for game instance
    await page.waitForFunction(() => {
      return typeof (window as any).game !== 'undefined' &&
             typeof (window as any).gameDebug !== 'undefined';
    }, { timeout: 40000 });
    console.log('‚úì Game instance created');

    // Wait for game to be ready
    await page.waitForTimeout(8000);
    console.log('‚úì Game initialized');

    // Take initial screenshot
    await page.screenshot({ path: 'test-results/drag-drop-01-initial.png', fullPage: true });

    // Helper function to get block positions
    async function getBlockPositions() {
      return await page.evaluate(() => {
        const scene = (window as any).game.scene.scenes[0];
        const blockPool = (scene as any).blockPool;
        const activeBlocks = Array.from(blockPool.activeBlocks || []);

        return activeBlocks.map((block: any, idx: number) => ({
          index: idx,
          id: block.blockData?.id,
          x: Math.round(block.x),
          y: Math.round(block.y),
          width: block.width,
          height: block.height,
          isActive: block.active,
          isVisible: block.visible,
          isDragging: block.isDragging,
          hasInput: !!block.input,
          isDraggable: block.input?.draggable
        }));
      });
    }

    // Get initial block positions
    const initialBlocks = await getBlockPositions();
    console.log('\nüìç INITIAL BLOCKS:');
    initialBlocks.forEach(b => {
      console.log(`  Block ${b.index}: ${b.id} at (${b.x}, ${b.y}) size ${b.width}x${b.height}`);
      console.log(`    Active: ${b.isActive}, Visible: ${b.isVisible}, HasInput: ${b.hasInput}, Draggable: ${b.isDraggable}`);
    });

    expect(initialBlocks.length).toBe(3);

    // === ROUND 1: Place first 3 blocks ===
    console.log('\nüéØ ROUND 1: Placing first 3 blocks using drag-and-drop\n');

    for (let i = 0; i < 3; i++) {
      console.log(`\n--- Placing Block ${i} ---`);

      const blocks = await getBlockPositions();
      if (blocks.length === 0) {
        console.log('‚ö†Ô∏è  No blocks available!');
        break;
      }

      const block = blocks[0]; // Always use first available block
      console.log(`  Block to drag: ${block.id} at (${block.x}, ${block.y})`);

      // Get canvas element
      const canvas = page.locator('canvas');
      const canvasBox = await canvas.boundingBox();

      if (!canvasBox) {
        console.log('‚ùå Canvas not found');
        break;
      }

      console.log(`  Canvas: ${canvasBox.width}x${canvasBox.height} at (${canvasBox.x}, ${canvasBox.y})`);

      // Calculate block center in screen coordinates
      const blockCenterX = canvasBox.x + block.x + (block.width / 2);
      const blockCenterY = canvasBox.y + block.y + (block.height / 2);

      console.log(`  Block center (screen coords): (${Math.round(blockCenterX)}, ${Math.round(blockCenterY)})`);

      // Target position on grid (different for each block)
      const gridOffsetX = 200; // From GAME_CONFIG
      const gridOffsetY = 80;
      const cellSize = 40;

      // Place blocks in different positions
      const targetCol = i * 2;
      const targetRow = 0;

      const targetX = canvasBox.x + gridOffsetX + (targetCol * cellSize) + (cellSize / 2);
      const targetY = canvasBox.y + gridOffsetY + (targetRow * cellSize) + (cellSize / 2);

      console.log(`  Target position (screen coords): (${Math.round(targetX)}, ${Math.round(targetY)})`);
      console.log(`  Grid position: row ${targetRow}, col ${targetCol}`);

      try {
        // Perform drag and drop
        console.log('  üñ±Ô∏è  Performing drag and drop...');

        await page.mouse.move(blockCenterX, blockCenterY);
        await page.waitForTimeout(100);

        await page.mouse.down();
        await page.waitForTimeout(200);

        await page.mouse.move(targetX, targetY, { steps: 10 });
        await page.waitForTimeout(200);

        await page.mouse.up();
        await page.waitForTimeout(500);

        console.log('  ‚úÖ Drag completed');

        // Check if block was actually placed on grid
        const gridState = await page.evaluate(() => {
          const scene = (window as any).game.scene.scenes[0];
          const grid = scene.grid;
          let filledCells = 0;
          for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
              if (grid[row][col] !== 0) filledCells++;
            }
          }
          return { filledCells, grid: grid.map((row: number[]) => row.slice()) };
        });

        console.log(`  Grid filled cells: ${gridState.filledCells}`);

        // Take screenshot
        await page.screenshot({
          path: `test-results/drag-drop-round1-block${i + 1}.png`,
          fullPage: true
        });

      } catch (error) {
        console.log(`  ‚ùå Error during drag: ${error}`);
        throw error;
      }
    }

    // Check if blocks respawned
    await page.waitForTimeout(1000);

    const blocksAfterRound1 = await getBlockPositions();
    console.log('\nüìç BLOCKS AFTER ROUND 1:');
    blocksAfterRound1.forEach(b => {
      console.log(`  Block ${b.index}: ${b.id} at (${b.x}, ${b.y}) size ${b.width}x${b.height}`);
      console.log(`    Active: ${b.isActive}, Visible: ${b.isVisible}, HasInput: ${b.hasInput}, Draggable: ${b.isDraggable}`);
    });

    // === ROUND 2: Try to place respawned blocks ===
    console.log('\nüéØ ROUND 2: Placing next 3 blocks (RESPAWNED) using drag-and-drop\n');

    if (blocksAfterRound1.length === 0) {
      console.log('‚ùå NO BLOCKS RESPAWNED! This is the bug.');
      throw new Error('Blocks did not respawn after Round 1');
    }

    expect(blocksAfterRound1.length).toBe(3);

    // Try to drag one of the respawned blocks
    console.log('\n--- Attempting to drag first respawned block ---');

    const block = blocksAfterRound1[0];
    console.log(`  Block to drag: ${block.id} at (${block.x}, ${block.y})`);
    console.log(`  HasInput: ${block.hasInput}, Draggable: ${block.isDraggable}`);

    if (!block.hasInput) {
      console.log('‚ùå Block does not have input! This is the bug.');
      throw new Error('Respawned block is not interactive');
    }

    if (!block.isDraggable) {
      console.log('‚ùå Block is not draggable! This is the bug.');
      throw new Error('Respawned block is not draggable');
    }

    const canvas = page.locator('canvas');
    const canvasBox = await canvas.boundingBox();

    if (!canvasBox) {
      throw new Error('Canvas not found');
    }

    const blockCenterX = canvasBox.x + block.x + (block.width / 2);
    const blockCenterY = canvasBox.y + block.y + (block.height / 2);

    console.log(`  Block center (screen coords): (${Math.round(blockCenterX)}, ${Math.round(blockCenterY)})`);

    // Try to drag to grid position (3, 0)
    const gridOffsetX = 200;
    const gridOffsetY = 80;
    const cellSize = 40;

    const targetX = canvasBox.x + gridOffsetX + (3 * cellSize) + (cellSize / 2);
    const targetY = canvasBox.y + gridOffsetY + (0 * cellSize) + (cellSize / 2);

    console.log(`  Target position (screen coords): (${Math.round(targetX)}, ${Math.round(targetY)})`);

    try {
      console.log('  üñ±Ô∏è  Performing drag and drop on respawned block...');

      await page.mouse.move(blockCenterX, blockCenterY);
      await page.waitForTimeout(100);

      await page.mouse.down();
      await page.waitForTimeout(200);

      await page.mouse.move(targetX, targetY, { steps: 10 });
      await page.waitForTimeout(200);

      await page.mouse.up();
      await page.waitForTimeout(500);

      console.log('  ‚úÖ Drag completed on respawned block');

      // Take screenshot
      await page.screenshot({
        path: 'test-results/drag-drop-round2-success.png',
        fullPage: true
      });

    } catch (error) {
      console.log(`  ‚ùå Error during drag: ${error}`);

      // Take error screenshot
      await page.screenshot({
        path: 'test-results/drag-drop-round2-error.png',
        fullPage: true
      });

      throw error;
    }

    console.log('\n' + '='.repeat(80));
    console.log('‚úÖ DRAG-AND-DROP TEST COMPLETED SUCCESSFULLY');
    console.log('='.repeat(80) + '\n');
  });
});
