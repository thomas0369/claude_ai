import { prisma } from '@/lib/storage/postgres/client';
import { cacheHelper } from '@/lib/storage/redis/client';
import { NotFoundError } from '@/lib/utils/error-handling';

export interface LevelConfig {
  levelNumber: number;
  name: string;
  description: string;
  difficulty: number;
  tier: 'FREE' | 'TRIAL' | 'PREMIUM';
  gridConfig: {
    rows: number;
    cols: number;
  };
  targetScore: number;
  timeLimit: number | null;
  blocks: Array<{
    id: string;
    shape: number[][];
    color: string;
    frequency: number;
  }>;
  tutorial?: {
    enabled: boolean;
    steps?: string[];
  };
}

const CACHE_TTL = 3600; // 1 hour

export async function getLevelById(levelId: string): Promise<LevelConfig> {
  // Try cache first
  const cacheKey = `level:${levelId}`;
  const cached = await cacheHelper.get<LevelConfig>(cacheKey);
  if (cached) {
    return cached;
  }

  // Fetch from database
  const level = await prisma.level.findUnique({
    where: { id: levelId },
  });

  if (!level || !level.isActive) {
    throw new NotFoundError('Level');
  }

  // Load level configuration from JSON
  const levelConfig = await loadLevelConfig(level.levelNumber);

  // Cache the result
  await cacheHelper.set(cacheKey, levelConfig, CACHE_TTL);

  return levelConfig;
}

export async function getLevelByNumber(levelNumber: number): Promise<LevelConfig> {
  // Try cache first
  const cacheKey = `level:number:${levelNumber}`;
  const cached = await cacheHelper.get<LevelConfig>(cacheKey);
  if (cached) {
    return cached;
  }

  // Fetch from database
  const level = await prisma.level.findUnique({
    where: { levelNumber },
  });

  if (!level || !level.isActive) {
    throw new NotFoundError('Level');
  }

  // Load level configuration from JSON
  const levelConfig = await loadLevelConfig(level.levelNumber);

  // Cache the result
  await cacheHelper.set(cacheKey, levelConfig, CACHE_TTL);

  return levelConfig;
}

export async function getLevelsByTier(tier: 'FREE' | 'TRIAL' | 'PREMIUM') {
  const cacheKey = `levels:tier:${tier}`;
  const cached = await cacheHelper.get<LevelConfig[]>(cacheKey);
  if (cached) {
    return cached;
  }

  const levels = await prisma.level.findMany({
    where: {
      tier,
      isActive: true,
    },
    orderBy: {
      levelNumber: 'asc',
    },
  });

  const levelConfigs = await Promise.all(
    levels.map(level => loadLevelConfig(level.levelNumber))
  );

  await cacheHelper.set(cacheKey, levelConfigs, CACHE_TTL);

  return levelConfigs;
}

export async function getAllLevels() {
  const cacheKey = 'levels:all';
  const cached = await cacheHelper.get<LevelConfig[]>(cacheKey);
  if (cached) {
    return cached;
  }

  const levels = await prisma.level.findMany({
    where: {
      isActive: true,
    },
    orderBy: {
      levelNumber: 'asc',
    },
  });

  const levelConfigs = await Promise.all(
    levels.map(level => loadLevelConfig(level.levelNumber))
  );

  await cacheHelper.set(cacheKey, levelConfigs, CACHE_TTL);

  return levelConfigs;
}

async function loadLevelConfig(levelNumber: number): Promise<LevelConfig> {
  try {
    // In a real app, this would use fs.readFile on the server
    // For now, we'll construct the path for client-side fetch
    const response = await fetch(`/levels/level-${levelNumber}.json`);
    if (!response.ok) {
      throw new Error(`Failed to load level ${levelNumber} configuration`);
    }
    return await response.json();
  } catch (_error) {
    // Catch and rethrow as NotFoundError regardless of original error
    throw new NotFoundError(`Level ${levelNumber} configuration`);
  }
}
