/**
 * Game Debug Helper - Autonomous Block Control for Testing
 *
 * This module provides programmatic control over blocks for autonomous testing
 * of game rules without requiring manual interaction.
 */

import { GAME_CONFIG } from '../config';
import { phaserLogger } from '@/lib/utils/logger';

export interface PlacementResult {
  success: boolean;
  gridPosition: { row: number; col: number };
  cellsPlaced: number;
  linesCleared: number;
  score: number;
  message: string;
}

/**
 * Get the MainScene instance from the game
 */
function getMainScene(): any {
  const game = (window as any).game;
  if (!game) {
    throw new Error('Game instance not found on window');
  }

  const scene = game.scene.scenes[0];
  if (!scene) {
    throw new Error('MainScene not found');
  }

  return scene;
}

/**
 * Place a block at a specific grid position programmatically
 *
 * @param blockIndex - Index of the block to place (0, 1, or 2)
 * @param gridRow - Target grid row (0-7)
 * @param gridCol - Target grid column (0-7)
 */
export function placeBlockAt(blockIndex: number, gridRow: number, gridCol: number): PlacementResult {
  phaserLogger.debug('placeBlockAt called', { blockIndex, gridRow, gridCol });

  try {
    const scene = getMainScene();
    const blockPool = (scene as any).blockPool;

    if (!blockPool) {
      return {
        success: false,
        gridPosition: { row: gridRow, col: gridCol },
        cellsPlaced: 0,
        linesCleared: 0,
        score: (scene as any).score || 0,
        message: 'BlockPool not found'
      };
    }

    const activeBlocks = (blockPool as any).activeBlocks || [];

    if (activeBlocks.length === 0) {
      return {
        success: false,
        gridPosition: { row: gridRow, col: gridCol },
        cellsPlaced: 0,
        linesCleared: 0,
        score: (scene as any).score || 0,
        message: 'No active blocks available'
      };
    }

    if (blockIndex < 0 || blockIndex >= activeBlocks.length) {
      return {
        success: false,
        gridPosition: { row: gridRow, col: gridCol },
        cellsPlaced: 0,
        linesCleared: 0,
        score: (scene as any).score || 0,
        message: `Invalid block index: ${blockIndex} (available: 0-${activeBlocks.length - 1})`
      };
    }

    const block = activeBlocks[blockIndex];
    const blockData = (block as any).blockData;

    if (!blockData) {
      return {
        success: false,
        gridPosition: { row: gridRow, col: gridCol },
        cellsPlaced: 0,
        linesCleared: 0,
        score: (scene as any).score || 0,
        message: 'Block has no data'
      };
    }

    phaserLogger.debug('Placing block', {
      blockId: blockData.id,
      shape: blockData.shape,
      targetPosition: { row: gridRow, col: gridCol }
    });

    // Get scores before placement
    const scoreBefore = (scene as any).score || 0;
    const comboBefore = (scene as any).comboCount || 0;

    // Trigger the placement callback directly
    const onPlacedCallback = (block as any).onPlacedCallback;

    if (onPlacedCallback) {
      onPlacedCallback({
        shape: blockData.shape,
        color: blockData.color,
        row: gridRow,
        col: gridCol,
      });

      // Get scores after placement
      const scoreAfter = (scene as any).score || 0;
      const comboAfter = (scene as any).comboCount || 0;
      const linesCleared = comboAfter > comboBefore ? comboAfter - comboBefore : 0;

      phaserLogger.info(`Block placed successfully at (${gridRow}, ${gridCol})`);
      phaserLogger.info(`Score: ${scoreBefore} → ${scoreAfter} (${scoreAfter - scoreBefore > 0 ? '+' : ''}${scoreAfter - scoreBefore})`);

      return {
        success: true,
        gridPosition: { row: gridRow, col: gridCol },
        cellsPlaced: blockData.shape.flat().filter((c: number) => c === 1).length,
        linesCleared,
        score: scoreAfter,
        message: `Block ${blockData.id} placed at (${gridRow}, ${gridCol})`
      };
    } else {
      return {
        success: false,
        gridPosition: { row: gridRow, col: gridCol },
        cellsPlaced: 0,
        linesCleared: 0,
        score: scoreBefore,
        message: 'Block has no placement callback'
      };
    }

  } catch (error) {
    phaserLogger.error('Error placing block', error);
    return {
      success: false,
      gridPosition: { row: gridRow, col: gridCol },
      cellsPlaced: 0,
      linesCleared: 0,
      score: 0,
      message: `Error: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}

/**
 * Get current game state for debugging
 */
export function getGameState() {
  try {
    const scene = getMainScene();
    const blockPool = (scene as any).blockPool;
    const activeBlocks = (blockPool as any).activeBlocks || [];

    return {
      score: (scene as any).score || 0,
      combo: (scene as any).comboCount || 0,
      activeBlockCount: activeBlocks.length,
      activeBlocks: activeBlocks.map((block: any, idx: number) => ({
        index: idx,
        id: block.blockData?.id,
        shape: block.blockData?.shape,
        color: block.blockData?.color,
        position: { x: block.x, y: block.y }
      })),
      grid: (scene as any).grid,
    };
  } catch (error) {
    phaserLogger.error('Error getting game state', error);
    return null;
  }
}

/**
 * Get grid state as a visual representation
 */
export function getGridVisualization(): string {
  try {
    const scene = getMainScene();
    const grid = (scene as any).grid;

    if (!grid) return 'Grid not found';

    let visual = '\n╔════════════════╗\n';
    grid.forEach((row: number[], r: number) => {
      visual += '║';
      row.forEach((cell: number) => {
        visual += cell === 0 ? '  ' : '██';
      });
      visual += '║\n';
    });
    visual += '╚════════════════╝\n';

    return visual;
  } catch (error) {
    return 'Error visualizing grid';
  }
}

/**
 * Simulate drag and drop for a block
 */
export function simulateDrag(blockIndex: number, targetRow: number, targetCol: number): PlacementResult {
  phaserLogger.debug('simulateDrag called', { blockIndex, targetRow, targetCol });

  try {
    const scene = getMainScene();
    const blockPool = (scene as any).blockPool;

    if (!blockPool) {
      return {
        success: false,
        gridPosition: { row: targetRow, col: targetCol },
        cellsPlaced: 0,
        linesCleared: 0,
        score: (scene as any).score || 0,
        message: 'BlockPool not found'
      };
    }

    const activeBlocks = Array.from((blockPool as any).activeBlocks || []);

    if (blockIndex < 0 || blockIndex >= activeBlocks.length) {
      return {
        success: false,
        gridPosition: { row: targetRow, col: targetCol },
        cellsPlaced: 0,
        linesCleared: 0,
        score: (scene as any).score || 0,
        message: `Invalid block index: ${blockIndex}`
      };
    }

    const block = activeBlocks[blockIndex] as any;

    // Calculate target position
    const targetX = GAME_CONFIG.gridOffsetX + targetCol * GAME_CONFIG.cellSize;
    const targetY = GAME_CONFIG.gridOffsetY + targetRow * GAME_CONFIG.cellSize;

    // Use the block's simulateDragAndDrop method
    const wasPlaced = block.simulateDragAndDrop(targetX, targetY);

    const scoreAfter = (scene as any).score || 0;

    return {
      success: wasPlaced,
      gridPosition: { row: targetRow, col: targetCol },
      cellsPlaced: wasPlaced ? block.getBlockData().shape.flat().filter((c: number) => c === 1).length : 0,
      linesCleared: 0, // Would need to track this separately
      score: scoreAfter,
      message: wasPlaced ? `Block dragged and placed at (${targetRow}, ${targetCol})` : 'Block returned to original position'
    };

  } catch (error) {
    phaserLogger.error('Error simulating drag', error);
    return {
      success: false,
      gridPosition: { row: targetRow, col: targetCol },
      cellsPlaced: 0,
      linesCleared: 0,
      score: 0,
      message: `Error: ${error instanceof Error ? error.message : String(error)}`
    };
  }
}

/**
 * Get all available blocks information
 */
export function getAvailableBlocks() {
  try {
    const scene = getMainScene();
    const blockPool = (scene as any).blockPool;
    const activeBlocks = Array.from((blockPool as any).activeBlocks || []);

    return activeBlocks.map((block: any, index: number) => {
      const data = block.getBlockData();
      const pos = block.getPosition();
      return {
        index,
        id: data.id,
        shape: data.shape,
        color: data.color,
        position: pos,
        width: data.shape[0]?.length || 0,
        height: data.shape.length
      };
    });
  } catch (error) {
    phaserLogger.error('Error getting available blocks', error);
    return [];
  }
}

/**
 * Reset the game to initial state
 */
export function resetGame() {
  try {
    const scene = getMainScene();

    // Clear the grid
    (scene as any).grid = Array(GAME_CONFIG.gridRows)
      .fill(0)
      .map(() => Array(GAME_CONFIG.gridCols).fill(0));

    // Reset score and combo
    (scene as any).score = 0;
    (scene as any).comboCount = 0;

    // Redraw grid
    (scene as any).drawGrid();

    // Spawn new blocks
    (scene as any).spawnBlocks();

    phaserLogger.info('Game reset to initial state');
    return true;
  } catch (error) {
    phaserLogger.error('Error resetting game', error);
    return false;
  }
}

/**
 * Expose debug functions to window for E2E testing
 */
export function exposeDebugHelpers() {
  if (typeof window !== 'undefined') {
    (window as any).gameDebug = {
      placeBlockAt,
      simulateDrag,
      getGameState,
      getGridVisualization,
      getAvailableBlocks,
      resetGame,
    };

    phaserLogger.info('Game debug helpers exposed to window.gameDebug');
    phaserLogger.info('Available commands:');
    phaserLogger.info('  gameDebug.placeBlockAt(blockIndex, row, col) - Place a block directly');
    phaserLogger.info('  gameDebug.simulateDrag(blockIndex, row, col) - Simulate drag and drop');
    phaserLogger.info('  gameDebug.getGameState() - Get current game state');
    phaserLogger.info('  gameDebug.getGridVisualization() - Show grid as ASCII art');
    phaserLogger.info('  gameDebug.getAvailableBlocks() - List all active blocks');
    phaserLogger.info('  gameDebug.resetGame() - Reset game to initial state');

    // Also expose on the game instance for additional access
    const game = (window as any).game;
    if (game) {
      game.debugHelpers = {
        placeBlockAt,
        simulateDrag,
        getGameState,
        getGridVisualization,
        getAvailableBlocks,
        resetGame,
      };
      phaserLogger.info('Game debug helpers also exposed to window.game.debugHelpers');
    }
  }
}
