/**
 * Find what object is blocking the bottom-right corner
 */

import { test } from '@playwright/test';

test('Find what blocks bottom-right clicks', async ({ page }) => {
  console.log('\nüîç FINDING WHAT BLOCKS BOTTOM-RIGHT\n');
  console.log('='.repeat(80));

  test.setTimeout(60000);

  await page.goto('/play/1', { waitUntil: 'networkidle', timeout: 60000 });
  await page.locator('canvas').waitFor({ state: 'visible', timeout: 30000 });
  await page.waitForFunction(() => typeof (window as any).game !== 'undefined', { timeout: 40000 });
  await page.waitForTimeout(8000);

  console.log('‚úÖ Game loaded\n');

  const result = await page.evaluate(() => {
    const game = (window as any).game;
    const scene = game.scene.scenes[0];
    const blocks = Array.from(scene.blockPool.activeBlocks);

    const firstBlock = blocks[0];
    const shape = firstBlock.blockData.shape;
    const width = shape[0]?.length * 30;
    const height = shape.length * 30;

    const centerX = firstBlock.x + width / 2;
    const centerY = firstBlock.y + height / 2;
    const bottomRightX = firstBlock.x + width - 5;
    const bottomRightY = firstBlock.y + height - 5;

    // What does Phaser find at center?
    const centerHits = scene.input.hitTestPointer({
      x: centerX,
      y: centerY,
      worldX: centerX,
      worldY: centerY
    } as any);

    // What does Phaser find at bottom-right?
    const bottomRightHits = scene.input.hitTestPointer({
      x: bottomRightX,
      y: bottomRightY,
      worldX: bottomRightX,
      worldY: bottomRightY
    } as any);

    return {
      blockId: firstBlock.blockData.id,
      blockPos: { x: firstBlock.x, y: firstBlock.y },
      blockSize: { width, height },
      centerPos: { x: centerX, y: centerY },
      bottomRightPos: { x: bottomRightX, y: bottomRightY },
      centerHits: centerHits ? centerHits.map((obj: any) => ({
        type: obj.constructor.name,
        name: obj.name || 'unnamed',
        blockId: obj.blockData?.id || 'no id',
        texture: obj.texture?.key || 'no texture',
        depth: obj.depth,
        isOurBlock: obj.blockData?.id === firstBlock.blockData.id
      })) : [],
      bottomRightHits: bottomRightHits ? bottomRightHits.map((obj: any) => ({
        type: obj.constructor.name,
        name: obj.name || 'unnamed',
        blockId: obj.blockData?.id || 'no id',
        texture: obj.texture?.key || 'no texture',
        depth: obj.depth,
        isOurBlock: obj.blockData?.id === firstBlock.blockData.id
      })) : []
    };
  });

  console.log(`üì¶ Testing Block: ${result.blockId}`);
  console.log(`   Position: (${result.blockPos.x}, ${result.blockPos.y})`);
  console.log(`   Size: ${result.blockSize.width}x${result.blockSize.height}\n`);

  console.log(`üìç CENTER (${result.centerPos.x}, ${result.centerPos.y}):`);
  console.log(`   Objects found: ${result.centerHits.length}\n`);
  if (result.centerHits.length > 0) {
    result.centerHits.forEach((hit: any, idx: number) => {
      const marker = hit.isOurBlock ? '‚úÖ OUR BLOCK' : '‚ùå BLOCKING';
      console.log(`   ${idx + 1}. ${hit.type} (${hit.name}) ${marker}`);
      console.log(`      Block ID: ${hit.blockId}`);
      console.log(`      Texture: ${hit.texture}`);
      console.log(`      Depth: ${hit.depth}\n`);
    });
  }

  console.log(`üìç BOTTOM-RIGHT (${result.bottomRightPos.x}, ${result.bottomRightPos.y}):`);
  console.log(`   Objects found: ${result.bottomRightHits.length}\n`);
  if (result.bottomRightHits.length > 0) {
    result.bottomRightHits.forEach((hit: any, idx: number) => {
      const marker = hit.isOurBlock ? '‚úÖ OUR BLOCK' : '‚ùå BLOCKING';
      console.log(`   ${idx + 1}. ${hit.type} (${hit.name}) ${marker}`);
      console.log(`      Block ID: ${hit.blockId}`);
      console.log(`      Texture: ${hit.texture}`);
      console.log(`      Depth: ${hit.depth}\n`);
    });
  } else {
    console.log(`   ‚ö†Ô∏è  NO OBJECTS FOUND! Phaser's hit test returned empty!\n`);
  }

  console.log('='.repeat(80));
  console.log('‚úÖ BLOCKING OBJECT SEARCH COMPLETE\n');
});
