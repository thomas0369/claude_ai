/**
 * TEST: Control Phaser's pointer directly instead of using Playwright's mouse
 */

import { test, expect } from '@playwright/test';

test('Test blocks using Phaser pointer directly', async ({ page }) => {
  console.log('\nüéØ DIRECT PHASER POINTER TEST\n');
  console.log('='.repeat(80));

  test.setTimeout(120000);

  await page.goto('/play/1', { waitUntil: 'networkidle', timeout: 60000 });
  await page.locator('canvas').waitFor({ state: 'visible', timeout: 30000 });
  await page.waitForFunction(() => typeof (window as any).game !== 'undefined', { timeout: 40000 });
  await page.waitForTimeout(8000);

  console.log('‚úÖ Game loaded\n');

  // Test each block using Phaser's internal pointer
  const result = await page.evaluate(() => {
    const game = (window as any).game;
    const scene = game.scene.scenes[0];
    const blocks = Array.from(scene.blockPool.activeBlocks);

    const results = [];

    for (const block of blocks) {
      const shape = block.blockData.shape;
      const width = shape[0]?.length * 30;
      const height = shape.length * 30;

      const centerX = block.x + width / 2;
      const centerY = block.y + height / 2;
      const bottomRightX = block.x + width - 5;
      const bottomRightY = block.y + height - 5;

      // Test CENTER using Phaser's hit test
      const centerHitObjects = scene.input.hitTestPointer({
        x: centerX,
        y: centerY,
        worldX: centerX,
        worldY: centerY
      } as any);

      const centerHit = centerHitObjects && centerHitObjects.some((obj: any) => obj === block);

      // Test BOTTOM-RIGHT using Phaser's hit test
      const bottomRightHitObjects = scene.input.hitTestPointer({
        x: bottomRightX,
        y: bottomRightY,
        worldX: bottomRightX,
        worldY: bottomRightY
      } as any);

      const bottomRightHit = bottomRightHitObjects && bottomRightHitObjects.some((obj: any) => obj === block);

      // Get detailed hit area info
      const hitArea = block.input?.hitArea;

      // Test if point is in hit area using Phaser's geometry
      let centerInHitArea = false;
      let bottomRightInHitArea = false;

      if (hitArea) {
        // Convert world coordinates to local coordinates
        const centerLocal = new Phaser.Math.Vector2();
        block.getWorldTransformMatrix().applyInverse(centerX, centerY, centerLocal);

        const bottomRightLocal = new Phaser.Math.Vector2();
        block.getWorldTransformMatrix().applyInverse(bottomRightX, bottomRightY, bottomRightLocal);

        centerInHitArea = Phaser.Geom.Rectangle.Contains(hitArea, centerLocal.x, centerLocal.y);
        bottomRightInHitArea = Phaser.Geom.Rectangle.Contains(hitArea, bottomRightLocal.x, bottomRightLocal.y);
      }

      results.push({
        id: block.blockData.id,
        x: block.x,
        y: block.y,
        width,
        height,
        hitArea: hitArea ? {
          x: hitArea.x,
          y: hitArea.y,
          width: hitArea.width,
          height: hitArea.height
        } : null,
        center: {
          gameCoords: { x: centerX, y: centerY },
          hitByPhaser: centerHit,
          inHitArea: centerInHitArea
        },
        bottomRight: {
          gameCoords: { x: bottomRightX, y: bottomRightY },
          hitByPhaser: bottomRightHit,
          inHitArea: bottomRightInHitArea
        }
      });
    }

    return results;
  });

  console.log('üìä Phaser Direct Hit Test Results:\n');

  let allPassed = true;

  result.forEach((blockResult: any) => {
    console.log(`üì¶ Block ${blockResult.id}:`);
    console.log(`   Position: (${blockResult.x}, ${blockResult.y})`);
    console.log(`   Size: ${blockResult.width}x${blockResult.height}`);
    console.log(`   Hit Area: ${JSON.stringify(blockResult.hitArea)}\n`);

    console.log(`   CENTER TEST:`);
    console.log(`      Game Coords: (${blockResult.center.gameCoords.x}, ${blockResult.center.gameCoords.y})`);
    console.log(`      In Hit Area (geometry): ${blockResult.center.inHitArea ? '‚úÖ' : '‚ùå'}`);
    console.log(`      Hit by Phaser (hitTestPointer): ${blockResult.center.hitByPhaser ? '‚úÖ' : '‚ùå'}\n`);

    console.log(`   BOTTOM-RIGHT TEST:`);
    console.log(`      Game Coords: (${blockResult.bottomRight.gameCoords.x}, ${blockResult.bottomRight.gameCoords.y})`);
    console.log(`      In Hit Area (geometry): ${blockResult.bottomRight.inHitArea ? '‚úÖ' : '‚ùå'}`);
    console.log(`      Hit by Phaser (hitTestPointer): ${blockResult.bottomRight.hitByPhaser ? '‚úÖ' : '‚ùå'}\n`);

    if (!blockResult.center.inHitArea || !blockResult.center.hitByPhaser) {
      console.log(`   ‚ùå CENTER FAILED for ${blockResult.id}!\n`);
      allPassed = false;
    }

    if (!blockResult.bottomRight.inHitArea || !blockResult.bottomRight.hitByPhaser) {
      console.log(`   ‚ùå BOTTOM-RIGHT FAILED for ${blockResult.id}!\n`);
      allPassed = false;
    }

    console.log('‚îÄ'.repeat(80) + '\n');
  });

  console.log('='.repeat(80));
  if (allPassed) {
    console.log('‚úÖ ALL BLOCKS PASS PHASER HIT TESTS!\n');
  } else {
    console.log('‚ùå SOME BLOCKS FAILED HIT TESTS!\n');
    throw new Error('Blocks failed Phaser hit tests');
  }
});
