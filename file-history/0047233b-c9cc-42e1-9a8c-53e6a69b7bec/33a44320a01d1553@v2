"""
Time Series Data Extractor - Converts screening DataFrames to time series arrays.

This module extracts the last N candles from each timeframe's DataFrame
and formats them as arrays for the Nof1-style prompt (oldest → newest).
"""

from typing import Dict, List, Any
import pandas as pd
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class TimeSeriesExtractor:
    """Extracts time series arrays from screening DataFrames."""

    def __init__(self, lookback_periods: int = 10):
        """
        Initialize the extractor.

        Args:
            lookback_periods: Number of historical candles to include
        """
        self.lookback_periods = lookback_periods

    def extract_time_series(
        self,
        dataframes: Dict[str, pd.DataFrame]
    ) -> Dict[str, Dict[str, List[float]]]:
        """
        Extract time series arrays from multi-timeframe DataFrames.

        Args:
            dataframes: Dict mapping timeframe names to DataFrames
                       (e.g., {'h1': df_h1, 'h4': df_h4, ...})

        Returns:
            Dict mapping timeframe names to indicator time series
            Format: {
                'h1': {
                    'close': [1.0830, 1.0835, ...],
                    'ema_8': [1.0828, 1.0831, ...],
                    ...
                },
                'h4': {...},
                ...
            }
        """
        time_series_data = {}

        for tf_name, df in dataframes.items():
            if df is None or df.empty:
                logger.warning(f"No data for timeframe {tf_name}")
                continue

            # Extract last N candles (oldest → newest)
            tf_data = self._extract_timeframe_series(df)
            time_series_data[tf_name] = tf_data

        return time_series_data

    def _extract_timeframe_series(self, df: pd.DataFrame) -> Dict[str, List[float]]:
        """
        Extract indicator time series from a single timeframe DataFrame.

        Args:
            df: DataFrame with OHLCV and indicator columns

        Returns:
            Dict mapping indicator names to value arrays
        """
        # Get last N rows (oldest → newest)
        last_n = df.tail(self.lookback_periods)

        series_data = {}

        # Define which columns to extract
        # These match the columns created by indicators.calculate_indicators()
        columns_to_extract = {
            # OHLCV
            'close': 'close',
            'open': 'open',
            'high': 'high',
            'low': 'low',
            'volume': 'volume',

            # EMAs (Fibonacci periods)
            'ema_3': 'ema_3',
            'ema_8': 'ema_8',
            'ema_13': 'ema_13',
            'ema_21': 'ema_21',
            'ema_55': 'ema_55',
            'ema_89': 'ema_89',
            'ema_144': 'ema_144',
            'ema_200': 'ema_200',

            # Bollinger Bands
            'bb_upper': 'bb_upper',
            'bb_middle': 'bb_middle',
            'bb_lower': 'bb_lower',

            # Stochastic
            'stochastic_k': 'stoch_k',
            'stochastic_d': 'stoch_d',

            # Oscillators
            'rsi': 'rsi',
            'adx': 'adx',
            'ewo': 'ewo',
            'macd': 'macd_line',
            'macd_signal': 'macd_signal',
            'macd_histogram': 'macd_histogram',
        }

        for output_name, column_name in columns_to_extract.items():
            if column_name in last_n.columns:
                # Convert to list, handling NaN values
                values = last_n[column_name].fillna(0).tolist()
                series_data[output_name] = values
            else:
                logger.debug(f"Column {column_name} not found in DataFrame")

        return series_data

    def get_latest_values(
        self,
        dataframes: Dict[str, pd.DataFrame],
        timeframe: str = 'h1'
    ) -> Dict[str, float]:
        """
        Get the latest (current) values for all indicators in a specific timeframe.

        Args:
            dataframes: Dict mapping timeframe names to DataFrames
            timeframe: Which timeframe to extract from (default: h1)

        Returns:
            Dict mapping indicator names to current values
        """
        if timeframe not in dataframes or dataframes[timeframe] is None:
            logger.warning(f"Timeframe {timeframe} not available")
            return {}

        df = dataframes[timeframe]
        if df.empty:
            return {}

        # Get last row
        latest = df.iloc[-1]

        current_values = {}

        # Extract all available columns
        for col in df.columns:
            if col not in ['timestamp', 'date']:
                current_values[col] = latest[col] if not pd.isna(latest[col]) else 0.0

        return current_values

    def validate_time_series(
        self,
        time_series_data: Dict[str, Dict[str, List[float]]]
    ) -> bool:
        """
        Validate that time series data is complete and properly formatted.

        Args:
            time_series_data: Extracted time series data

        Returns:
            True if valid, False otherwise
        """
        if not time_series_data:
            logger.error("Time series data is empty")
            return False

        required_timeframes = ['m15', 'h1', 'h4', 'daily']
        missing_timeframes = [tf for tf in required_timeframes if tf not in time_series_data]

        if missing_timeframes:
            logger.warning(f"Missing timeframes: {missing_timeframes}")

        # Check that each timeframe has data
        for tf_name, tf_data in time_series_data.items():
            if not tf_data:
                logger.warning(f"No indicators in timeframe {tf_name}")
                continue

            # Check that arrays are the right length
            for indicator, values in tf_data.items():
                if len(values) < self.lookback_periods:
                    logger.warning(
                        f"{tf_name}.{indicator} has only {len(values)} values "
                        f"(expected {self.lookback_periods})"
                    )

                # Check for all NaN/zero
                if all(v == 0 for v in values):
                    logger.warning(f"{tf_name}.{indicator} is all zeros")

        return True


def extract_from_screening_dataframes(
    screening_dataframes: Dict[str, pd.DataFrame],
    lookback_periods: int = 10
) -> Dict[str, Dict[str, List[float]]]:
    """
    Convenience function to extract time series from screening DataFrames.

    Args:
        screening_dataframes: DataFrames from screener._calculate_indicators()
        lookback_periods: Number of candles to include

    Returns:
        Time series data formatted for prompt builder
    """
    extractor = TimeSeriesExtractor(lookback_periods=lookback_periods)
    time_series_data = extractor.extract_time_series(screening_dataframes)
    extractor.validate_time_series(time_series_data)
    return time_series_data
