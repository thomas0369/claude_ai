"""
Claude Trading Bot - Main orchestration for LLM-powered Elliott Wave trading.

This is the main entry point that coordinates:
1. Asset screening (signal detection)
2. Time series data collection
3. Prompt generation
4. Claude CLI integration
5. Trade execution/logging

Usage:
    python claude_trading_bot.py --mode paper --method cli
    python claude_trading_bot.py --mode live --method api --api-key YOUR_KEY
    python claude_trading_bot.py --mode backtest --simulate
"""

import argparse
import logging
from datetime import datetime, timezone
from typing import Dict, Any, List, Optional
import sys
from pathlib import Path

# Add src to path if needed
sys.path.insert(0, str(Path(__file__).parent))

from screener import AssetScreener
from time_series_extractor import extract_from_screening_dataframes
from claude_prompt_builder import ClaudePromptBuilder
from claude_integration import create_claude_trader, ClaudeIntegrationError, ClaudeResponseError
from trade_history_manager import TradeHistoryManager
from performance_metrics import calculate_performance
import config

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class ClaudeTradingBot:
    """Main orchestration class for Claude-powered Elliott Wave trading."""

    def __init__(
        self,
        mode: str = "paper",  # "paper", "live", or "backtest"
        claude_method: str = "cli",  # "cli" or "api"
        api_key: Optional[str] = None,
        simulate: bool = False,
        initial_capital: float = 100.0
    ):
        """
        Initialize the Claude trading bot.

        Args:
            mode: Trading mode - "paper", "live", or "backtest"
            claude_method: "cli" or "api"
            api_key: Anthropic API key (for "api" method)
            simulate: Use simulated Claude responses (for testing)
            initial_capital: Starting capital in EUR
        """
        self.mode = mode
        self.initial_capital = initial_capital

        logger.info(f"Initializing Claude Trading Bot in {mode} mode")

        # Initialize components
        self.screener = AssetScreener()
        self.prompt_builder = ClaudePromptBuilder(session_start_time=datetime.now(timezone.utc))
        self.claude = create_claude_trader(
            method=claude_method,
            api_key=api_key,
            simulate=simulate
        )
        self.trade_history = TradeHistoryManager()

        logger.info("Claude Trading Bot initialized successfully")

    def run_screening(self, symbols: Optional[List[str]] = None) -> List[Dict[str, Any]]:
        """
        Run the screener on specified symbols.

        Args:
            symbols: List of symbols to screen (or None for all configured symbols)

        Returns:
            List of screening results
        """
        if symbols is None:
            symbols = config.ALL_ASSETS

        logger.info(f"Screening {len(symbols)} symbols...")

        results = []
        for symbol in symbols:
            try:
                result = self.screener.screen_asset(symbol)
                if result:
                    results.append(result)
                    logger.info(
                        f"{symbol}: Score {result['score']}/194, "
                        f"Direction: {result['direction']}, "
                        f"Tradeable: {result['tradeable']}"
                    )
            except Exception as e:
                logger.error(f"Error screening {symbol}: {e}")

        # Sort by score (highest first)
        results.sort(key=lambda x: x['score'], reverse=True)

        return results

    def analyze_with_claude(
        self,
        screening_result: Dict[str, Any],
        screening_dataframes: Dict[str, Any]
    ) -> Optional[Dict[str, Any]]:
        """
        Send screening result to Claude for analysis.

        Args:
            screening_result: Output from AssetScreener.screen_asset()
            screening_dataframes: DataFrames from screener (for time series extraction)

        Returns:
            Claude's trading decision, or None if analysis fails
        """
        symbol = screening_result['symbol']
        logger.info(f"Analyzing {symbol} with Claude...")

        try:
            # Extract time series data
            time_series_data = extract_from_screening_dataframes(screening_dataframes)

            # Get account state
            account_state = self.trade_history.get_account_state(self.initial_capital)

            # Get recent trade history
            recent_trades = self.trade_history.get_recent_trades(count=5)

            # Calculate performance metrics
            current_capital = account_state['available_capital']
            performance_metrics = calculate_performance(
                self.trade_history.get_closed_trades(),
                current_capital,
                self.initial_capital
            )

            # Build prompts
            system_prompt, user_prompt = self.prompt_builder.get_complete_prompt(
                screening_result=screening_result,
                time_series_data=time_series_data,
                account_state=account_state,
                trade_history=recent_trades,
                performance_metrics=performance_metrics
            )

            # Save prompts to file for debugging
            self._save_prompts(symbol, system_prompt, user_prompt)

            # Get Claude's decision
            decision = self.claude.analyze_trade(
                system_prompt=system_prompt,
                user_prompt=user_prompt,
                screening_result=screening_result  # For simulator
            )

            logger.info(
                f"Claude decision for {symbol}: {decision['signal'].upper()} "
                f"(confidence: {decision['confidence']:.2f})"
            )

            return decision

        except (ClaudeIntegrationError, ClaudeResponseError) as e:
            logger.error(f"Claude analysis failed for {symbol}: {e}")
            return None
        except Exception as e:
            logger.error(f"Unexpected error analyzing {symbol}: {e}", exc_info=True)
            return None

    def execute_decision(
        self,
        symbol: str,
        screening_result: Dict[str, Any],
        claude_decision: Dict[str, Any]
    ) -> None:
        """
        Execute or log Claude's trading decision.

        Args:
            symbol: Trading symbol
            screening_result: Screener output
            claude_decision: Claude's decision
        """
        signal = claude_decision['signal']

        if signal == 'hold':
            logger.info(
                f"HOLD {symbol}: {claude_decision.get('justification', 'No justification provided')}"
            )
            self._log_hold_decision(symbol, screening_result, claude_decision)
            return

        if signal in ['buy', 'sell']:
            direction = 'long' if signal == 'buy' else 'short'

            # Extract trade parameters
            entry_price = screening_result['current_price']
            stop_loss = claude_decision['exit_plan']['stop_loss']
            take_profit = claude_decision['exit_plan']['take_profit']
            position_size = claude_decision.get('position_size_eur', 10.0)
            leverage = claude_decision.get('leverage', screening_result['leverage'])

            if self.mode == 'paper':
                logger.info(f"[PAPER TRADE] Opening {direction.upper()} {symbol}")
                logger.info(f"  Entry: {entry_price:.5f}")
                logger.info(f"  Stop: {stop_loss:.5f}")
                logger.info(f"  Target: {take_profit:.5f}")
                logger.info(f"  Size: {position_size:.2f} EUR @ {leverage}x leverage")
                logger.info(f"  Confidence: {claude_decision['confidence']:.2f}")
                logger.info(f"  Wave Count: {claude_decision.get('wave_count', 'N/A')}")
                logger.info(f"  Reasoning: {claude_decision.get('justification', 'N/A')}")

                # Add to trade history
                trade_id = self.trade_history.add_trade(
                    symbol=symbol,
                    direction=direction,
                    entry_price=entry_price,
                    stop_loss=stop_loss,
                    take_profit=take_profit,
                    position_size=position_size,
                    leverage=leverage,
                    llm_decision=claude_decision,
                    screening_score=screening_result['score']
                )

                logger.info(f"Trade recorded with ID: {trade_id}")

            elif self.mode == 'live':
                logger.warning("[LIVE TRADING] Live execution not yet implemented")
                logger.warning("Would execute trade:")
                logger.warning(f"  {direction.upper()} {symbol} @ {entry_price}")
                # TODO: Integrate with actual broker API

            else:  # backtest
                logger.info(f"[BACKTEST] Simulated {direction.upper()} {symbol}")

        elif signal == 'close':
            logger.info(f"CLOSE signal for {symbol}")
            # Find and close open position
            open_trades = self.trade_history.get_open_trades()
            for trade in open_trades:
                if trade['symbol'] == symbol:
                    self.trade_history.close_trade(
                        trade_id=trade['trade_id'],
                        exit_price=screening_result['current_price'],
                        exit_reason='claude_signal'
                    )
                    logger.info(f"Closed position for {symbol}")

    def _save_prompts(self, symbol: str, system_prompt: str, user_prompt: str) -> None:
        """Save prompts to file for debugging and analysis."""
        output_dir = Path("data/prompts")
        output_dir.mkdir(parents=True, exist_ok=True)

        timestamp = datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S')
        filename = output_dir / f"{symbol.replace('/', '_')}_{timestamp}.txt"

        with open(filename, 'w') as f:
            f.write("=" * 80 + "\n")
            f.write("SYSTEM PROMPT\n")
            f.write("=" * 80 + "\n\n")
            f.write(system_prompt)
            f.write("\n\n" + "=" * 80 + "\n")
            f.write("USER PROMPT\n")
            f.write("=" * 80 + "\n\n")
            f.write(user_prompt)

        logger.debug(f"Saved prompts to {filename}")

    def _log_hold_decision(
        self,
        symbol: str,
        screening_result: Dict[str, Any],
        claude_decision: Dict[str, Any]
    ) -> None:
        """Log a hold decision for future analysis."""
        log_file = Path("data/hold_decisions.jsonl")
        log_file.parent.mkdir(parents=True, exist_ok=True)

        import json
        with open(log_file, 'a') as f:
            log_entry = {
                'timestamp': datetime.now(timezone.utc).isoformat(),
                'symbol': symbol,
                'screening_score': screening_result['score'],
                'claude_confidence': claude_decision['confidence'],
                'reasoning': claude_decision.get('justification'),
                'concerns': claude_decision.get('concerns')
            }
            f.write(json.dumps(log_entry) + '\n')

    def run_single_scan(self, symbols: Optional[List[str]] = None) -> None:
        """
        Run a single screening scan and analyze top opportunities.

        Args:
            symbols: Symbols to screen (None for all configured)
        """
        logger.info("=" * 80)
        logger.info("Starting single scan")
        logger.info("=" * 80)

        # Screen assets
        results = self.run_screening(symbols)

        if not results:
            logger.info("No screening results available")
            return

        # Filter to tradeable setups (score >= 75)
        tradeable = [r for r in results if r['tradeable']]

        if not tradeable:
            logger.info(f"No tradeable setups found (all scores < 75)")
            logger.info(f"Top score: {results[0]['score']}/194 ({results[0]['symbol']})")
            return

        logger.info(f"Found {len(tradeable)} tradeable setups")

        # Analyze top tradeable setups with Claude
        for result in tradeable[:3]:  # Top 3 tradeable setups
            symbol = result['symbol']
            logger.info(f"\n{'=' * 80}")
            logger.info(f"Analyzing {symbol} (Score: {result['score']}/194)")
            logger.info(f"{'=' * 80}")

            # Get the DataFrames for time series extraction
            # We need to run screen_asset again to get the dataframes
            # (or modify screener to return them)
            screening_dataframes = self.screener._fetch_multi_timeframe_data(symbol)
            if screening_dataframes:
                screening_dataframes = self.screener._calculate_indicators(screening_dataframes)

                # Analyze with Claude
                decision = self.analyze_with_claude(result, screening_dataframes)

                if decision:
                    # Execute or log the decision
                    self.execute_decision(symbol, result, decision)
                else:
                    logger.warning(f"No decision received from Claude for {symbol}")

        logger.info("\n" + "=" * 80)
        logger.info("Scan complete")
        logger.info("=" * 80)

    def show_performance_summary(self) -> None:
        """Display performance summary."""
        closed_trades = self.trade_history.get_closed_trades()
        account_state = self.trade_history.get_account_state(self.initial_capital)
        performance = calculate_performance(
            closed_trades,
            account_state['available_capital'],
            self.initial_capital
        )

        from performance_metrics import PerformanceMetrics
        calculator = PerformanceMetrics(self.initial_capital)
        report = calculator.format_metrics_report(performance)

        print("\n" + report)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Claude Trading Bot - LLM-powered Elliott Wave trading"
    )

    parser.add_argument(
        '--mode',
        choices=['paper', 'live', 'backtest'],
        default='paper',
        help='Trading mode (default: paper)'
    )

    parser.add_argument(
        '--method',
        choices=['cli', 'api'],
        default='cli',
        help='Claude integration method (default: cli)'
    )

    parser.add_argument(
        '--api-key',
        type=str,
        help='Anthropic API key (or set ANTHROPIC_API_KEY env var)'
    )

    parser.add_argument(
        '--simulate',
        action='store_true',
        help='Use simulated Claude responses (for testing/backtesting)'
    )

    parser.add_argument(
        '--symbols',
        nargs='+',
        help='Symbols to screen (default: all configured symbols)'
    )

    parser.add_argument(
        '--show-performance',
        action='store_true',
        help='Show performance summary and exit'
    )

    args = parser.parse_args()

    # Create bot
    bot = ClaudeTradingBot(
        mode=args.mode,
        claude_method=args.method,
        api_key=args.api_key,
        simulate=args.simulate
    )

    # Show performance if requested
    if args.show_performance:
        bot.show_performance_summary()
        return

    # Run single scan
    bot.run_single_scan(symbols=args.symbols)


if __name__ == '__main__':
    main()
