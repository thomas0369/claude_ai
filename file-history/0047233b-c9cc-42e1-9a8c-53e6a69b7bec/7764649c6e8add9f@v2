"""
Claude Prompt Builder - Generates Nof1-style prompts for Elliott Wave trading decisions.

This module creates structured prompts following the Nof1 Alpha Arena pattern:
- Multi-timeframe data ordered oldest → newest
- Explicit scoring breakdowns
- Account state and performance metrics
- Trade history with LLM reasoning
- Clear task definition with structured output requirements
"""

from datetime import datetime, timezone
from typing import Dict, List, Any, Optional
import json


class ClaudePromptBuilder:
    """Builds structured prompts for Claude CLI following Nof1 best practices."""

    def __init__(self, session_start_time: Optional[datetime] = None):
        """
        Initialize the prompt builder.

        Args:
            session_start_time: When the trading session started (for time context)
        """
        self.session_start_time = session_start_time or datetime.now(timezone.utc)
        self.system_prompt = self._build_system_prompt()

    def _build_system_prompt(self) -> str:
        """
        Build the fixed system prompt that defines Claude's role and constraints.

        Returns:
            System prompt string
        """
        return """You are an expert Elliott Wave trader analyzing forex, crypto, and commodity markets.

Your task: Analyze the provided market data and technical indicators to make a high-conviction trading decision.

CRITICAL RULES:
1. Only trade when setup scores ≥75 points (out of 194)
2. Focus on fewer, larger, high-conviction positions
3. Always provide explicit exit plans (stop loss, take profit, invalidation)
4. Consider multi-timeframe confluence (Daily → 4H → 1H → 15M)
5. Respect Fibonacci ratios and Elliott Wave principles
6. Account for current risk exposure and position sizing
7. If the setup is tradeable but has conflicting signals, explain the conflicts

ELLIOTT WAVE PRINCIPLES TO FOLLOW:
- Wave 3 is never the shortest impulse wave
- Wave 2 cannot retrace more than 100% of Wave 1
- Wave 4 cannot overlap Wave 1 in an impulse (except in diagonals)
- Fibonacci relationships: Wave 2 often 50-61.8%, Wave 4 often 38.2-50%
- Wave 5 targets: 61.8%, 100%, or 161.8% extension of Wave 1
- Divergence at Wave 5 suggests trend exhaustion

OUTPUT FORMAT (STRICT JSON):
{
  "signal": "buy|sell|hold|close",
  "confidence": 0.0-1.0,
  "position_size_eur": number,
  "leverage": 3|5|8,
  "justification": "string (2-3 sentences explaining the Elliott Wave count and setup)",
  "exit_plan": {
    "stop_loss": number,
    "take_profit": number,
    "invalidation_level": number,
    "invalidation_reason": "string (what would prove this wave count wrong?)"
  },
  "wave_count": "string (e.g., 'Wave 3 of larger degree Wave 5')",
  "risk_reward_ratio": number,
  "concerns": "string (any conflicting signals or risks to be aware of)"
}

IMPORTANT: Return ONLY the JSON object, no additional text or explanation."""

    def build_user_prompt(
        self,
        screening_result: Dict[str, Any],
        time_series_data: Dict[str, Any],
        account_state: Dict[str, Any],
        trade_history: List[Dict[str, Any]],
        performance_metrics: Dict[str, Any]
    ) -> str:
        """
        Build the dynamic user prompt with current market state.

        Args:
            screening_result: Output from AssetScreener.screen_asset()
            time_series_data: Time series arrays for each timeframe
            account_state: Current account balance, positions, risk exposure
            trade_history: Last 3-5 trades with LLM reasoning and outcomes
            performance_metrics: Sharpe ratio, win rate, avg R:R

        Returns:
            User prompt string
        """
        # Calculate session duration
        minutes_trading = int((datetime.now(timezone.utc) - self.session_start_time).total_seconds() / 60)

        symbol = screening_result['symbol']
        current_time = screening_result['timestamp']

        prompt = f"""It has been {minutes_trading} minutes since you started trading.
Current UTC time: {current_time}

Below, we are providing you with multi-timeframe Elliott Wave analysis, Fibonacci-optimized
technical indicators, and a comprehensive scoring breakdown (max 194 points) so you can
make informed trading decisions.

**ALL OF THE PRICE AND INDICATOR DATA BELOW IS ORDERED: OLDEST → NEWEST**

**Timeframes:** Daily (macro trend), 4-Hour (swing direction), 1-Hour (setup), 15-Minute (entry timing)

---

### {symbol} DETAILED ANALYSIS

**Current State:**
current_price = {screening_result['current_price']:.5f}
"""

        # Add current indicator snapshot from H1 timeframe (primary)
        if 'indicators' in screening_result and 'h1' in screening_result['indicators']:
            h1 = screening_result['indicators']['h1']
            prompt += f"current_ema_8 = {h1.get('ema_8', 'N/A'):.5f}, "
            prompt += f"current_ema_21 = {h1.get('ema_21', 'N/A'):.5f}\n"
            prompt += f"current_rsi_14 = {h1.get('rsi', 'N/A'):.2f}, "
            prompt += f"current_ewo = {h1.get('ewo', 'N/A'):.6f}, "
            prompt += f"current_adx = {h1.get('adx', 'N/A'):.2f}\n"

        # Screening score
        prompt += f"\n**Elliott Wave Screening Score: {screening_result['score']} / 194 points**\n"

        if screening_result['score'] >= 85:
            quality = "HIGH"
        elif screening_result['score'] >= 75:
            quality = "MODERATE"
        else:
            quality = "LOW"

        prompt += f"Signal Quality: {quality} (threshold: 75+, optimal: 85+)\n"
        prompt += f"Direction: {screening_result['direction'].upper()}\n\n"

        # Score breakdown
        prompt += "**Score Breakdown:**\n"
        breakdown = screening_result.get('score_breakdown', {})
        score_descriptions = {
            'ema_structure': 'EMA Structure (perfect Fibonacci alignment)',
            'fibonacci_levels': 'Fibonacci Levels (price at key retracement)',
            'elliott_wave_oscillator': 'Elliott Wave Oscillator (momentum)',
            'divergence': 'Divergence Detection (trend exhaustion)',
            'fibonacci_bounce': 'Fibonacci Bounce (continuation setup)',
            'stochastic': 'Stochastic (oversold/overbought)',
            'bollinger_bands': 'Bollinger Bands (squeeze/expansion)',
            'adx': 'ADX (trend strength)',
            'volume': 'Volume (above average confirmation)',
            'confluence': 'Confluence Bonus (multi-indicator alignment)',
            'elliott_wave_pattern': 'Elliott Wave Pattern (swing counting)',
            'fibonacci_time': 'Fibonacci Time (period alignment)'
        }

        for key, description in score_descriptions.items():
            score = breakdown.get(key, 0)
            prompt += f"- {description}: {score} pts\n"

        prompt += "\n---\n\n"

        # Add time series data for each timeframe
        prompt += self._format_timeframe_data(time_series_data, screening_result)

        # Add account information
        prompt += self._format_account_state(account_state, performance_metrics)

        # Add trade history
        prompt += self._format_trade_history(trade_history)

        # Add screener recommendations
        prompt += self._format_screener_recommendations(screening_result)

        # Add task definition
        prompt += self._format_task_definition()

        return prompt

    def _format_timeframe_data(
        self,
        time_series_data: Dict[str, Any],
        screening_result: Dict[str, Any]
    ) -> str:
        """Format time series data for each timeframe."""
        output = ""

        timeframe_order = [
            ('m15', '15-MINUTE TIMEFRAME (Entry Timing)'),
            ('h1', '1-HOUR TIMEFRAME (Setup Identification)'),
            ('h4', '4-HOUR TIMEFRAME (Swing Direction)'),
            ('daily', 'DAILY TIMEFRAME (Macro Trend Filter)')
        ]

        for tf_key, tf_title in timeframe_order:
            if tf_key not in time_series_data:
                continue

            tf_data = time_series_data[tf_key]
            output += f"**{tf_title}:**\n\n"
            output += "Last 10 candles (oldest → newest):\n"

            # Format each indicator as an array
            if 'close' in tf_data:
                output += f"Close prices: {self._format_array(tf_data['close'])}\n"
            if 'ema_8' in tf_data:
                output += f"EMA 8: {self._format_array(tf_data['ema_8'])}\n"
            if 'ema_21' in tf_data:
                output += f"EMA 21: {self._format_array(tf_data['ema_21'])}\n"
            if 'rsi' in tf_data:
                output += f"RSI (14): {self._format_array(tf_data['rsi'])}\n"
            if 'stochastic_k' in tf_data:
                output += f"Stochastic K: {self._format_array(tf_data['stochastic_k'])}\n"
            if 'ewo' in tf_data:
                output += f"Elliott Wave Oscillator: {self._format_array(tf_data['ewo'])}\n"
            if 'macd' in tf_data:
                output += f"MACD: {self._format_array(tf_data['macd'])}\n"

            # Add interpretation for this timeframe
            output += f"\n{self._interpret_timeframe(tf_key, tf_data, screening_result)}\n"
            output += "\n---\n\n"

        return output

    def _format_array(self, values: List[float], precision: int = 5) -> str:
        """Format a list of values as a compact array string."""
        if not values:
            return "[]"

        # Determine if values are prices (> 1) or indicators (< 1)
        if abs(values[0]) > 1:
            # Prices or large indicators
            formatted = [f"{v:.{min(precision, 2)}f}" for v in values]
        else:
            # Small indicators (like EWO)
            formatted = [f"{v:.6f}" for v in values]

        return "[" + ", ".join(formatted) + "]"

    def _interpret_timeframe(
        self,
        tf_key: str,
        tf_data: Dict[str, List[float]],
        screening_result: Dict[str, Any]
    ) -> str:
        """Add brief interpretation of the timeframe data."""
        interpretation = ""

        if tf_key == 'm15':
            # Entry timing interpretation
            if 'stochastic_k' in tf_data and len(tf_data['stochastic_k']) >= 2:
                last_stoch = tf_data['stochastic_k'][-1]
                prev_stoch = tf_data['stochastic_k'][-2]
                if last_stoch > prev_stoch and last_stoch < 40:
                    interpretation += "Current momentum: Stochastic turning up from oversold\n"
                elif last_stoch < prev_stoch and last_stoch > 60:
                    interpretation += "Current momentum: Stochastic turning down from overbought\n"

            if 'ema_8' in tf_data and 'ema_21' in tf_data:
                if tf_data['ema_8'][-1] > tf_data['ema_21'][-1]:
                    interpretation += "Entry signal: Bullish (EMA 8 > 21)\n"
                else:
                    interpretation += "Entry signal: Bearish (EMA 8 < 21)\n"

        elif tf_key == 'h1':
            # Setup identification
            indicators = screening_result.get('indicators', {}).get('h1', {})

            if indicators.get('fibonacci_bounce'):
                fib_level = indicators.get('fibonacci_level', 'N/A')
                fib_conf = indicators.get('fibonacci_confidence', 0)
                interpretation += f"Fibonacci Analysis:\n"
                interpretation += f"- Price bounced from {fib_level} retracement level\n"
                interpretation += f"- Bounce confidence: {fib_conf:.0%}\n"

            # Divergence check
            rsi_div = indicators.get('rsi_divergence', 'none')
            macd_div = indicators.get('macd_divergence', 'none')
            vol_div = indicators.get('volume_divergence', 'none')

            interpretation += "\nDivergence Check:\n"
            interpretation += f"- RSI Divergence: {rsi_div.title()}\n"
            interpretation += f"- MACD Divergence: {macd_div.title()}\n"
            interpretation += f"- Volume Divergence: {vol_div.title()}\n"

        elif tf_key == 'h4':
            # Swing direction
            if 'ema_8' in tf_data and 'ema_21' in tf_data:
                ema8 = tf_data['ema_8'][-1]
                ema21 = tf_data['ema_21'][-1]
                structure = "Bullish" if ema8 > ema21 else "Bearish"
                interpretation += f"EMA Structure: {structure} (EMA 8 vs EMA 21)\n"

            if 'macd' in tf_data and len(tf_data['macd']) >= 2:
                macd_trend = "rising" if tf_data['macd'][-1] > tf_data['macd'][-5] else "falling"
                interpretation += f"MACD Trend: {macd_trend} (momentum building)\n"

        elif tf_key == 'daily':
            # Macro trend
            indicators = screening_result.get('indicators', {}).get('daily', {})
            adx = indicators.get('adx', 0)
            trend_strength = "strong" if adx > 25 else "weak"
            interpretation += f"Trend Structure: ADX = {adx:.1f} ({trend_strength} trend)\n"

            # Elliott Wave context
            interpretation += "\nElliott Wave Count:\n"
            interpretation += "- Current position: Wave 3 of larger degree Wave 5\n"
            interpretation += "- Wave structure: Impulsive (5-wave pattern developing)\n"

        return interpretation

    def _format_account_state(
        self,
        account_state: Dict[str, Any],
        performance_metrics: Dict[str, Any]
    ) -> str:
        """Format account state and performance metrics."""
        output = "### YOUR ACCOUNT INFORMATION & PERFORMANCE\n\n"

        total_return = performance_metrics.get('total_return_pct', 0)
        output += f"**Current Total Return:** {total_return:+.2f}%\n"
        output += f"**Available Capital:** {account_state.get('available_capital', 0):.2f} EUR\n"

        open_positions = account_state.get('open_positions', [])
        output += f"**Open Positions:** {len(open_positions)}\n"

        risk_exposure = account_state.get('risk_exposure', 0)
        output += f"**Risk Exposure:** {risk_exposure:.2f} EUR ({risk_exposure / account_state.get('available_capital', 1) * 100:.1f}%)\n"

        max_position = account_state.get('max_position_size', 10)
        output += f"**Max Position Size:** {max_position:.2f} EUR (10% per trade rule)\n\n"

        output += "**Performance Metrics:**\n"
        output += f"- Win Rate: {performance_metrics.get('win_rate', 0):.1f}%\n"
        output += f"- Average Risk:Reward: {performance_metrics.get('avg_risk_reward', 0):.1f}:1\n"
        output += f"- Sharpe Ratio: {performance_metrics.get('sharpe_ratio', 0):.2f}\n"
        output += f"- Max Drawdown: {performance_metrics.get('max_drawdown', 0):.2f}%\n\n"

        # Show open positions if any
        if open_positions:
            output += "**Current Open Positions:**\n\n"
            for pos in open_positions:
                output += f"- {pos['symbol']} {pos['direction'].upper()} @ {pos['entry_price']:.5f}\n"
                output += f"  - Unrealized P&L: {pos['unrealized_pnl']:+.2f} EUR\n"
                output += f"  - Stop Loss: {pos['stop_loss']:.5f}\n"
                output += f"  - Take Profit: {pos['take_profit']:.5f}\n"
                if 'exit_plan' in pos:
                    output += f"  - Original reasoning: \"{pos['exit_plan'].get('invalidation_condition', 'N/A')}\"\n"
                output += "\n"

        return output

    def _format_trade_history(self, trade_history: List[Dict[str, Any]]) -> str:
        """Format recent trade history with LLM reasoning."""
        if not trade_history:
            return "**Recent Trade History:** No trades yet\n\n---\n\n"

        output = f"**Recent Trade History (Last {len(trade_history)} trades, oldest → newest):**\n\n"

        for i, trade in enumerate(trade_history[-5:], 1):  # Last 5 trades max
            symbol = trade['symbol']
            direction = trade['direction'].upper()
            entry = trade['entry_price']
            exit_price = trade.get('exit_price', entry)
            pnl = trade.get('pnl', 0)
            pnl_pct = trade.get('pnl_pct', 0)

            outcome = "Closed" if 'exit_price' in trade else "Open"

            output += f"{i}. {symbol} {direction} @ {entry:.5f} → {outcome} @ {exit_price:.5f} "
            output += f"({pnl:+.2f} EUR, {pnl_pct:+.2f}%)\n"

            # LLM's original reasoning
            if 'llm_reasoning' in trade:
                reasoning = trade['llm_reasoning']
                output += f"   - Entry reasoning: \"{reasoning.get('justification', 'N/A')}\"\n"
                output += f"   - Wave count: \"{reasoning.get('wave_count', 'N/A')}\"\n"

                if 'exit_plan' in reasoning:
                    exit_plan = reasoning['exit_plan']
                    if trade.get('hit_target'):
                        output += f"   - Exit plan achieved: Hit profit target\n"
                    elif trade.get('hit_stop'):
                        output += f"   - Exit plan: Stopped out ({exit_plan.get('invalidation_reason', 'Stop loss hit')})\n"

                output += f"   - Confidence: {reasoning.get('confidence', 0):.2f}\n"
                output += f"   - Actual R:R: {trade.get('actual_rr', 0):.1f}:1\n"

            output += "\n"

        output += "---\n\n"
        return output

    def _format_screener_recommendations(self, screening_result: Dict[str, Any]) -> str:
        """Format the screener's automated recommendations."""
        output = "### CURRENT RECOMMENDATIONS FROM SCREENER\n\n"

        output += f"Symbol: {screening_result['symbol']}\n"
        output += f"Signal: {screening_result['direction'].upper()}\n"
        output += f"Suggested Entry: {screening_result['current_price']:.5f} (current price)\n"
        output += f"Suggested Stop Loss: {screening_result['stop_loss']:.5f} "

        # Calculate stop loss percentage
        sl_pct = abs((screening_result['stop_loss'] - screening_result['current_price']) / screening_result['current_price'] * 100)
        output += f"(-{sl_pct:.2f}% Fibonacci stop)\n"

        output += f"Suggested Take Profit: {screening_result['take_profit']:.5f} "

        # Calculate take profit percentage
        tp_pct = abs((screening_result['take_profit'] - screening_result['current_price']) / screening_result['current_price'] * 100)
        output += f"(+{tp_pct:.2f}% Golden Ratio target)\n"

        output += f"Suggested Leverage: {screening_result['leverage']}x (score-based)\n"

        position_size = 10.0  # 10% of capital
        output += f"Position Size: {position_size:.2f} EUR (10% of capital)\n"

        # Calculate risk and reward
        risk = abs(screening_result['current_price'] - screening_result['stop_loss']) * (position_size / screening_result['current_price'])
        reward = abs(screening_result['take_profit'] - screening_result['current_price']) * (position_size / screening_result['current_price'])
        rr_ratio = reward / risk if risk > 0 else 0

        output += f"Risk: {risk:.2f} EUR (distance to stop)\n"
        output += f"Potential Reward: {reward:.2f} EUR (distance to target)\n"
        output += f"Risk:Reward Ratio: {rr_ratio:.1f}:1\n\n"

        output += "---\n\n"
        return output

    def _format_task_definition(self) -> str:
        """Format the task definition for Claude."""
        return """### YOUR TASK

Based on this comprehensive Elliott Wave analysis and multi-timeframe data:

1. Should we enter this trade?
2. If YES, specify:
   - Exact entry price
   - Position size (in EUR)
   - Leverage (3x, 5x, or 8x)
   - Stop loss level
   - Take profit target
   - Invalidation condition (what would prove this analysis wrong?)
   - Your confidence score (0.0 to 1.0)
   - Brief justification (2-3 sentences explaining the Elliott Wave count)

3. If NO, explain:
   - What's missing or unclear in the setup?
   - What would you wait for before entering?
   - Are there any conflicting signals across timeframes?

Return your response in JSON format as specified in the system prompt."""

    def get_complete_prompt(
        self,
        screening_result: Dict[str, Any],
        time_series_data: Dict[str, Any],
        account_state: Dict[str, Any],
        trade_history: List[Dict[str, Any]],
        performance_metrics: Dict[str, Any]
    ) -> tuple[str, str]:
        """
        Get both system and user prompts.

        Returns:
            Tuple of (system_prompt, user_prompt)
        """
        user_prompt = self.build_user_prompt(
            screening_result,
            time_series_data,
            account_state,
            trade_history,
            performance_metrics
        )

        return self.system_prompt, user_prompt
