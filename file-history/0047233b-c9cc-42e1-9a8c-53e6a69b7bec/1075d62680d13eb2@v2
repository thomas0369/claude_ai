"""
Flask Backend for Elliott Wave Live Signals Web UI.

Provides REST API endpoints for:
- Scanning markets with cache support
- Claude CLI integration for signal analysis
- Real-time signal updates
"""

from flask import Flask, jsonify, request, send_from_directory
from flask_cors import CORS
from datetime import datetime, timezone, timedelta
import json
import logging
from typing import Dict, Any, List, Optional
import sys
from pathlib import Path

# Add src to path
sys.path.insert(0, str(Path(__file__).parent))

from screener import AssetScreener
from time_series_extractor import extract_from_screening_dataframes
from claude_prompt_builder import ClaudePromptBuilder
from claude_integration import create_claude_trader, ClaudeIntegrationError
from trade_history_manager import TradeHistoryManager
from performance_metrics import calculate_performance
import config

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = Flask(__name__)
CORS(app)  # Enable CORS for React frontend

# Global instances
screener = AssetScreener()
prompt_builder = ClaudePromptBuilder()
trade_history = TradeHistoryManager()

# Cache for market data
class MarketDataCache:
    """Simple in-memory cache for market data with TTL."""

    def __init__(self, ttl_minutes: int = 5):
        self.cache: Dict[str, Dict[str, Any]] = {}
        self.ttl = timedelta(minutes=ttl_minutes)

    def get(self, symbol: str) -> Optional[Dict[str, Any]]:
        """Get cached data if not expired."""
        if symbol not in self.cache:
            return None

        entry = self.cache[symbol]
        if datetime.now(timezone.utc) - entry['timestamp'] > self.ttl:
            # Expired
            del self.cache[symbol]
            return None

        return entry['data']

    def set(self, symbol: str, data: Dict[str, Any]) -> None:
        """Cache data with timestamp."""
        self.cache[symbol] = {
            'data': data,
            'timestamp': datetime.now(timezone.utc)
        }

    def clear(self) -> None:
        """Clear entire cache."""
        self.cache.clear()


cache = MarketDataCache(ttl_minutes=5)


@app.route('/')
def index():
    """Serve the frontend HTML."""
    frontend_dir = Path(__file__).parent / 'frontend'
    return send_from_directory(frontend_dir, 'index.html')


@app.route('/api/health', methods=['GET'])
def health_check():
    """Health check endpoint."""
    return jsonify({
        'status': 'healthy',
        'timestamp': datetime.now(timezone.utc).isoformat()
    })


@app.route('/api/scan', methods=['POST'])
def scan_markets():
    """
    Scan markets and analyze signals.

    Request body:
    {
        "symbols": ["EUR/USD", "BTC/USD"],  // Optional, defaults to all
        "min_score": 75,                     // Optional
        "use_claude": true,                  // Optional, default false
        "use_cache": true                    // Optional, default true
    }
    """
    try:
        data = request.get_json() or {}
        symbols = data.get('symbols', config.ALL_ASSETS)
        min_score = data.get('min_score', 75)
        use_claude = data.get('use_claude', False)
        use_cache = data.get('use_cache', True)

        logger.info(f"Scanning {len(symbols)} symbols (min_score: {min_score}, use_claude: {use_claude})")

        results = []
        scan_start = datetime.now(timezone.utc)

        for symbol in symbols:
            try:
                # Check cache first
                cached_data = cache.get(symbol) if use_cache else None

                if cached_data:
                    logger.info(f"{symbol}: Using cached data")
                    screening_result = cached_data['screening_result']
                else:
                    # Run screener
                    screening_result = screener.screen_asset(symbol)

                    if not screening_result:
                        logger.warning(f"{symbol}: No screening result")
                        continue

                    # Cache the result
                    if use_cache:
                        cache.set(symbol, {
                            'screening_result': screening_result,
                            'dataframes': None  # We'll fetch these when needed for Claude
                        })

                # Only include if score >= threshold
                if screening_result['score'] < min_score:
                    continue

                # Prepare result
                result = {
                    'symbol': symbol,
                    'category': _get_category(symbol),
                    'score': screening_result['score'],
                    'direction': screening_result['direction'],
                    'tradeable': screening_result['tradeable'],
                    'current_price': screening_result['current_price'],
                    'stop_loss': screening_result['stop_loss'],
                    'take_profit': screening_result['take_profit'],
                    'leverage': screening_result['leverage'],
                    'score_breakdown': screening_result['score_breakdown'],
                    'indicators': screening_result.get('indicators', {}),
                    'timestamp': screening_result['timestamp']
                }

                # If Claude analysis is requested for high-scoring signals
                if use_claude and screening_result['score'] >= 85:
                    logger.info(f"{symbol}: High score ({screening_result['score']}), calling Claude CLI...")
                    claude_analysis = _analyze_with_claude(symbol, screening_result)

                    if claude_analysis:
                        result['claude_analysis'] = claude_analysis
                        result['enhanced_score'] = _calculate_enhanced_score(
                            screening_result['score'],
                            claude_analysis
                        )

                results.append(result)

            except Exception as e:
                logger.error(f"Error scanning {symbol}: {e}", exc_info=True)
                continue

        # Sort by score (or enhanced_score if available)
        results.sort(
            key=lambda x: x.get('enhanced_score', x['score']),
            reverse=True
        )

        scan_duration = (datetime.now(timezone.utc) - scan_start).total_seconds()

        return jsonify({
            'success': True,
            'signals': results,
            'scan_info': {
                'total_scanned': len(symbols),
                'qualified_signals': len(results),
                'duration_seconds': scan_duration,
                'timestamp': datetime.now(timezone.utc).isoformat(),
                'min_score': min_score,
                'used_claude': use_claude
            }
        })

    except Exception as e:
        logger.error(f"Error in scan_markets: {e}", exc_info=True)
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/analyze/<symbol>', methods=['POST'])
def analyze_signal(symbol: str):
    """
    Analyze a specific signal with Claude CLI.

    Request body:
    {
        "screening_result": {...}  // Optional, will screen if not provided
    }
    """
    try:
        data = request.get_json() or {}
        screening_result = data.get('screening_result')

        if not screening_result:
            # Run screener
            screening_result = screener.screen_asset(symbol)
            if not screening_result:
                return jsonify({
                    'success': False,
                    'error': f'No screening result for {symbol}'
                }), 404

        # Analyze with Claude
        claude_analysis = _analyze_with_claude(symbol, screening_result)

        if not claude_analysis:
            return jsonify({
                'success': False,
                'error': 'Claude analysis failed'
            }), 500

        # Calculate enhanced score
        enhanced_score = _calculate_enhanced_score(
            screening_result['score'],
            claude_analysis
        )

        return jsonify({
            'success': True,
            'symbol': symbol,
            'original_score': screening_result['score'],
            'enhanced_score': enhanced_score,
            'claude_analysis': claude_analysis
        })

    except Exception as e:
        logger.error(f"Error analyzing {symbol}: {e}", exc_info=True)
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


@app.route('/api/cache/clear', methods=['POST'])
def clear_cache():
    """Clear the market data cache."""
    cache.clear()
    return jsonify({
        'success': True,
        'message': 'Cache cleared'
    })


@app.route('/api/performance', methods=['GET'])
def get_performance():
    """Get trading performance metrics."""
    try:
        account_state = trade_history.get_account_state(initial_capital=100.0)
        performance = calculate_performance(
            trade_history.get_closed_trades(),
            account_state['available_capital'],
            initial_capital=100.0
        )

        return jsonify({
            'success': True,
            'performance': performance,
            'account_state': account_state
        })

    except Exception as e:
        logger.error(f"Error getting performance: {e}", exc_info=True)
        return jsonify({
            'success': False,
            'error': str(e)
        }), 500


def _get_category(symbol: str) -> str:
    """Determine asset category from symbol."""
    if '/' in symbol:
        if any(crypto in symbol for crypto in ['BTC', 'ETH', 'BNB', 'SOL']):
            return 'Crypto'
        else:
            return 'Forex Majors'
    elif 'XAU' in symbol or 'XAG' in symbol:
        return 'Commodities'
    else:
        return 'Other'


def _analyze_with_claude(symbol: str, screening_result: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    """
    Analyze a signal with Claude CLI.

    Returns Claude's decision or None if analysis fails.
    """
    try:
        # Get fresh dataframes for time series extraction
        screening_dataframes = screener._fetch_multi_timeframe_data(symbol)
        if not screening_dataframes:
            logger.warning(f"No dataframes for {symbol}")
            return None

        screening_dataframes = screener._calculate_indicators(screening_dataframes)

        # Extract time series
        time_series_data = extract_from_screening_dataframes(screening_dataframes)

        # Get account state
        account_state = trade_history.get_account_state(initial_capital=100.0)

        # Get recent trades
        recent_trades = trade_history.get_recent_trades(count=5)

        # Calculate performance
        performance = calculate_performance(
            trade_history.get_closed_trades(),
            account_state['available_capital'],
            initial_capital=100.0
        )

        # Build prompts
        system_prompt, user_prompt = prompt_builder.get_complete_prompt(
            screening_result=screening_result,
            time_series_data=time_series_data,
            account_state=account_state,
            trade_history=recent_trades,
            performance_metrics=performance
        )

        # Call Claude CLI
        claude = create_claude_trader(method='cli', simulate=False)
        decision = claude.analyze_trade(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            screening_result=screening_result
        )

        return decision

    except ClaudeIntegrationError as e:
        logger.error(f"Claude integration error for {symbol}: {e}")
        return None
    except Exception as e:
        logger.error(f"Error analyzing {symbol} with Claude: {e}", exc_info=True)
        return None


def _calculate_enhanced_score(base_score: int, claude_analysis: Dict[str, Any]) -> int:
    """
    Calculate enhanced score incorporating Claude's confidence and analysis.

    Logic:
    - High confidence (>0.8) + buy/sell signal: +10 points
    - Medium confidence (0.6-0.8) + buy/sell signal: +5 points
    - Low confidence (<0.6) or hold: +0 points
    - Concerns present: -5 points
    """
    enhanced = base_score

    signal = claude_analysis.get('signal', 'hold')
    confidence = claude_analysis.get('confidence', 0)
    concerns = claude_analysis.get('concerns', '')

    # Bonus for actionable signals with confidence
    if signal in ['buy', 'sell']:
        if confidence >= 0.8:
            enhanced += 10
        elif confidence >= 0.6:
            enhanced += 5

    # Penalty for concerns
    if concerns and len(concerns) > 20:  # Non-trivial concern
        enhanced -= 5

    # Cap at 194 (max possible score)
    return min(enhanced, 194)


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(description='Elliott Wave Web Backend')
    parser.add_argument('--host', default='127.0.0.1', help='Host to bind to')
    parser.add_argument('--port', type=int, default=5000, help='Port to bind to')
    parser.add_argument('--debug', action='store_true', help='Enable debug mode')

    args = parser.parse_args()

    logger.info(f"Starting Flask backend on {args.host}:{args.port}")
    app.run(host=args.host, port=args.port, debug=args.debug)
