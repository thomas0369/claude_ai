"""
Performance Metrics Calculator - Computes trading performance statistics.

Calculates:
- Total return (%)
- Win rate (%)
- Average risk:reward ratio
- Sharpe ratio
- Maximum drawdown
- Profit factor
- Average win/loss
"""

from typing import List, Dict, Any
import numpy as np
from datetime import datetime
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class PerformanceMetrics:
    """Calculates trading performance metrics from trade history."""

    def __init__(self, initial_capital: float = 100.0):
        """
        Initialize performance calculator.

        Args:
            initial_capital: Starting capital in EUR
        """
        self.initial_capital = initial_capital

    def calculate_metrics(
        self,
        trade_history: List[Dict[str, Any]],
        current_capital: float
    ) -> Dict[str, float]:
        """
        Calculate comprehensive performance metrics.

        Args:
            trade_history: List of closed trades
            current_capital: Current account balance

        Returns:
            Dictionary of performance metrics
        """
        if not trade_history:
            return self._get_empty_metrics()

        # Filter to only closed trades (have exit_price and pnl)
        closed_trades = [
            t for t in trade_history
            if 'exit_price' in t and 'pnl' in t
        ]

        if not closed_trades:
            return self._get_empty_metrics()

        metrics = {}

        # Total return
        metrics['total_return_pct'] = (
            (current_capital - self.initial_capital) / self.initial_capital * 100
        )

        # Win rate
        wins = [t for t in closed_trades if t.get('pnl', 0) > 0]
        losses = [t for t in closed_trades if t.get('pnl', 0) <= 0]
        metrics['win_rate'] = len(wins) / len(closed_trades) * 100 if closed_trades else 0

        # Number of trades
        metrics['total_trades'] = len(closed_trades)
        metrics['wins'] = len(wins)
        metrics['losses'] = len(losses)

        # Average risk:reward ratio
        rr_ratios = [t.get('actual_rr', 0) for t in closed_trades if t.get('actual_rr')]
        metrics['avg_risk_reward'] = np.mean(rr_ratios) if rr_ratios else 0

        # Average win and loss
        if wins:
            metrics['avg_win'] = np.mean([t['pnl'] for t in wins])
            metrics['avg_win_pct'] = np.mean([t.get('pnl_pct', 0) for t in wins])
        else:
            metrics['avg_win'] = 0
            metrics['avg_win_pct'] = 0

        if losses:
            metrics['avg_loss'] = np.mean([t['pnl'] for t in losses])
            metrics['avg_loss_pct'] = np.mean([t.get('pnl_pct', 0) for t in losses])
        else:
            metrics['avg_loss'] = 0
            metrics['avg_loss_pct'] = 0

        # Profit factor
        total_wins = sum(t['pnl'] for t in wins) if wins else 0
        total_losses = abs(sum(t['pnl'] for t in losses)) if losses else 0
        metrics['profit_factor'] = (
            total_wins / total_losses if total_losses > 0 else float('inf') if total_wins > 0 else 0
        )

        # Sharpe ratio (annualized)
        metrics['sharpe_ratio'] = self._calculate_sharpe_ratio(closed_trades)

        # Maximum drawdown
        metrics['max_drawdown'] = self._calculate_max_drawdown(closed_trades)

        # Expectancy (average expected profit per trade)
        win_rate_decimal = metrics['win_rate'] / 100
        loss_rate_decimal = 1 - win_rate_decimal
        metrics['expectancy'] = (
            win_rate_decimal * metrics['avg_win'] -
            loss_rate_decimal * abs(metrics['avg_loss'])
        )

        # Largest win/loss
        if closed_trades:
            metrics['largest_win'] = max(t.get('pnl', 0) for t in closed_trades)
            metrics['largest_loss'] = min(t.get('pnl', 0) for t in closed_trades)
            metrics['largest_win_pct'] = max(t.get('pnl_pct', 0) for t in closed_trades)
            metrics['largest_loss_pct'] = min(t.get('pnl_pct', 0) for t in closed_trades)

        return metrics

    def _calculate_sharpe_ratio(
        self,
        closed_trades: List[Dict[str, Any]],
        risk_free_rate: float = 0.02  # 2% annual risk-free rate
    ) -> float:
        """
        Calculate Sharpe ratio (annualized).

        Args:
            closed_trades: List of closed trades
            risk_free_rate: Annual risk-free rate (default 2%)

        Returns:
            Sharpe ratio
        """
        if len(closed_trades) < 2:
            return 0.0

        # Get returns as percentages
        returns = np.array([t.get('pnl_pct', 0) / 100 for t in closed_trades])

        # Calculate mean and std of returns
        mean_return = np.mean(returns)
        std_return = np.std(returns, ddof=1)  # Sample std

        if std_return == 0:
            return 0.0

        # Assume average 1 trade per day for annualization (can be adjusted)
        # If you trade less frequently, this should be adjusted
        trades_per_year = 252  # Trading days per year

        # Annualize the returns and volatility
        annual_return = mean_return * trades_per_year
        annual_std = std_return * np.sqrt(trades_per_year)

        # Sharpe ratio
        sharpe = (annual_return - risk_free_rate) / annual_std

        return sharpe

    def _calculate_max_drawdown(
        self,
        closed_trades: List[Dict[str, Any]]
    ) -> float:
        """
        Calculate maximum drawdown from peak.

        Args:
            closed_trades: List of closed trades

        Returns:
            Maximum drawdown as percentage
        """
        if not closed_trades:
            return 0.0

        # Build equity curve
        equity = [self.initial_capital]
        for trade in closed_trades:
            equity.append(equity[-1] + trade.get('pnl', 0))

        equity = np.array(equity)

        # Calculate running maximum
        running_max = np.maximum.accumulate(equity)

        # Calculate drawdown at each point
        drawdown = (equity - running_max) / running_max * 100

        # Return maximum drawdown (most negative value)
        max_dd = np.min(drawdown)

        return max_dd

    def _get_empty_metrics(self) -> Dict[str, float]:
        """Return empty metrics structure when no trades available."""
        return {
            'total_return_pct': 0.0,
            'win_rate': 0.0,
            'total_trades': 0,
            'wins': 0,
            'losses': 0,
            'avg_risk_reward': 0.0,
            'avg_win': 0.0,
            'avg_loss': 0.0,
            'avg_win_pct': 0.0,
            'avg_loss_pct': 0.0,
            'profit_factor': 0.0,
            'sharpe_ratio': 0.0,
            'max_drawdown': 0.0,
            'expectancy': 0.0,
            'largest_win': 0.0,
            'largest_loss': 0.0,
            'largest_win_pct': 0.0,
            'largest_loss_pct': 0.0,
        }

    def format_metrics_report(self, metrics: Dict[str, float]) -> str:
        """
        Format metrics as a readable report.

        Args:
            metrics: Performance metrics dictionary

        Returns:
            Formatted string report
        """
        report = "=== PERFORMANCE METRICS ===\n\n"

        report += f"Total Return: {metrics['total_return_pct']:+.2f}%\n"
        report += f"Total Trades: {int(metrics['total_trades'])} "
        report += f"(W: {int(metrics['wins'])}, L: {int(metrics['losses'])})\n"
        report += f"Win Rate: {metrics['win_rate']:.1f}%\n"
        report += f"\n"

        report += f"Average R:R: {metrics['avg_risk_reward']:.2f}:1\n"
        report += f"Profit Factor: {metrics['profit_factor']:.2f}\n"
        report += f"Expectancy: {metrics['expectancy']:+.2f} EUR per trade\n"
        report += f"\n"

        report += f"Average Win: {metrics['avg_win']:+.2f} EUR ({metrics['avg_win_pct']:+.2f}%)\n"
        report += f"Average Loss: {metrics['avg_loss']:+.2f} EUR ({metrics['avg_loss_pct']:+.2f}%)\n"
        report += f"Largest Win: {metrics['largest_win']:+.2f} EUR ({metrics['largest_win_pct']:+.2f}%)\n"
        report += f"Largest Loss: {metrics['largest_loss']:+.2f} EUR ({metrics['largest_loss_pct']:+.2f}%)\n"
        report += f"\n"

        report += f"Sharpe Ratio: {metrics['sharpe_ratio']:.2f}\n"
        report += f"Max Drawdown: {metrics['max_drawdown']:.2f}%\n"

        return report


def calculate_performance(
    trade_history: List[Dict[str, Any]],
    current_capital: float,
    initial_capital: float = 100.0
) -> Dict[str, float]:
    """
    Convenience function to calculate performance metrics.

    Args:
        trade_history: List of trade dictionaries
        current_capital: Current account balance
        initial_capital: Starting capital

    Returns:
        Performance metrics dictionary
    """
    calculator = PerformanceMetrics(initial_capital=initial_capital)
    return calculator.calculate_metrics(trade_history, current_capital)
